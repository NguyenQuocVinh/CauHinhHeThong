#!/bin/env bash
# Copyright (c) 2002, 2013, Oracle and/or its affiliates. All rights reserved.
# Name raccheck.sh - checks Oracle best practices and patches on all nodes in clustered environment
#Caution This script is provided for educational purposes only and not supported by Oracle Support Services. It has been tested internally, however, and works as documented. We do not guarantee that it will work for you, so be sure to test it in your environment before relying on it.Proofread this script before using it! Due to the differences in the way text editors, e-mail packages and operating systems handle text formatting (spaces, tabs and carriage returns), this script may not be in an executable state when you first receive it. Check over the script to ensure that errors of this type are corrected. 

##############################################################################
# Authors        : Bob Caldwell, Girdhari Ghantiyala and Girish Adiga
# Creation Date : 18-Apr-2008
# Purpose       : Tool for checking best practices
#
##############################################################################

usage()
{
#if [ $# -lt 1 ]
#then
#    TYP="-a"
#else
cat <<EOF
Usage : ./${program_name} [-abvhpfmsuSo:c:t:] 
        -a      All (Perform best practice check and recommended patch check)
        -b      Best Practice check only. No recommended patch check
        -h      Show usage
        -v      Show version 
        -p      Patch check only
        -m      exclude checks for Maximum Availability Architecture scorecards(see user guide for more details)
        -u      Run ${program_name} to check pre-upgrade or post-upgrade best practices for 11.2.0.3 and 12.1.0.1
                -o pre or -o post is mandatory with -u option like ./${program_name} -u -o pre
        -f      Run Offline.Checks will be performed on data already collected from the customer system
        -o      Argument to an option. if -o is followed by v,V,Verbose,VERBOSE or Verbose, it will print checks which passs on the screen
                if -o option is not specified,it will print only failures on screen. for eg: ${program_name} -a -o v 

        -clusternodes
                Pass comma separated node names to run ${program_name} only on selected nodes.
        -localonly
                Run ${program_name} only on local node.

        -nopass
                Do not print PASS'ed checks in HTML report.

        -noscore
                Do not print healthscore in HTML report.

        -diff <Old Report> <New Report> [-outfile <Output HTML>]
                Diff two ${program_name} reports. Pass directory name or zip file or html report file as <Old Report> & <New Report> 

        -c     Used only under the guidance of Oracle support or development to override default components 

        -d <start|stop|status>
               start      : Start the ${program_name} daemon
               stop       : Stop the ${program_name} daemon
               status     : Check if the ${program_name} daemon is running
               nextautorun: print the next auto run time
        -daemon
               Used to specify that run ${program_name} only if daemon is running
        -nodaemon
               Dont use ${program_name} daemon to run command
        -set "param1=value1;param2=value2.."
               Set ${program_name} config parameter
               Supported parameters are:
                 AUTORUN_INTERVAL <n[d|h]> : Automatic rerun interval in daemon mode. 
                                             Set it zero to disable automatic rerun. Default is zero.
                 AUTORUN_FLAGS <flags> : ${program_name} flags to use for auto runs.
                 Ex: ${program_name} -set "AUTORUN_INTERVAL=12h;AUTORUN_FLAGS=-profile sysadmin"
                     This will run sysadmin profile every 12 hours
                     ${program_name} -set "AUTORUN_INTERVAL=2d;AUTORUN_FLAGS=-profile sysadmin"
                     This will run sysadmin profile once every 2 days.
                 NOTIFICATION_EMAIL : Email address used for notifications by daemon if mail server is configured.
                 PASSWORD_CHECK_INTERVAL <number of hours> : In daemon mode, interval to check change in password
        -get <parameter | all>
               Print the value of parameter

        -profile Pass specific profile. 
                 List of supported profiles: 
EOF
if [ -e $SCRIPTPATH/.cgrep/profiles.dat ]
then
    if [[ ${program_name} = "raccheck" || ${program_name} = "odachk" ]] ; then
      cat $SCRIPTPATH/.cgrep/profiles.dat| grep -v "^.-"| sort |grep -ivw "ControlVM" | grep -ivw "Switch" | grep -v "storage" | grep -v "virtual_infra"|awk -F"|" '{printf "                 %-15s %-20s\n",$1,$NF}' 
    else # Show all
      cat $SCRIPTPATH/.cgrep/profiles.dat| grep -v "^.-"|sort | awk -F"|" '{printf "                 %-15s %-20s\n",$1,$NF}' 
        echo -e "\n        -cells
                Pass comma separated storage server names to run ${program_name} only on selected storage servers.\n
        -ibswitches
                Pass comma separated infiniband switch names to run ${program_name} only on selected infiniband switches.\n
        -zfsnodes
                Pass comma separated ZFS storage appliance names to run ${program_name} only on selected storage appliances."
    fi
fi
exit 1
#fi 
}

#        -s      Run silent mode, does not ask if environment is set correctly, assumes it is.  Also runs with sudo for oracle assumed.
#set up for changing colors of output lines
#site for examples of colors http://oinkzwurgl.org/bashrc
GREEN="\033[1;32;40m"
#ORANGE="\033[33;40m"
ORANGE="\033[33;44m"
#RED="\033[1;31;40m"
RED="\033[1;37;41m"
#BLUE="\033[1;34;40m"
BLUE="\033[1;30;46m"
CYAN="\033[1;36;40m"
NORM="\033[0m"
BOLD="\033[1m"
#BLINK="\033[5m"
GREEN="\033[1;32;40m"
ORANGE="\033[33;40m"
RED="\033[1;31;40m"
BLUE="\033[1;34;40m"
#Added validation to make sure supported bash version is there
bash_version=$(bash -version|head -1|awk '{print $4}'|cut -d. -f1-2|tr -d '.')
bash_version_msg=$(bash -version|head -1|awk '{print $4}'|cut -d. -f1-2)
program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
if [[ -n "$bash_version" && $bash_version -lt 30 ]]
then
    echo -e "\n${RED}${program_name} is not supported on bash version ${bash_version_msg}. It requires bash version 3.2 and above. Use bash -version command to verify ${NORM}\n"
    exit
fi
if [ -f "/bin/gawk" ]
then
  AWK=gawk
else
  AWK=awk
fi

#Function to Fix root password
fixRootPassword ()
{
 inputPassword=$1
 fixedRootPassword=$(echo "$inputPassword" | sed 's/\\/\\\\/g')
}

get_check_env_file ()
{
  # Cluster, platform details are read from end file in offline mode
  if [ -e "$OUTPUTDIR/check_env.out" ]
  then
    check_env_file=$OUTPUTDIR/check_env.out
  else
    check_env_file=$OUTPUTDIR/raccheck_env.out
  fi
}

read_env_file_for_cs_nodes ()
{
  get_check_env_file;

  el_db_node=""
  el_ec1_node=""
  el_ovmm_node=""
  el_pc_nodes=""
  el_pc1_node=""
  el_pc2_node=""

  if [[ -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ;then
    el_db_node=$(grep '\.COMPONENT = .*EXALOGIC_DB' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u)
    el_ec1_node=$(grep '\.COMPONENT = .*EXALOGIC_EC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u)
    el_ovmm_node=$(grep '\.COMPONENT = .*EXALOGIC_OVMM' $check_env_file |sed 's/\.COMPONENT.*//' | sort -u)
    el_pc_nodes=$(grep '\.COMPONENT = .*EXALOGIC_PC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u)
    el_pc1_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u | head -1)
    el_pc2_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $check_env_file |sed 's/\.COMPONENT.*//'| sort -u | tail -1)
  fi
}

get_el_prefix()
{
  if [[ -z "$el_db_node" ]] ; then
    read_env_file_for_cs_nodes
  fi

  el_hname=$1
  case $el_hname in
    $el_db_node)
      el_prefix="DB";;
    $el_ec1_node)
      el_prefix="EC";;
    $el_ovmm_node)
      el_prefix="OVMM";;
    "$el_pc1_node"|"$el_pc2_node")
      el_prefix="PC";;
    *)
      el_prefix="CN";;
  esac
}

prompt_for_pass()
{
  # $usern  $hname
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
  then
    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" ]]
    then # Get type of node
      case $hname in 
        $ea_db_node)
          el_prefix="DB";;
        $ea_ec1_node)
          el_prefix="EC";;
        $ea_ovmm_node)
          el_prefix="OVMM";;
        "$ea_pc1_node"|"$ea_pc2_node")
          el_prefix="PC";;
        *)
          el_prefix="CN";;
      esac
    fi

    ask_pass=0
    go_back=0
    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" && $el_prefix = "CN" && -n "$use_expect_for_ssh_cn" && $use_expect_for_ssh_cn -eq "1" ]]
    then # Already prompted for compute node password in new exalogic..
      go_back=1
      if [[ -n "$node_samerootpassword_cn" && $node_samerootpassword_cn -eq "0" ]] ; then ask_pass=1 ; fi
    elif [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" && $el_prefix != "CN" && -n "$use_expect_for_ssh_vm" && $use_expect_for_ssh_vm -eq "1" ]]
    then # Already prompted for control server password in new exalogic..
      go_back=1
      if [[ -n "$node_samerootpassword_vm" && $node_samerootpassword_vm -eq "0" ]] ; then ask_pass=1 ; fi
    elif [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" && $in_ec_exalogic -eq "0" ]]
    then # Already prompted for password, so we have details
      go_back=1
      if [[ -n "$node_samerootpassword" && $node_samerootpassword -eq "0" ]] ; then ask_pass=1 ; fi
    fi

    if [[ $go_back -eq "1" ]] ; then
      if [[ $ask_pass -eq "1" ]]
      then # Get nodepassword
        echo -e "\n"
        printf  "Enter ${usern} password on $hname ${NORM} :- "
        stty -echo
        read -r node_rootpassword
        stty echo
        checkUserPassword "$hname" "$usern" "$node_rootpassword" "3"
      fi
      return 0;
    fi

    use_expect_for_ssh=1

    node_type="nodes"
    node_type2=""
    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" ]] ; then
      if [[ $el_prefix = "CN" ]] ; then 
        use_expect_for_ssh_cn=1
        node_type="Compute Nodes"
      else
        node_type="Control VM's"
        node_type2="(EC,OVMM,DB,PC)"
        use_expect_for_ssh_vm=1
      fi
    fi

    echo -e  "We can configure ssh on all $node_type $node_type2 without prompting for password on each host if password is same on all $node_type."
    read -p  "Is ${usern} password same on all $node_type?[y/n][y]" node_samerootpassword_yes
    case $node_samerootpassword_yes in
      n|N|No|NO|no)
        node_samerootpassword=0
        echo "Enter password for each host when prompted."
        echo -e "\n"
        printf  "Enter ${usern} password on $hname ${NORM} :- "
        stty -echo
        read -r node_rootpassword
        stty echo
        checkUserPassword "$hname" "$usern" "$node_rootpassword" "3"
        ;;
      *)
        echo -e "\n"
        printf  "Enter ${usern} password ${NORM} :- "
        stty -echo
        read -r node_rootpassword
        stty echo
        checkUserPassword "$hname" "$usern" "$node_rootpassword" "3"
        if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
        then
          node_samerootpassword=1
        else
          node_samerootpassword=0
        fi
        ;;
    esac

    if [[ -n $in_ec_exalogic && $in_ec_exalogic -eq "1" ]] ; then
      if [[ $el_prefix = "CN" ]] ; then
        node_samerootpassword_cn=$node_samerootpassword
        node_rootpassword_cn=$node_rootpassword
      else
        node_samerootpassword_vm=$node_samerootpassword
        node_rootpassword_vm=$node_rootpassword
      fi
    fi
  fi

  if [ -e "$EXPECT" ] ; then
    echo -e "\n"
    node_rootpassword=$passwordToCheck;
    if [[ -z "$node_rootpassword" || $passwordCheckStatus -ne 0 ]]
    then  
    	printf  "Enter ${usern} password on $hname ${NORM} :- "
    	stty -echo
    	read -r node_rootpassword
    	stty echo
    fi
    checkUserPassword "$hname" "$usern" "$node_rootpassword" "3"
    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
    then
      if [ -z "$node_index" ] ; then node_index=0; fi
      a_node_names[$node_index]=$hname;
      a_node_passwords[$node_index]="$node_rootpassword";
      node_index=$(expr $node_index + 1)
      use_expect_for_ssh=1
    fi
  fi
}


#follwoing fuction is to setup ssh at given node
func_setup_ssh ()
{ 

prompt_for_pass  # Ask user if we need to setup automatically.
local numargs=$#
local ADVANCED=false
local HOSTNAME=`hostname`
local CONFIRM=no
local SHARED=false
local i=1
local USR=$USER
if  test -z "$TEMP"
then
  local TEMP=/tmp
fi
local IDENTITY=id_dsa
#local LOGFILE=$TEMP/sshUserSetup_`date +%F-%H-%M-%S`.log
local LOGFILE=/dev/null
local VERIFY=false
local EXHAUSTIVE_VERIFY=false
local HELP=false
local PASSPHRASE=no
local RERUN_SSHKEYGEN=no
local NO_PROMPT_PASSPHRASE=yes
local j=""
local HOSTS=""
local USR=""
while [ $i -le $numargs ]
do
  j=$1 
  if [ $j = "-hosts" ] 
  then
     HOSTS=$2
     shift 1
     i=`expr $i + 1`
  fi
  if [ $j = "-user" ] 
  then
     USR=$2
     shift 1
     i=`expr $i + 1`
   fi
  if [ $j = "-logfile" ] 
  then
     LOGFILE=$2
     shift 1
     i=`expr $i + 1`
   fi
  if [ $j = "-confirm" ] 
  then
     CONFIRM=yes
   fi
  if [ $j = "-hostfile" ] 
  then
     CLUSTER_CONFIGURATION_FILE=$2
     shift 1
     i=`expr $i + 1`
   fi
  if [ $j = "-usePassphrase" ] 
  then
     PASSPHRASE=yes
   fi
  if [ $j = "-noPromptPassphrase" ] 
  then
     NO_PROMPT_PASSPHRASE=yes
   fi
  if [ $j = "-shared" ] 
  then
     SHARED=true
   fi
  if [ $j = "-exverify" ] 
  then
     EXHAUSTIVE_VERIFY=true
   fi
  if [ $j = "-verify" ] 
  then
     VERIFY=true
   fi
  if [ $j = "-advanced" ] 
  then
     ADVANCED=true
   fi
  if [ $j = "-help" ] 
  then
     HELP=true
   fi
  i=`expr $i + 1`
  shift 1
done


if [ $HELP = "true" ]
then
  echo "Usage $0 -user <user name> [ -hosts \"<space separated hostlist>\" | -hostfile <absolute path of cluster configuration file> ] [ -advanced ]  [ -verify] [ -exverify ] [ -logfile <desired absolute path of logfile> ] [-confirm] [-shared] [-help] [-usePassphrase] [-noPromptPassphrase]"
exit
fi

if test -z "$HOSTS"
then
   if test -n "$CLUSTER_CONFIGURATION_FILE" && test -f "$CLUSTER_CONFIGURATION_FILE"
   then
      HOSTS=`awk '$1 !~ /^#/ { str = str " " $1 } END { print str }' $CLUSTER_CONFIGURATION_FILE` 
   elif ! test -f "$CLUSTER_CONFIGURATION_FILE"
   then
     echo "Please specify a valid and existing cluster configuration file."
   fi
fi

if  test -z "$HOSTS" || test -z $USR
then
echo "Either user name or host information is missing"
echo "Usage $0 -user <user name> [ -hosts \"<space separated hostlist>\" | -hostfile <absolute path of cluster configuration file> ] [ -advanced ]  [ -verify] [ -exverify ] [ -logfile <desired absolute path of logfile> ] [-confirm] [-shared] [-help] [-usePassphrase] [-noPromptPassphrase]" 
return 1
fi

#echo Hosts are $HOSTS | tee -a $LOGFILE
#echo user is  $USR | tee -a $LOGFILE
SSH="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
SSH_KEYGEN="/usr/bin/ssh-keygen"
calculateOS()
{
    platform=`uname -s`
    case "$platform"
    in
       "SunOS")  SSH="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
                 SSH_KEYGEN="/usr/bin/ssh-keygen"
                 os=solaris;;
       "Linux")  os=linux;;
       "HP-UX")  os=hpunix;;
         "AIX")  os=aix;;
             *)  echo "Sorry, $platform is not currently supported." | tee -a $LOGFILE
                 return 1;;
    esac

    #echo "Platform:- $platform " | tee -a $LOGFILE
}
calculateOS
BITS=1024
ENCR="dsa"

deadhosts=""
alivehosts=""
PING_W_FLAG=""
echo Checking if the remote hosts are reachable >> $LOGFILE
if [ $platform = "Linux" ]
then
    PING="/bin/ping"
    PING_W_FLAG="-w 5"
else
    PING="/usr/sbin/ping"
fi
for host in $HOSTS
do
   if [ $platform = "SunOS" ]; then
       $PING -s $host 5 5 >/dev/null 2>&1
   elif [ $platform = "HP-UX" ]; then
       $PING $host -n 5 -m 5 >/dev/null 2>&1
   else
       $PING -c 1 $PING_W_FLAG $host >/dev/null 2>&1
   fi
  exitcode=`echo $?`
  if [ $exitcode = 0 ]
  then
     alivehosts="$alivehosts $host"
  else
     deadhosts="$deadhosts $host"
  fi
done

if test -z "$deadhosts"
then
   echo Remote host reachability check succeeded >> $LOGFILE
   #echo The following hosts are reachable: $alivehosts.  | tee -a $LOGFILE
   #echo The following hosts are not reachable: $deadhosts.  | tee -a $LOGFILE
   #echo All hosts are reachable. Proceeding further...  | tee -a $LOGFILE
else
   echo Remote host reachability check failed.  >>$LOGFILE
   #echo The following hosts are reachable: $alivehosts.  | tee -a $LOGFILE
   #echo The following hosts are not reachable: $deadhosts.  | tee -a $LOGFILE
   #echo Please ensure that all the hosts are up and re-run the script.  | tee -a $LOGFILE
   #echo Exiting now...  | tee -a $LOGFILE
   return 1
fi
if [ $platform = "HP-UX" ]
then
    firsthost=`echo $HOSTS | awk '{print $1}; END { }'`
    echo firsthost $firsthost
    numhosts=`echo $HOSTS | awk '{ }; END {print NF}'`
    echo numhosts $numhosts
else
    declare -a HOSTSARR="( $HOSTS )"
    firsthost=${HOSTSARR[0]}
    typeset -i numhosts=${#HOSTSARR[@]} 
fi

if [ $VERIFY = "true" ]
then
   echo Since user has specified -verify option, SSH setup will not be performed. Existing SSH setup will be verified instead. >>$LOGFILE
   continue
else
#echo The script will setup SSH connectivity from the host ''`hostname`'' to all  | tee -a $LOGFILE 
#echo the remote hosts. After the script is executed, the user can use SSH to run  | tee -a $LOGFILE 
#echo commands on the remote hosts or copy files between this host ''`hostname`'' | tee -a $LOGFILE 
#echo and the remote hosts without being prompted for passwords or confirmations. | tee -a $LOGFILE 
#echo  | tee -a $LOGFILE 
#echo NOTE 1: | tee -a $LOGFILE 
#echo As part of the setup procedure, this script will use 'ssh' and 'scp' to copy | tee -a $LOGFILE 
#echo files between the local host and the remote hosts. Since the script does not  | tee -a $LOGFILE 
#echo store passwords, you may be prompted for the passwords during the execution of  | tee -a $LOGFILE 
#echo the script whenever 'ssh' or 'scp' is invoked. | tee -a $LOGFILE 
#echo  | tee -a $LOGFILE 
#echo NOTE 2: | tee -a $LOGFILE 
#echo "AS PER SSH REQUIREMENTS, THIS SCRIPT WILL SECURE THE USER HOME DIRECTORY" | tee -a $LOGFILE 
#echo AND THE .ssh DIRECTORY BY REVOKING GROUP AND WORLD WRITE PRIVILEDGES TO THESE  | tee -a $LOGFILE 
#echo "directories." | tee -a $LOGFILE 
#echo  | tee -a $LOGFILE 
#echo "Do you want to continue and let the script make the above mentioned changes (yes/no)?" | tee -a $LOGFILE 

#Added by to overwrite variable
CONFIRM=yes
if [ "$CONFIRM" = "no" ] 
then 
  read CONFIRM 
else
  echo "Confirmation provided on the command line" >>$LOGFILE
fi 
   
#echo  | tee -a $LOGFILE 
#echo The user chose ''$CONFIRM'' | tee -a $LOGFILE 
 
if [ "$CONFIRM" = "no" ] 
then 
  echo "SSH setup has not been performed." >> $LOGFILE 
  return 1 
else 
  NO_PROMPT_PASSPHRASE=yes
  if [ $NO_PROMPT_PASSPHRASE = "yes" ]
  then
    echo "User chose to skip passphrase related questions."  >>$LOGFILE
  else
    typeset -i PASSPHRASE_PROMPT
    if [ $SHARED = "true" ]
    then
	  PASSPHRASE_PROMPT=2*${numhosts}+1
    else
	  PASSPHRASE_PROMPT=2*${numhosts} 
    fi
    echo "Please indicate whether you want to specify a passphrase for the private key this script will create for the local host. The passphrase is used to encrypt the private key and makes SSH much more secure. Type 'yes' or 'no' and then press enter. If you press 'yes', you will need to enter the passphrase whenever the script executes ssh or scp. " >>$LOGFILE
    echo "The estimated number of times the user will be prompted for a passphrase is $PASSPHRASE_PROMPT. In addition, if the private-public files are also newly created, the user would have to specify the passphrase on one additional occasion. " | tee -a $LOGFILE
    echo "Enter 'yes' or 'no'." >>$LOGFILE
    if [ $PASSPHRASE = "no" ]
    then
      read PASSPHRASE
    else
      echo "Confirmation provided on the command line" >>$LOGFILE
    fi 

    echo  | tee -a $LOGFILE 
    echo The user chose ''$PASSPHRASE'' >> $LOGFILE 

    if [ "$PASSPHRASE" = "yes" ] 
    then 
       RERUN_SSHKEYGEN="yes"
#Checking for existence of ${IDENTITY} file
       if test -f  $HOME/.ssh/${IDENTITY}.pub && test -f  $HOME/.ssh/${IDENTITY} 
       then
	     echo "The files containing the client public and private keys already exist on the local host. The current private key may or may not have a passphrase associated with it. In case you remember the passphrase and do not want to re-run ssh-keygen, press 'no' and enter. If you press 'no', the script will not attempt to create any new public/private key pairs. If you press 'yes', the script will remove the old private/public key files existing and create new ones prompting the user to enter the passphrase. If you enter 'yes', any previous SSH user setups would be reset. If you press 'change', the script will associate a new passphrase with the old keys." | tee -a $LOGFILE
	     echo "Press 'yes', 'no' or 'change'" >> $LOGFILE
             read RERUN_SSHKEYGEN 
             echo The user chose ''$RERUN_SSHKEYGEN'' >> $LOGFILE 
       fi 
     else
       if test -f  $HOME/.ssh/${IDENTITY}.pub && test -f  $HOME/.ssh/${IDENTITY} 
       then
         echo "The files containing the client public and private keys already exist on the local host. The current private key may have a passphrase associated with it. In case you find using passphrase inconvenient(although it is more secure), you can change to it empty through this script. Press 'change' if you want the script to change the passphrase for you. Press 'no' if you want to use your old passphrase, if you had one."
         read RERUN_SSHKEYGEN 
         echo The user chose ''$RERUN_SSHKEYGEN'' >> $LOGFILE 
       fi
     fi
  fi
  #echo Creating .ssh directory on local host, if not present already | tee -a $LOGFILE
  mkdir -p $HOME/.ssh | tee -a $LOGFILE
#echo Creating authorized_keys file on local host  | tee -a $LOGFILE
touch $HOME/.ssh/authorized_keys  | tee -a $LOGFILE
#echo Changing permissions on authorized_keys to 644 on local host  | tee -a $LOGFILE
chmod 644 $HOME/.ssh/authorized_keys  | tee -a $LOGFILE
mv -f $HOME/.ssh/authorized_keys  $HOME/.ssh/authorized_keys.tmp | tee -a $LOGFILE
#echo Creating known_hosts file on local host  | tee -a $LOGFILE
touch $HOME/.ssh/known_hosts  | tee -a $LOGFILE
#echo Changing permissions on known_hosts to 644 on local host  | tee -a $LOGFILE
chmod 644 $HOME/.ssh/known_hosts  | tee -a $LOGFILE
mv -f $HOME/.ssh/known_hosts $HOME/.ssh/known_hosts.tmp | tee -a $LOGFILE


#echo Creating config file on local host | tee -a $LOGFILE
#echo If a config file exists already at $HOME/.ssh/config, it would be backed up to $HOME/.ssh/config.backup.
echo "Host *" > $HOME/.ssh/config.tmp | tee -a $LOGFILE
echo "ForwardX11 no" >> $HOME/.ssh/config.tmp | tee -a $LOGFILE

if test -f $HOME/.ssh/config 
then
  cp -f $HOME/.ssh/config $HOME/.ssh/config.backup
fi

mv -f $HOME/.ssh/config.tmp $HOME/.ssh/config  | tee -a $LOGFILE
#Fix for BUG NO 5157782
chmod 644 $HOME/.ssh/config
if [ $RERUN_SSHKEYGEN = "yes" ]
then
  #echo Removing old private/public keys on local host | tee -a $LOGFILE
  rm -f $HOME/.ssh/${IDENTITY} | tee -a $LOGFILE
  rm -f $HOME/.ssh/${IDENTITY}.pub | tee -a $LOGFILE
  #echo Running SSH keygen on local host | tee -a $LOGFILE
  $SSH_KEYGEN -t $ENCR -b $BITS -f $HOME/.ssh/${IDENTITY}   | tee -a $LOGFILE

elif [ $RERUN_SSHKEYGEN = "change" ]
then
    echo Running SSH Keygen on local host to change the passphrase associated with the existing private key | tee -a $LOGFILE
    $SSH_KEYGEN -p -t $ENCR -b $BITS -f $HOME/.ssh/${IDENTITY} | tee -a $LOGFILE
elif test -f  $HOME/.ssh/${IDENTITY}.pub && test -f  $HOME/.ssh/${IDENTITY} 
then
    echo "">>$LOGFILE
    #continue
else
    #echo Removing old private/public keys on local host | tee -a $LOGFILE
    rm -f $HOME/.ssh/${IDENTITY} | tee -a $LOGFILE
    rm -f $HOME/.ssh/${IDENTITY}.pub | tee -a $LOGFILE
    #echo Running SSH keygen on local host with empty passphrase | tee -a $LOGFILE
    $SSH_KEYGEN -t $ENCR -b $BITS -f $HOME/.ssh/${IDENTITY} -N ''  | tee -a $LOGFILE
fi
if [ $SHARED = "true" ]
then
  if [ $USER = $USR ]
  then
#No remote operations required
    echo Remote user is same as local user >> $LOGFILE
    REMOTEHOSTS=""
    chmod og-w $HOME $HOME/.ssh >> $LOGFILE
  else    
    REMOTEHOSTS="${firsthost}"
  fi
else
  REMOTEHOSTS="$HOSTS"
fi

fixRootPassword "$node_rootpassword"

for host in $REMOTEHOSTS
do
     #echo Creating .ssh directory and setting permissions on remote host $host | tee -a $LOGFILE
     #echo "THE SCRIPT WOULD ALSO BE REVOKING WRITE PERMISSIONS FOR "group" AND "others" ON THE HOME DIRECTORY FOR $USR. THIS IS AN SSH REQUIREMENT." | tee -a $LOGFILE
     #echo The script would create ~$USR/.ssh/config file on remote host $host. If a config file exists already at ~$USR/.ssh/config, it would be backed up to ~$USR/.ssh/config.backup. | tee -a $LOGFILE
     #echo The user may be prompted for a password here since the script would be running SSH on host $host. | tee -a $LOGFILE
     if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
     then
       $EXPECT -f - << IBEOF
                           set timeout 10
                           set le_node_rootpassword "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {   
                             exp_internal 1
                           } 
                           spawn -noecho $SSH -x -l $USR $host "/bin/sh -c \"  mkdir -p .ssh ; chmod og-w . .ssh;   touch .ssh/authorized_keys .ssh/known_hosts .ssh/config;  chmod 644 .ssh/authorized_keys  .ssh/known_hosts .ssh/config; cp  .ssh/authorized_keys .ssh/authorized_keys.tmp ;  cp .ssh/known_hosts .ssh/known_hosts.tmp; echo \\"Host *\\" > .ssh/config.tmp; echo \\"ForwardX11 no\\" >> .ssh/config.tmp; if test -f  .ssh/config ; then cp -f .ssh/config .ssh/config.backup; fi ; mv -f .ssh/config.tmp .ssh/config\";chmod 644 .ssh/config"
                           match_max 100000
                           expect {
                             "no)?" {
                                 send -- "yes\n"
                                 }
                             "*?assword:*" {
                                 send -- "\$le_node_rootpassword\n" 
                                 }
                             eof {
                                 exit 0
                                 }
                           }
                           expect {
                             "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                             eof {
                                 exit 0
                                 }
                          }
IBEOF
     else
       $SSH -x -l $USR $host "/bin/sh -c \"  mkdir -p .ssh ; chmod og-w . .ssh;   touch .ssh/authorized_keys .ssh/known_hosts .ssh/config;  chmod 644 .ssh/authorized_keys  .ssh/known_hosts .ssh/config; cp  .ssh/authorized_keys .ssh/authorized_keys.tmp ;  cp .ssh/known_hosts .ssh/known_hosts.tmp; echo \\"Host *\\" > .ssh/config.tmp; echo \\"ForwardX11 no\\" >> .ssh/config.tmp; if test -f  .ssh/config ; then cp -f .ssh/config .ssh/config.backup; fi ; mv -f .ssh/config.tmp .ssh/config\";chmod 644 .ssh/config" | tee -a $LOGFILE
     fi
     echo Done with creating .ssh directory and setting permissions on remote host $host.>> $LOGFILE
done

for host in $REMOTEHOSTS
do
  #echo Copying local host public key to the remote host $host | tee -a $LOGFILE
  #echo The user may be prompted for a password or passphrase here since the script would be using SCP for host $host. | tee -a $LOGFILE
  if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
  then
    $EXPECT -f - << IBEOF
                           set timeout 100
			   set le_node_rootpassword "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }
                           spawn $SCOPY $HOME/.ssh/${IDENTITY}.pub  $USR@$host:.ssh/authorized_keys
                           match_max 100000
                           expect {
                             "no)?" {
                                 send -- "yes\n"
                                 }
                             "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                             eof {
                                 exit 0
                                 }
                            }

                            expect {
                              "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                              eof {
                                 exit 0
                                 }
                            }
IBEOF
  else
    scp $HOME/.ssh/${IDENTITY}.pub  $USR@$host:.ssh/authorized_keys | tee -a $LOGFILE
  fi
  echo Done copying local host public key to the remote host $host >> $LOGFILE
done

cat $HOME/.ssh/${IDENTITY}.pub >> $HOME/.ssh/authorized_keys | tee -a $LOGFILE
for host in $HOSTS
do
  if [ $ADVANCED = "true" ] 
  then
    echo Creating keys on remote host $host if they do not exist already. This is required to setup SSH on host $host. >> $LOGFILE
    if [ $SHARED = "true" ]
    then
      IDENTITY_FILE_NAME=${IDENTITY}_$host
      COALESCE_IDENTITY_FILES_COMMAND="cat .ssh/${IDENTITY_FILE_NAME}.pub >> .ssh/authorized_keys"
    else
      IDENTITY_FILE_NAME=${IDENTITY}
    fi

    if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
    then
       $EXPECT -f - << IBEOF
                           set timeout 10
			   set le_node_rootpassword "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {   
                             exp_internal 1
                           }
                           spawn -noecho $SSH  -x -l $USR $host " /bin/sh -c \"if test -f  .ssh/${IDENTITY_FILE_NAME}.pub && test -f  .ssh/${IDENTITY_FILE_NAME}; then echo; else rm -f .ssh/${IDENTITY_FILE_NAME} ;  rm -f .ssh/${IDENTITY_FILE_NAME}.pub ;  $SSH_KEYGEN -t $ENCR -b $BITS -f .ssh/${IDENTITY_FILE_NAME} -N '' ; fi; ${COALESCE_IDENTITY_FILES_COMMAND} \"" | tee -a $LOGFILE
                           match_max 100000
                           expect {
                              "no)?" {
                                 send -- "yes\n"
                                 }
                             "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"	
                                 }
                            eof {
                                 exit 0
                                 }
                            }
                            expect {
                              "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                              eof {
                                 exit 0
                                 }
                            }
IBEOF
    else
      $SSH  -x -l $USR $host " /bin/sh -c \"if test -f  .ssh/${IDENTITY_FILE_NAME}.pub && test -f  .ssh/${IDENTITY_FILE_NAME}; then echo; else rm -f .ssh/${IDENTITY_FILE_NAME} ;  rm -f .ssh/${IDENTITY_FILE_NAME}.pub ;  $SSH_KEYGEN -t $ENCR -b $BITS -f .ssh/${IDENTITY_FILE_NAME} -N '' ; fi; ${COALESCE_IDENTITY_FILES_COMMAND} \"" | tee -a $LOGFILE
    fi
  else 
#At least get the host keys from all hosts for shared case - advanced option not set
    if test  $SHARED = "true" && test $ADVANCED = "false"
    then
      if [ $PASSPHRASE = "yes" ]
      then
	 echo "The script will fetch the host keys from all hosts. The user may be prompted for a passphrase here in case the private key has been encrypted with a passphrase." >>$LOGFILE
      fi

      if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
      then
        $EXPECT -f - << IBEOF
                           set timeout 10
			   set le_node_rootpassword "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }
                           spawn -noecho $SSH  -x -l $USR $host "/bin/sh -c true"
                           match_max 100000
                           expect {
                             "no)?" {
                                 send -- "yes\n"
                                 }
                             "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                             eof {
                                 exit 0
                                 }
                           }
                           expect {
                             "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                             eof {
                                 exit 0
                                 }
                          }
IBEOF
      else
         $SSH  -x -l $USR $host "/bin/sh -c true"
      fi
    fi
  fi
done

for host in $REMOTEHOSTS
do
  if test $ADVANCED = "true" && test $SHARED = "false"  
  then
     if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
     then
       $EXPECT -f - << IBEOF
                           set timeout 10
			   set le_node_rootpassword "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }   
                           spawn -noecho scp $USR@$host:.ssh/${IDENTITY}.pub $HOME/.ssh/${IDENTITY}.pub.$host | tee -a $LOGFILE
                           match_max 100000
                           expect {
                             "no)?" {
                                 send -- "yes\n"
                                 }
                             "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                             eof {
                                 exit 0
                                 }
                           expect {
                             "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                             eof {
                                 exit 0
                                 }
                          }
IBEOF
     else
       scp $USR@$host:.ssh/${IDENTITY}.pub $HOME/.ssh/${IDENTITY}.pub.$host | tee -a $LOGFILE
     fi
      cat $HOME/.ssh/${IDENTITY}.pub.$host >> $HOME/.ssh/authorized_keys | tee -a $LOGFILE
      rm -f $HOME/.ssh/${IDENTITY}.pub.$host | tee -a $LOGFILE
    fi
done

for host in $REMOTEHOSTS
do
   if [ $ADVANCED = "true" ]
   then
      if [ $SHARED != "true" ]
      then
         echo Updating authorized_keys file on remote host $host >>$LOGFILE
         if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
         then
           $EXPECT -f - << IBEOF
                           set timeout 10
			   set le_node_rootpassword "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }
                           spawn -noecho scp $HOME/.ssh/authorized_keys  $USR@$host:.ssh/authorized_keys | tee -a $LOGFILE
                           match_max 100000
                             expect {
                           "no)?" {
                                 send -- "yes\n"
                                 }
                           "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                           eof {
                                 exit 0
                                 }
                                 }
                             expect {
                           "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                           eof {
                                 exit 0
                                 }
                          }
IBEOF
         else
           scp $HOME/.ssh/authorized_keys  $USR@$host:.ssh/authorized_keys | tee -a $LOGFILE
         fi
      fi 
     echo Updating known_hosts file on remote host $host >>$LOGFILE
     if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
     then
       $EXPECT -f - << IBEOF
                           set timeout 10
			   set le_node_rootpassword "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1	
                           }
                           spawn -noecho scp $HOME/.ssh/known_hosts $USR@$host:.ssh/known_hosts | tee -a $LOGFILE
                           match_max 100000
                             expect {
                           "no)?" {
                                 send -- "yes\n"
                                 }
                           "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                           eof {
                                 exit 0
                                 }
                                 }
                             expect {
                           "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                           eof {
                                 exit 0
                                 }
                          }
IBEOF
     else
       scp $HOME/.ssh/known_hosts $USR@$host:.ssh/known_hosts | tee -a $LOGFILE
     fi
   fi
   if [ $PASSPHRASE = "yes" ]
   then
	 echo "The script will run SSH on the remote machine $host. The user may be prompted for a passphrase here in case the private key has been encrypted with a passphrase." >> $LOGFILE
   fi
   if [[ -n "$use_expect_for_ssh" && $use_expect_for_ssh -eq "1" ]]
   then
       $EXPECT -f - << IBEOF
                           set timeout 10
			   set le_node_rootpassword "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {   
                             exp_internal 1
                           }		
                           if { "$AutoLoginCheckYes" == "1" } {
                             spawn -noecho $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts; rm -f  .ssh/known_hosts.tmp  .ssh/authorized_keys.tmp\"" | tee -a $LOGFILE
                           } else { 
                             spawn -noecho $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts\"" | tee -a $LOGFILE
                           }
                           match_max 100000
                             expect {
                           "no)?" {
                                 send -- "yes\n"
                                 }
                           "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                           eof {
                                 exit 0
                                 }
                                 }
                             expect {
                           "*?assword:*" {
				 send -- "\$le_node_rootpassword\n"
                                 }
                           eof {
                                 exit 0
                                 }
                          }
IBEOF
    else
       if [[ -n "$AutoLoginCheckYes" && $AutoLoginCheckYes -eq 1 ]]            
       then  
           $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts; rm -f  .ssh/known_hosts.tmp  .ssh/authorized_keys.tmp\"" | tee -a $LOGFILE
       else   
           $SSH -x -l $USR $host "/bin/sh -c \"cat .ssh/authorized_keys.tmp >> .ssh/authorized_keys; cat .ssh/known_hosts.tmp >> .ssh/known_hosts\"" | tee -a $LOGFILE
       fi
    fi
done
if [ -f $HOME/.ssh/known_hosts.tmp ]
then
    cat  $HOME/.ssh/known_hosts.tmp >> $HOME/.ssh/known_hosts | tee -a $LOGFILE
fi
if [ $HOME/.ssh/authorized_keys.tmp ]
then
    cat  $HOME/.ssh/authorized_keys.tmp >> $HOME/.ssh/authorized_keys | tee -a $LOGFILE
fi
#Added chmod to fix BUG NO 5238814
chmod 644 $HOME/.ssh/authorized_keys
chmod 644 $HOME/.ssh/config
rm -f  $HOME/.ssh/known_hosts.tmp $HOME/.ssh/authorized_keys.tmp | tee -a $LOGFILE
echo SSH setup is complete. >> $LOGFILE
fi
fi
#echo                                                                          | tee -a $LOGFILE
#echo ------------------------------------------------------------------------ | tee -a $LOGFILE
#echo Verifying SSH setup | tee -a $LOGFILE
#echo =================== | tee -a $LOGFILE
#echo The script will now run the 'date' command on the remote nodes using ssh | tee -a $LOGFILE
#echo to verify if ssh is setup correctly. IF THE SETUP IS CORRECTLY SETUP,  | tee -a $LOGFILE
#echo THERE SHOULD BE NO OUTPUT OTHER THAN THE DATE AND SSH SHOULD NOT ASK FOR | tee -a $LOGFILE
#echo PASSWORDS. If you see any output other than date or are prompted for the | tee -a $LOGFILE
#echo password, ssh is not setup correctly and you will need to resolve the  | tee -a $LOGFILE
#echo issue and set up ssh again. | tee -a $LOGFILE
#echo The possible causes for failure could be:  | tee -a $LOGFILE
#echo   1. The server settings in /etc/ssh/sshd_config file do not allow ssh | tee -a $LOGFILE
#echo      for user $USR. | tee -a $LOGFILE
#echo   2. The server may have disabled public key based authentication.
#echo   3. The client public key on the server may be outdated.
#echo   4. ~$USR or  ~$USR/.ssh on the remote host may not be owned by $USR.  | tee -a $LOGFILE
#echo   5. User may not have passed -shared option for shared remote users or | tee -a $LOGFILE
#echo     may be passing the -shared option for non-shared remote users.  | tee -a $LOGFILE
#echo   6. If there is output in addition to the date, but no password is asked, | tee -a $LOGFILE
#echo   it may be a security alert shown as part of company policy. Append the | tee -a $LOGFILE
#echo   "additional text to the <OMS HOME>/sysman/prov/resources/ignoreMessages.txt file." | tee -a $LOGFILE
#echo ------------------------------------------------------------------------ | tee -a $LOGFILE
#read -t 30 dummy
  for host in $HOSTS
  do
    #echo --$host:-- | tee -a $LOGFILE
     #echo Running $SSH -x -l $USR $host date to verify SSH connectivity has been setup from local host to $host.  | tee -a $LOGFILE
     #echo "IF YOU SEE ANY OTHER OUTPUT BESIDES THE OUTPUT OF THE DATE COMMAND OR IF YOU ARE PROMPTED FOR A PASSWORD HERE, IT MEANS SSH SETUP HAS NOT BEEN SUCCESSFUL. Please note that being prompted for a passphrase may be OK but being prompted for a password is ERROR." | tee -a $LOGFILE
     if [ $PASSPHRASE = "yes" ]
     then
       echo "The script will run SSH on the remote machine $host. The user may be prompted for a passphrase here in case the private key has been encrypted with a passphrase." | tee -a $LOGFILE
     fi
     #$SSH -l $USR $host "/bin/sh -c date"  | tee -a $LOGFILE
echo ------------------------------------------------------------------------ >> $LOGFILE
  done


if [ $EXHAUSTIVE_VERIFY = "true" ]
then
   for clienthost in $HOSTS
   do

      if [ $SHARED = "true" ]
      then
         REMOTESSH="$SSH -i .ssh/${IDENTITY}_${clienthost}"
      else
         REMOTESSH=$SSH
      fi

      for serverhost in  $HOSTS
      do
         echo ------------------------------------------------------------------------ >> $LOGFILE
         echo Verifying SSH connectivity has been setup from $clienthost to $serverhost  | tee -a $LOGFILE
         echo ------------------------------------------------------------------------ | tee -a $LOGFILE
         $SSH -l $USR $clienthost "$REMOTESSH $serverhost \"/bin/sh -c date\""  | tee -a $LOGFILE
         echo ------------------------------------------------------------------------ >> $LOGFILE
      done  
       echo -Verification from $clienthost complete- | tee -a $LOGFILE
   done
else
   if [ $ADVANCED = "true" ]
   then
      if [ $SHARED = "true" ]
      then
         REMOTESSH="$SSH -i .ssh/${IDENTITY}_${firsthost}"
      else
         REMOTESSH=$SSH
      fi
     for host in $HOSTS
     do
         echo ------------------------------------------------------------------------ >>$LOGFILE
        echo Verifying SSH connectivity has been setup from $firsthost to $host  | tee -a $LOGFILE
       $SSH -l $USR $firsthost "$REMOTESSH $host /bin/sh -c date" | tee -a $LOGFILE
         echo ------------------------------------------------------------------------ >> $LOGFILE
    done
    echo -Verification from $clienthost complete- | tee -a $LOGFILE
  fi
fi
echo "SSH verification complete." >>$LOGFILE
echo ""
}

#end of fun_setup_ssh

generate_result_xml ()
{
#code to write xml for em plug-in starts here
         status_on_target="";
         check_execution_time=$(date '+%Y-%m-%d %H:%M:%S %Z')
         echo "   <${xml_prefix1}Result executionTimestamp=\"$check_execution_time\">" >> $XMLREPFIL
	 if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
	 then
	     echo "     <CheckID>${crs_check_id[$crs_check_file_counter]}</CheckID>" >>$XMLREPFIL
	 else
	     echo "     <CheckID>$CHECK_ID</CheckID>" >>$XMLREPFIL
	 fi
	 echo "     <CheckType>$COMTYPE</CheckType>" >>$XMLREPFIL 
	 echo "     <AlertType>$ALVL_CHECK</AlertType>" >>$XMLREPFIL 
         if [[ "$COMTYPE" = "SQL_PARAM" || "$COMTYPE" = "SQL" ]]
         then
	     echo "     <TargetType>RDBMS</TargetType>" >>$XMLREPFIL 
         #elif [[ "$COMTYPE" = "CLUSTERWIDE_CHECK" || "$COMTYPE" = "SYSTEMWIDE_CHECK" ]]
         #then
         #    echo "     <TargetType>CLUSTER</TargetType>" >>$XMLREPFIL
         elif [[ "$COMTYPE" = "OS_PACKAGE" || "$COMTYPE" = "OS_PATCH" || "$COMTYPE" = "OS_PARAM" ]]
         then
	     echo "     <TargetType>UNSPECIFIED</TargetType>" >>$XMLREPFIL 
         elif [[ "$COMTYPE" = "ORACLE_PATCH" ]]
         then
             echo "     <TargetType>ORACLE_HOME</TargetType>" >>$XMLREPFIL
         else
	     echo "     <TargetType>$NEEDS_RUNNING</TargetType>" >>$XMLREPFIL 
         fi
	 echo "     <Status>$1</Status>" >>$XMLREPFIL 
	 if [[ -n "$SOURCEFIL" && -e $SOURCEFIL ]] && [[ $COMTYPE != "OS" && $COMTYPE != "SQL" && $COMTYPE != "CLUSTERWIDE_CHECK" ]]
	 then
	     SOURCEFIL4XML=$(basename $SOURCEFIL)               
	     echo "     <OutfilePath>$SOURCEFIL4XML</OutfilePath>" >>$XMLREPFIL               
	 fi
	 echo "     <ColumnValues>" >>$XMLREPFIL               
         if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
         then 
             cellname_counter=0
             for cellname in ${a_cellname[@]}
             do
                echo "       <ColumnValue Name=\"NodeName\" value=\"$cellname\" status=\"${a_cellCheckStatus[$cellname_counter]}\"/>" >>$XMLREPFIL
                #echo "       <ColumnValue Name=\"CellCheckStatus\" value=\"${a_cellCheckStatus[$cellname_counter]}\"/>" >>$XMLREPFIL
                cellname_counter=$(expr $cellname_counter + 1 )
             done
             #for cellCheckStatus in ${a_cellCheckStatus[@]}
             #do
             #   echo "       <ColumnValue Name=\"CellCheckStatus\" value=\"$cellCheckStatus\">" >>$XMLREPFIL
             #done
         elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]]
         then
	     echo "       <ColumnValue Name=\"NodeName\" value=\"$switchname\"/>" >>$XMLREPFIL
	 elif [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" ]]
	 then
	     echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
	 elif [[ $COMTYPE = "OS_PARAM" ]]
	 then
	     echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
	     if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
	     echo "       <ColumnValue Name=\"ParamName\" value=\"$p_name\"/>" >>$XMLREPFIL
         elif [ $COMTYPE = "OS" ]
         then
             if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
             then
                 echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
                 echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
             elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]
             then
                  echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
                  echo "       <ColumnValue Name=\"DBHome\" value=\"${mb_db_homes_without_slash}\"/>" >>$XMLREPFIL
             else
                  echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
             fi 
	 elif [[ $COMTYPE = "SQL" || $COMTYPE = "SQL_OUT_CHECK" ]]
	 then
	     echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
	 elif [[ $COMTYPE = "SQL_PARAM" ]]
	 then
	     echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLREPFIL
	     echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLREPFIL
	     echo "       <ColumnValue Name=\"InitORAParameterName\" value=\"$PARAM_PATH\"/>" >>$XMLREPFIL
             status_on_target="$inst_name";
	 elif [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
	 then
	     echo "       <ColumnValue Name=\"NodeName\" value=\"CLUSTERWIDE_CHECK\"/>" >>$XMLREPFIL
	 elif [ $COMTYPE = "ORACLE_PATCH" ]
	 then
	     echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
	     if [[ $HOME_PATH = "RDBMS" ]]
	     then
	       echo "       <ColumnValue Name=\"DBHome\" value=\"${mb_db_homes}\"/>" >>$XMLREPFIL
	     else
	       echo "       <ColumnValue Name=\"DBHome\" value=\"$message4Home\"/>" >>$XMLREPFIL
	     fi
	 else
	     echo "       <ColumnValue Name=\"NodeName\" value=\"what_to_write\"/>" >>$XMLREPFIL
	 fi
	 echo "     </ColumnValues>" >>$XMLREPFIL               
      echo "   </${xml_prefix1}Result>" >> $XMLREPFIL

  if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
    echo "$CHECK_ID|$cch_status|$COMTYPE|$status_on_target|$db_name_to_check|$inst_name|$mb_db_homes|$message4Home|$cch_cname|$g_hosts" >> $OUTPUTDIR/slave_results.out
  fi
      #code to write xml for em plug-in ends here
}

generate_exceptions_xml ()
{
         echo "   <${xml_prefix1}Exclusion>" >> $XMLSKIPFIL
         if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
         then
             echo "     <CheckID>${crs_check_id[$crs_check_file_counter]}</CheckID>" >>$XMLSKIPFIL
         else
             echo "     <CheckID>$CHECK_ID</CheckID>" >>$XMLSKIPFIL
         fi
         echo "     <CheckType>$COMTYPE</CheckType>" >>$XMLSKIPFIL
         echo "     <AlertType>$ALVL_CHECK</AlertType>" >>$XMLSKIPFIL
         if [[ "$COMTYPE" = "SQL_PARAM" || "$COMTYPE" = "SQL" ]]
         then
	     echo "     <TargetType>RDBMS</TargetType>" >>$XMLSKIPFIL
         #elif [[ "$COMTYPE" = "CLUSTERWIDE_CHECK" || "$COMTYPE" = "SYSTEMWIDE_CHECK" ]]
         #then
         #    echo "     <TargetType>CLUSTER</TargetType>" >>$XMLSKIPFIL
         elif [[ "$COMTYPE" = "OS_PACKAGE" || "$COMTYPE" = "OS_PATCH" || "$COMTYPE" = "OS_PARAM" ]]
         then
	     echo "     <TargetType>UNSPECIFIED</TargetType>" >>$XMLSKIPFIL
         elif [[ "$COMTYPE" = "ORACLE_PATCH" ]]
         then
             echo "     <TargetType>ORACLE_HOME</TargetType>" >>$XMLREPFIL
         else
	     echo "     <TargetType>$NEEDS_RUNNING</TargetType>" >>$XMLSKIPFIL
         fi
         if [[ $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" || $COMTYPE = "SQL_PARAM" ]]
         then
             echo "     <CheckName>$PARAM_NAME</CheckName>" >>$XMLSKIPFIL
         else
             echo "     <CheckName>$(echo $audit_check_name|sed 's/\[DBMV2]//g' |sed 's/</less than/g' | sed 's/>/greater than/g')</CheckName>" >>$XMLSKIPFIL
         fi
         if [[ $COMTYPE != "OS" && $COMTYPE != "SQL" && $COMTYPE != "CLUSTERWIDE_CHECK" ]]
	 then
	     SOURCEFIL4XML=$(basename $SOURCEFIL)               
	     echo "     <OutfilePath>$SOURCEFIL4XML</OutfilePath>" >>$XMLSKIPFIL               
	 fi    
	 echo "     <ColumnValues>" >>$XMLSKIPFIL 
         if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
         then 
             echo "       <ColumnValue Name=\"NodeName\" value=\"$cellname\"/>" >>$XMLSKIPFIL       
         elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]]
         then
	     echo "       <ColumnValue Name=\"NodeName\" value=\"$switchname\"/>" >>$XMLSKIPFIL
	 elif [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" || $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" ]]
	 then
	     echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
	 elif [[ $COMTYPE = "OS_PARAM" ]]
	 then
	     echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLSKIPFIL
	     if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
	     echo "       <ColumnValue Name=\"ParamName\" value=\"$p_name\"/>" >>$XMLSKIPFIL
	 elif [[ $COMTYPE = "SQL" || $COMTYPE = "SQL_OUT_CHECK" ]]
	 then
	     echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
	 elif [[ $COMTYPE = "SQL_PARAM" ]]
	 then
	     echo "       <ColumnValue Name=\"DBName\" value=\"$db_name_to_check\"/>" >>$XMLSKIPFIL
	     echo "       <ColumnValue Name=\"InstanceName\" value=\"$inst_name\"/>" >>$XMLSKIPFIL
	     echo "       <ColumnValue Name=\"InitORAParameterName\" value=\"$PARAM_PATH\"/>" >>$XMLSKIPFIL
	 elif [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
	 then
	     echo "       <ColumnValue Name=\"NodeName\" value=\"CLUSTERWIDE_CHECK\"/>" >>$XMLSKIPFIL
	 elif [ $COMTYPE = "ORACLE_PATCH" ]
	 then
	     echo "       <ColumnValue Name=\"NodeName\" value=\"$i\"/>" >>$XMLREPFIL
	     if [[ $HOME_PATH = "RDBMS" ]]
	     then
	       echo "       <ColumnValue Name=\"DBHome\" value=\"${mb_db_homes}\"/>" >>$XMLREPFIL
	     else
	       echo "       <ColumnValue Name=\"DBHome\" value=\"$message4Home\"/>" >>$XMLREPFIL
	     fi
	 else
	     echo "       <ColumnValue Name=\"NodeName\" value=\"what_to_write\"/>" >>$XMLSKIPFIL
	 fi    
	 echo "     </ColumnValues>" >>$XMLSKIPFIL               
	 echo "     <Message><![CDATA[$1]]></Message>" >>$XMLSKIPFIL               
         echo "   </${xml_prefix1}Exclusion>" >> $XMLSKIPFIL
}

log_pass ()
{

  #if we're in SILENT mode then all we want to suppress some of this logging
  #BUT not all of the logging which we may need for debugging purposes
  #pass/fail is not a concept fo rSILENT mode
  #read -p "calling log pass"
#echo "row=$ROW COMTYPE=$COMTYPE command=$COM PARAM_PATH=$PARAM_PATH ISBRANCH=$ISBRANCH REQUIRES_ROOT_OS=$REQUIRES_ROOT_OS NEEDS_RUNNING=$NEEDS_RUNNING execute once=$execute_once"	
  case $COMTYPE in

  OS_COLLECT)
    echo "------------------------------" >>$LOGFIL 
    #echo "------------------------------" >>$REPFIL
    echo "  SEE OS OUTPUT FILE $OUTFIL" >>$LOGFIL
    #echo "  SEE OS OUTPUT FILE $OUTFIL" >>$REPFIL
    echo "------------------------------" >>$LOGFIL
    #echo "------------------------------" >>$REPFIL
    echo "" >>$LOGFIL
    #echo "" >>$REPFIL
    ;;
  SQL_COLLECT)
    echo "------------------------------" >>$LOGFIL
    #echo "------------------------------" >>$REPFIL
    echo "  SEE SQL OUTPUT FILE $OUTFIL" >>$LOGFIL
    #echo "  SEE SQL OUTPUT FILE $OUTFIL" >>$REPFIL
    echo "------------------------------" >>$LOGFIL
    #echo "------------------------------" >>$REPFIL
    echo "" >>$LOGFIL
    #echo "" >>$REPFIL
     ;;
  #CLUSTERWIDE_CHECK)
  #   echo "it called the right fuction"
  #  ;;
  *)
   if [[ $ISBRANCH -eq "1" && $SILENT -eq "0" ]]
   then
     echo "BRANCH CONDITION TRUE" >>$LOGFIL
     echo "---------------------------------------------" >>$LOGFIL
   else
     # gadiga.. added for SHS
     let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1

     if [ $SILENT -eq "0" ]
     then     
       echo "" >>$LOGFIL 
       #if [ "$ALVL" != "INFO" ]
       #then
       #    ACREPCOUNT=`expr $ACREPCOUNT + 1`
       #fi
       #echo "------------------------------" >>$LOGFIL
       echo  "PASS =>  $PMSG" >>$LOGFIL
       #echo "------------------------------" >>$LOGFIL
       echo "" >>$LOGFIL
       #Commented this if condition on Oct 02 to print info pass messages in all reports
       #if [[ -n $ALVL && $ALVL != "INFO" ]]
       #then 
           if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
           then
	       echo "" >>$CWCREPFIL_PASS
	       echo  "Check:- PASS => $PMSG" >>$CWCREPFIL_PASS
	       echo  "Check:- PASS => $PMSG" >>$SCWCREPFIL_PASS
           else
               if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
               then
	           echo "" >>$CELLREPFIL_PASS
	           echo "Check:- PASS => $PMSG" >>$CELLREPFIL_PASS
	           echo "Check:- PASS => $PMSG" >>$CELLSREPFIL_PASS
               elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
               then
	           echo "" >>$IBREPFIL_PASS
	           echo "Check:- PASS => $PMSG" >>$IBREPFIL_PASS
	           echo "Check:- PASS => $PMSG" >>$IBSREPFIL_PASS
               else
	           echo "" >>$REPFIL_PASS
	           echo "Check:- PASS => $PMSG" >>$REPFIL_PASS
	           echo "Check:- PASS => $PMSG" >>$SREPFIL_PASS
               fi
           fi
           if [[ $COMTYPE != "OS_PACKAGE" && -n "$db_machine_compute" && $db_machine_compute -eq 0 ]]
           then
               if [[  $COMTYPE = "CLUSTERWIDE_CHECK"  ]]
               then
                   echo -e "Success factor name = $SF \n">>$CWCREPFIL_PASS
               else
                   if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
                   then
                       echo -e "Success factor name = $SF \n">>$CELLREPFIL_PASS
                   elif [[ $COMTYPE = "OS_OUT_CHECK"  ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
                   then
                       echo -e "Success factor name = $SF \n">>$IBREPFIL_PASS
                   else
                       echo -e "Success factor name = $SF \n">>$REPFIL_PASS
                   fi
               fi
           fi
           if [ $COMTYPE = "OS_PACKAGE" ]
           then
               echo  "Audit check # $ACREPCOUNT@RPM Version Check@$actual@$PARAM_PATH@PASS =>   $PMSG@$rpm_status@$rpm_arch">>$OSCHECKRESULT
           else
               if [ -z "$audit_check_name" ]
               then
                   audit_check_name=$COM
               fi
               echo  "Audit check # $ACREPCOUNT@$audit_check_name@$VAL@$COMP@PASS =>   $PMSG">>$OSCHECKRESULT
               #audit_check_name=""
           fi 
           #echo "------------------------------" >>$REPFIL
           if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
           then 
               echo "" >>$CWCREPFIL_PASS
           else
               if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
               then
                   echo "" >>$CELLREPFIL_PASS
               elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
               then
                   echo "" >>$IBREPFIL_PASS
               else 
                   echo "" >>$REPFIL_PASS
               fi 
           fi
           if [[ $CREATE_HTML_REPORT -eq 1 ]]
           then # gadiga - for html reporting
             init_arrays_html "PASS"
             write_additional_info;
           fi

           generate_result_xml "PASS"     

       #fi 
       BPMSG=0  
       BPMSG=`echo $PMSG|grep -c "BRANCH CONDITION TRUE"`
       if [[ $BPMSG -lt 1 && $ALVL != "INFO" && -n $ALVL && $print_pass_on_screen -eq 1 ]]
       then
           echo -e "$GREEN PASS =>   $NORM $PMSG"
       else
#to stop printing info in pass, just redirect follwing line to devnull 
            if [[ -n "$RAT_INFOPASS" && $RAT_INFOPASS -eq 1 && $print_pass_on_screen -eq 1 ]]
            then
                echo -e "$CYAN $ALVL =>   $NORM $PMSG" 
            else
                echo -e "$CYAN $ALVL =>   $NORM $PMSG" > /dev/null
                #echo -e "$CYAN $ALVL =>   $NORM $PMSG"
            fi
       fi
       echo -e "CHECK ID = $CHECK_ID \nAUDIT CHECK NAME = $audit_check_name\n">>$LOGFIL
       echo "---------------------------------------------" >>$LOGFIL
     fi
   fi
  ;;
  esac
}

function assign_usern ()
{
    case `/bin/uname` in
        Linux)
        usern=`whoami`
        ;;
        SunOS)
        usern=`id|awk '{print $1}'|cut -d'(' -f2|cut -d')' -f1`
        ;;
        HP-UX)
        usern=`whoami`
        ;;
        AIX)
        usern=`whoami`
        ;;     
        *)
        usern=`whoami`
        ;;     
    esac
}

P_CONF_NAMES[0]="AUTORUN_INTERVAL"
P_CONF_NAMES[1]="AUTORUN_FLAGS"
P_CONF_NAMES[2]="NOTIFICATION_EMAIL"
P_CONF_NAMES[3]="PASSWORD_CHECK_INTERVAL"

function check_p_conf_validity ()
{
  p_name=$1
  p_conf_valid=0
  for v_n in "${P_CONF_NAMES[@]}"
  do
    if [[ `echo $v_n | grep -cw "$p_name"` -gt "0" ]] ; then
      p_conf_valid=1
      return
    fi
  done
}

function show_conf_file ()
{
  i_name=$1
  if [ -z "$i_name" ] ; then i_name="all"; fi
  #if [ "$i_name" != "all" ] ; then
  #  check_p_conf_validity $i_name
  #  if [ $p_conf_valid -eq "0" ] ; then
  #    echo 
  #    echo -e "${RED}Invalid parameter name : $i_name${NORM}"
  #    echo
  #    return
  #  fi
  #fi

  matched_conf=0
  if [ ! -f "$p_conf_file" ] ; then
    echo
    echo "None of parameters are set"
    echo
    return
  fi

  echo
  while read l_option
  do
    o_name=$(echo $l_option | cut -d"=" -f1 | sed 's/ //g')
    o_val=$(echo $l_option | cut -d"=" -f2 | sed 's/^ *//g' | sed 's/ *$//')
    if [[ -n "$i_name" &&  `echo $o_name | grep -ic $i_name` -gt "0" ]] ; then
      echo "$o_name = $o_val";
      matched_conf=1
    elif [[ "$i_name" = "all" ]] ; then
      echo "$o_name = $o_val";
      matched_conf=1
    fi
  done < $p_conf_file
  if [[ $matched_conf -eq "0" ]] ; then
    echo 
    echo -e "${RED}Invalid parameter name : $i_name${NORM}"
  fi
  echo
}

function update_conf_file ()
{
  old_ifs=$IFS
  IFS=";"
  for l_option in $options2set
  do
    o_name=$(echo $l_option | cut -d"=" -f1 | sed 's/ //g')
    o_val=$(echo $l_option | cut -d"=" -f2 | sed 's/^ *//g' | sed 's/ *$//')
    if [[ -n "$o_name" && -n "$o_val" ]] ; then
      check_p_conf_validity "$o_name"
      if [[ $p_conf_valid -eq "1" ]] ; then
        do_update_conf
      else
        echo
        echo -e "${RED}Invalid parameter name $p_name${NORM}";
        echo
      fi
    else
      echo
      echo -e "${RED}Invalid parameter name${NORM}";
      echo
    fi
  done
  IFS="$old_ifs"
}

function do_update_conf ()
{
  if [[ -f "$p_conf_file" && `grep -c "$o_name" $p_conf_file` -gt "0" ]] ; then
    sed  "s/"$o_name"=.*/"$o_name"="$o_val"/g" $p_conf_file >/tmp/$$.conf.tmp
    cp /tmp/$$.conf.tmp $p_conf_file
    rm -f /tmp/$$.conf.tmp
  else
    echo "$o_name=$o_val" >> $p_conf_file
  fi
  log_daemon "Updating config $o_name=$o_val"
}

function read_conf ()
{
  if [ ! -f "$p_conf_file" ] ; then
    p_conf_value=""
    return
  fi
  p_conf_value=$(grep "$1=" $p_conf_file | cut -d"=" -f2)
  # default AUTORUN_INTERVAL will be in days
  if [[ `echo "$p_conf_value"| grep -c '^[0-9]*$'` -gt "0" && $1 = "AUTORUN_INTERVAL" ]] ; then
    p_conf_value=$(expr $p_conf_value \* 24)
  fi

  if [[ `echo "$p_conf_value"| grep -c '^[0-9]*d$'` -gt "0" ]] ; then
    p_conf_num=$(echo "$p_conf_value"| sed 's/d$//');
    p_conf_value=$(expr $p_conf_num \* 24)
  elif [[ `echo "$p_conf_value"| grep -c '^[0-9]*h$'` -gt "0" ]] ; then
    p_conf_value=$(echo "$p_conf_value"| sed 's/h$//');
  fi
}

mail_server_running=0
function check_if_mail_exists ()
{
  mail_cmd=$(which mail)
  if [ -z "$mail_cmd" ] ; then mail_cmd=$(which mailx); fi
  if [ -n "$mail_cmd" ] ; then mail_server_running=1; fi
}

function send_email ()
{
  subject=$1
  matter=$2
  check_if_mail_exists
  if [[ -f "$p_conf_file" && `grep -c "NOTIFICATION_EMAIL" $p_conf_file` -gt "0" ]] ; then
    echo >/dev/null
  else
    echo 
    echo -e "${RED}Email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications.${NORM}"
    log_daemon "Failed to send email as email address is not configured. Please use ${program_name} -set \"NOTIFICATION_EMAIL=admin@company.com\" command to set email address for notifications."
    echo
    return
  fi
  read_conf "NOTIFICATION_EMAIL"
  remail=$p_conf_value
echo "mail_server_running=$mail_server_running"
  if [[ -n "$mail_server_running" && $mail_server_running -eq "1" ]] ; then
ls -l $RTEMPDIR_D/.cells.txt
    if [[ -e "$RTEMPDIR_D/.cells.txt" ]] ; then
      send_mail_using_cell 
    else
      echo "$matter" | $mail_cmd -s "$subject" $remail
    fi
  fi
}

function add_to_skipped_nodes ()
{
  skipped_host=$1
  skipped_reason=$2
  if [ ! -e "$OUTPUTDIR/${program_name}_skipped_nodes.log" ] ; then
    echo "<table><tr><th>Host Name</th><th>Reason</th></tr>" > $OUTPUTDIR/${program_name}_skipped_nodes.log
  fi
  echo "<tr><td>$skipped_host</td><td>$skipped_reason</td></tr>" >> $OUTPUTDIR/${program_name}_skipped_nodes.log
}

# Global variables for System Health Score for a cluster
# System Health Score will be a number b/w 0 - 100
# At the top of report print the score
# The logic used is (From Giri)
# Every check has 10 points
# If check status = FAIL reduce 10 points
#                   WARN reduce 5 points
#                   INFO reduce 3 points
# The total checks = checks in log_pass + checks in log_fail
# Also total check is count of all checks executed on all nodes, means,
# if same check is executed on two nodes, add 2 to total
G_TOTAL_CHECKS=0
G_FAIL_CHECKS=0
G_WARN_CHECKS=0
G_INFO_CHECKS=0
# Heath score is
# ((G_TOTAL_CHECKS*10)-(G_FAIL_CHECKS*10+G_WARN_CHECKS*5+G_INFO_CHECKS*3))/(G_TOTAL_CHECKS*10)

# Added by gadiga for creating html reports
# After writing failed message to corresponding .rep file, 
# write the message to <checkid>.html. If the file exists already, just 
# concatinate the .out file contents. Create <a name=<checkid>_details> anchor.
# Also create "Top" link, which will jump back to the message in summary table with 
# name <checkid>_summary. All <checkid>.html files are concatinated later to 
# create raccheck.html file

g_cch_cnt=0                 # check id count
g_cid=0                     # index for a check id
g_type=""                   # Type of check
g_hosts=""                  # Host names where check failed
declare -a G_CHECKIDS       # All failed check ids
declare -a G_CHECKID_INFO   # Collection name
declare -a G_CHECKID_TYPE   # Check Type
declare -a G_CHECKID_STATUS   # Status Pass failed etc
declare -a G_CHECKID_MAA_SF
declare -a G_CHECKID_HOSTS    # Host names
declare -a G_CHECKID_HOSTS_PASSED    # Host names
declare -a G_CHECKID_ALLHOSTS # Host names
CID_HTML_REPFILE=""         # checkid file
G_SOURCEFIL_REPORT=""       # Saved SOURCEFIL_REPORT
G_SOURCEFIL_REPORT_NEW=""   # Saved SOURCEFIL_REPORT_NEW
G_LINKS=""                  # Saved links finormation
CREATE_HTML_REPORT=1        # Set to zero to disable html reporting
TOOL_NAME="raccheck"        # Tool name to display. Changed later based on program name.
G_OUT_LINES=20               # Number of lines to display from .out file. default 20
G_HOST_CNT=5                # Number of host/db names to display in summary table. Default 5
                            # To change G_HOST_CNT, update the number in function get_host_string_html (In cut command)
# Below variables track the summary counts
G_TOTAL_CHECKS=0           
G_PASS_CNT=0           
G_WARNING_CNT=0           
G_ERROR_CNT=0           
G_FAIL_CNT=0           
G_INFO_CNT=0           

g_tr_index=0 # Index for deletebutton

G_SFS_TO_IGNORE[0]='GENERIC OS DATA COLLECTIONS';
G_SFS_TO_IGNORE[1]='OVM GUEST AUDIT CHECKS';
G_SFS_TO_IGNORE[2]='ARCHIVED AUDIT CHECKS';
G_SFS_TO_IGNORE[3]='DBMACHINE X2-2, X2-8 GENERIC AUDIT CHECKS'
G_SFS_TO_IGNORE[4]='DBMACHINE X2-2 AND X2-8 AUDIT CHECKS'
G_SFS_TO_IGNORE[5]='SQL DATA COLLECTIONS AND CHECKS'
G_SFS_TO_IGNORE[6]='GENERIC ORACLE PRE-UPGRADE AND POST-UPGRADE COLLECTIONS AND AUDIT CHECKS'
G_SFS_TO_IGNORE[7]='SFRAC'
G_SFS_TO_IGNORE[8]='OVM SERVER AUDIT CHECKS'
G_SFS_TO_IGNORE[9]='HA CHECKS'
G_SFS_TO_IGNORE[10]='SOLARIS DATA COLLECTIONS'
G_SFS_TO_IGNORE[11]='EXALOGIC AUDIT CHECKS'
G_SFS_TO_IGNORE[12]='LINUX RPM AUDIT CHECKS'
G_SFS_TO_IGNORE[13]='ACFS- OS COLLECTIONS AND OS CHECKS'
G_SFS_TO_IGNORE[14]='ORACLE DATABASE APPLIANCE (ODA)'
G_SFS_TO_IGNORE[15]='LINUX DATA COLLECTIONS AND AUDIT CHECKS'
G_SFS_TO_IGNORE[16]='HP-UX DATA COLLECTIONS'
G_SFS_TO_IGNORE[17]='AIX DATA COLLECTIONS'
G_SFS_TO_IGNORE[18]='AIX OS PACKAGES AND PATCHES'
G_SFS_TO_IGNORE[19]='SOLARIS OS PACKAGES AND PATCHES'
G_SFS_TO_IGNORE[20]='EXALYTICS AUDIT CHECKS'
G_SFS2INGORE=21
#--

ignore_sf_name=0
set_ignore_sf_name ()
{
  l_sf_counter=0
  while [[ $l_sf_counter -lt $G_SFS2INGORE ]] ; do
    l_sfname=${G_SFS_TO_IGNORE[$l_sf_counter]}
    if [[ $SF = $l_sfname ]] ; then
      ignore_sf_name=1
      return;
    else
      ignore_sf_name=0
    fi
    l_sf_counter=$(expr $l_sf_counter + 1)
  done
}

# Identifies the check type. Logic copied from generate_result_xml
# Output
#     $g_type : Check type
#     $g_hosts: machine/db/switch names
get_check_type ()
{
  g_type=""
  g_hosts=""
  g_hosts_passed="" # On cell no new message for passed checked

  if [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
  then
    cwc_failed=0
    if [[ "$cell_outcheck_type" = "cwc" ]]
    then # failed on one node = failed on all nodes
      cellname_counter=0
      for cellname in ${a_cellname[@]}
      do
        if [[ ${a_cellCheckStatus[$cellname_counter]} != "PASS" ]]
        then
          cwc_failed=1
        fi
        cellname_counter=$(expr $cellname_counter + 1 )
      done
    fi

    g_type="Storage Server Check"
    cellname_counter=0
    for cellname in ${a_cellname[@]}
    do
      cell_status=${a_cellCheckStatus[$cellname_counter]}
      if [[ "$cell_outcheck_type" = "cwc" && $cwc_failed = "1" ]]
      then
        cell_status="FAIL"
      fi

      if [[ $cell_status != "PASS" ]]
      then
        if [[ `echo $g_hosts | grep -ic $cellname` -eq 0 ]] ; then
          g_hosts="$cellname, $g_hosts"
        fi
        # Storage server check status is stored in a array. 
        # For PASS, a new message is not created
      else
        if [[ `echo $g_hosts_passed | grep -ic $cellname` -eq 0 ]] ; then
          g_hosts_passed="$cellname, $g_hosts_passed"
        fi
      fi
      update_check_status "$cell_status" $cch_check_id
      cellname_counter=$(expr $cellname_counter + 1 )
    done
    g_hosts_saved=$g_hosts
    g_hosts=$(echo $g_hosts_saved | sed 's/,$//')
    g_hosts_saved=$g_hosts_passed
    g_hosts_passed=$(echo $g_hosts_saved | sed 's/,$//')
  elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]]
  then
    g_type="Switch Check"
    g_hosts="$switchname"
  elif [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" ]]
  then
    g_type="OS Check"
    g_hosts="$i"
  elif [ $COMTYPE = "OS" ]
  then
    if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
    then
      g_type="Database Check"
      g_hosts="$i:$db_name_to_check"
    elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]
    then
      g_type="ORACLE_HOME Check"
      g_hosts=" $i:$mb_db_homes"
    elif [[ "$NEEDS_RUNNING" = "ASM" ]]
    then
      g_type="ASM Check"
      g_hosts="$i"
    elif [[ "$NEEDS_RUNNING" = "STORAGE_CELL" ]]
    then
      g_type="Storage Server Check"
      g_hosts="$cellname"
    elif [[ "$NEEDS_RUNNING" = "ZFS" ]]
    then
      g_type="ZFS Storage Appliance Check"
      g_hosts="$cellname"
    else
      g_type="OS Check"
      g_hosts="$i"

    fi
  elif [[ $COMTYPE = "SQL" || $COMTYPE = "SQL_OUT_CHECK" ]]
  then
    g_type="SQL Check"
    g_hosts="$db_name_to_check"
  elif [[ $COMTYPE = "SQL_PARAM" ]]
  then
    g_type="SQL Parameter Check"
    g_hosts="$inst_name"
  elif [[ $COMTYPE = "CLUSTERWIDE_CHECK" || $COMTYPE = "CROSS_NODE_CHECK" ]]
  then
    g_type="$html_rack_type Wide Check"
    g_hosts="$html_rack_type Wide"
  elif [ $COMTYPE = "SYSTEMWIDE_CHECK" ]
  then
    g_type="System Wide Check"
    g_hosts="System Wide"
  elif [ $COMTYPE = "ORACLE_PATCH" ] && [[ $HOME_PATH = "CRS" || $HOME_PATH = "ASM" || $HOME_PATH = "RDBMS" ]]
  then
    g_type="Patch Check"
    if [[ $HOME_PATH = "CRS" || $HOME_PATH = "ASM" ]]
    then
      g_hosts="$i:$message4Home"
    elif [ $HOME_PATH = "RDBMS" ]
    then
      g_hosts="$i:$mb_db_homes"
    fi
  else
    echo "Could not find the check type/target"
    g_type="Unknown"
    g_hosts="Unknown"
  fi
}

# Array G_CHECKIDS holds all check id's, one entry for each status
# Key is check_id and status
# This function will insert a check id into the array if does not exists
# Input:
#   Status
#   Check id
# Output:
#   $g_cid : Index number in array for the i/p check id
get_check_id_number ()
{
  gci_index=0;
  g_cid=-1;
  gci_cid="A${2}_$1"
  if [ -z $(eval echo \${$gci_cid}) ]
  then # First time
  #while [ $gci_index -lt $g_cch_cnt ]
  #do
  #  chk_status=$(echo ${G_CHECKID_STATUS[$gci_index]} | awk -F":" '{print $1}')
  #  if [[ "${G_CHECKIDS[$gci_index]}" = "$2" && $chk_status = "$1" ]]
  #  then # Already there
  #    g_cid=$gci_index;
  #    break;
  #  fi
  #  let gci_index=$gci_index+1
  #done

  #if [ $g_cid -eq -1 ] 
  #then # Assign a new id
    eval $gci_cid=$g_cch_cnt
    g_cid=$g_cch_cnt
    G_CHECKIDS[$g_cid]=$2
    let g_cch_cnt=$g_cch_cnt+1
  else
    g_cid=$(eval echo \${$gci_cid});
  fi
}

# Find the right check_id and initialize variable $cch_check_id
# Output:
#   $cch_check_id
get_check_id ()
{
  if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
  then 
    cch_check_id=${crs_check_id[$crs_check_file_counter]}
  else
    cch_check_id=$CHECK_ID
  fi
}

# This function will create a variable by name <checkid> using eval and assigns below values
# = 1 if the status is PASS
# = -1 if the status is FAIL
# = 2 if the status has both pass and fail
update_check_status ()
{
  ucs_status=$1
  ucs_cid="A$2" # Variable names can't start with number. So append dummy letter A

  if [ -z $(eval echo \${$ucs_cid}) ]
  then # First time
    #let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1 # unique check count
    if [ $ucs_status = "PASS" ] 
    then
      eval $ucs_cid=1
    else
      eval $ucs_cid=-1
    fi
  else # We have results for the check from another host/db
    ucs_current=$(eval echo \${$ucs_cid}) # Status from previous host/db
    if [[ $ucs_current -eq "1" && $ucs_status != "PASS" ]]
    then # Passed in earlier hosts, failed in the new host
      eval $ucs_cid=2
    elif [[ $ucs_current -eq "-1" && $ucs_status = "PASS" ]]
    then # Failed in earlier hosts, passed in the new host
      eval $ucs_cid=2
    fi
  fi
  
}

# for PASS messages log_pass does not initialize ONFAIL and LINK variable
# This function does that
write_additional_info ()
{
     # ALVL="PASS"
     alvl_value="PASS"
     if [ -n "$1" ] ; then alvl_value="$1"; fi
     if [ $COMTYPE != "OS_PACKAGE-DISABLED" ]
     then
         #grab the details from the appendix
         LINKNUM=0
         LINK=
         if [ $op_mode -eq 0 ]
         then
             LINKNUM=`grep -c _$ROW-LINK $REFFIL1`
             BEGPAT="_$ROW-BEGIN_COMMENTS"
             ENDPAT="_$ROW-END_COMMENTS"
         else
             if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
             then 
                 CHECK_ID=${crs_check_id[$crs_check_file_counter]}
             fi 
             LINKNUM=`grep -c _$CHECK_ID-LINK $REFFIL1`
             BEGPAT="_$CHECK_ID-BEGIN_COMMENTS"
             ENDPAT="_$CHECK_ID-END_COMMENTS"
         fi
         ONFAIL=`sed -n /$BEGPAT/,/$ENDPAT/p $REFFIL1 |sed s/$BEGPAT//g | sed s/$ENDPAT//g |sed 's/ / /g'`
 
         #Added this line to add pass/fail message as rational if its ORACLE_PATH and ratinoal is empty
         if [[ "$COMTYPE" = "ORACLE_PATCH" && `echo $ONFAIL|sed '/^$/d'|wc -l` -eq 0 ]];then ONFAIL=$PMSG;fi
         if [ $LINKNUM -gt 0 ]
         then
            #echo "$ROW LINKNUM = $LINKNUM" >>$REPFIL
            for ((j=1;j<=$LINKNUM;j+=1));
            do
              #echo "j=$j, ROW=$ROW" >>$REPFIL
              if [ $op_mode -eq 0 ]
              then
                  LINK=`grep "_"$ROW"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
              else
                  LINK=`grep "_"$CHECK_ID"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
              fi
              if [ $CREATE_HTML_REPORT -eq 1 ]
              then
                append_links_html "$alvl_value"
              fi
            done
         fi

         if [ $CREATE_HTML_REPORT -eq 1 ]
         then # gadiga - for html reports
           create_checkid_html "$alvl_value"
           write_output_to_html "$alvl_value"
         fi
     else
         if [ $CREATE_HTML_REPORT -eq 1 ]
         then  # gadiga - for html reports
           write_output_to_html "$alvl_value"
         fi
     fi # end if not to print in report file for OS_PACAKGE
}

# Info related to a check are stored in different arrays using the same index
# which is used in checkid array G_CHECKIDS
# Output:
#   Global arrays which hold the info on each check
init_arrays_html ()
{
  cch_check_id=""
  get_check_id
  if [ $1 = "PASS" ]
  then
    if [[ -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi
    get_check_id_number "PASS" $cch_check_id
    update_check_status "PASS" $cch_check_id
    if [[ -n $ORIG_PMSG && `echo "$PMSG" | grep -ic "$ORIG_PMSG"` -ge 1 ]]
    then # ORIG_PMSG has message without db names
      cch_cname="$ORIG_PMSG"
    else
      cch_cname="$PMSG"
    fi
    cch_status="PASS"
  else # FAIL 
    get_check_id_number "$ALVL" $cch_check_id
    update_check_status "FAIL" $cch_check_id
    if [[ -n "$ORIG_FMSG" && `echo "$FMSG" | grep -ic "$ORIG_FMSG"` -ge 1 ]]
    then # ORIG_FMSG has message without db names
      cch_cname="$ORIG_FMSG"
    else
      cch_cname="$FMSG"
    fi
    cch_status="$ALVL"
  fi
  get_check_type

  if [[ -n "$skip_maa_scorecard" && $skip_maa_scorecard -eq 0  ]]; then
        if [[ `echo $check_components|grep -ic "MAA"` -ge 1 && `echo $components|grep -ic "MAA"` -ge 1 ]]
          then
                G_CHECKID_MAA_SF[$g_cid]=$SF
          elif [[ `echo $cch_cname|grep -ic "System is not exposed"` -ge 1  || `echo $cch_cname|grep -ic "System is exposed"` -ge 1 ]]
          then
            if [[ -n "$maa_scorecard" && $maa_scorecard -eq 0 ]] ; then
                G_CHECKID_MAA_SF[$g_cid]=""
            else
                G_CHECKID_MAA_SF[$g_cid]='SOFTWARE MAINTENANCE BEST PRACTICES'
            fi
          else
                G_CHECKID_MAA_SF[$g_cid]=""
          fi
  else
        G_CHECKID_MAA_SF[$g_cid]=""
  fi

  CID_HTML_REPFILE="$OUTPUTDIR/$cch_check_id.html"
  #G_CHECKIDS[$g_cch_cnt]=$cch_check_id
  G_CHECKID_INFO[$g_cid]="${cch_cname}"
  G_CHECKID_TYPE[$g_cid]="$g_type"
  G_CHECKID_STATUS[$g_cid]="$cch_status:$1" # Some INFO can be PASS.. So we store INFO:PASS

  # Append host names for each each
  if [ -z "${G_CHECKID_HOSTS[$g_cid]}" ]
  then
    G_CHECKID_HOSTS[$g_cid]="$g_hosts"
  else
    G_CHECKID_HOSTS[$g_cid]="${G_CHECKID_HOSTS[$g_cid]}, $g_hosts";
  fi

  # Append host names for each each
  if [ -z "${G_CHECKID_HOSTS_PASSED[$g_cid]}" ]
  then
    G_CHECKID_HOSTS_PASSED[$g_cid]="$g_hosts_passed"
  else
    G_CHECKID_HOSTS_PASSED[$g_cid]="${G_CHECKID_HOSTS_PASSED[$g_cid]}, $g_hosts_passed";
  fi

  # Save for use in write_output_to_html. These varibales are unset before we call function
  G_SOURCEFIL_REPORT="$SOURCEFIL_REPORT"
  G_SOURCEFIL_REPORT_NEW="$SOURCEFIL_REPORT_NEW"
  
}

# Additional details on a check are stored in a <checkid>.html as discussed before.
# The information needs to be written only once for each check.
# Output:
#   <checkid>.html  - temporary files.. deleted after creating raccheck.html
create_checkid_html ()
{
  if [[ $1 = "PASS" && -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi
  if [ ! -e "$CID_HTML_REPFILE" ]
  then
    set_ignore_sf_name;
    if [[ $COMTYPE = "OS_PARAM" || $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" || $COMTYPE = "SQL_PARAM" ]]
    then
      if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
      cch_check_name="Check for parameter $p_name"
    elif [[ $COMTYPE = "ORACLE_PATCH" ]]
    then
      if [ -n "$PARAM_NAME" ] ; then p_name=$PARAM_NAME; else p_name=$PARAM_PATH; fi
      cch_check_name="Check ORACLE_PATCH $p_name for $HOME_PATH home"
    else
      cch_check_name=$(echo $audit_check_name|sed 's/\[DBMV2]//g')
    fi

    echo "<hr>" >> $CID_HTML_REPFILE
    echo "<a name=\"${cch_check_id}_details\"></a>" >> $CID_HTML_REPFILE
    echo "<a href=\"#${cch_check_id}_summary\" class=\"a_bgw\">Top</a><br>" >> $CID_HTML_REPFILE
    echo "<h3>${cch_check_name}</h3>" >> $CID_HTML_REPFILE
    echo "<table width=800 summary="Summary of audit check and SF" role="presentation">" >> $CID_HTML_REPFILE
    if [[ $ignore_sf_name -eq "0" ]] ; then
      echo "<tr><td>Success Factor</td><td>${SF}</td></tr>" >> $CID_HTML_REPFILE
    fi
    #cch_onfail=$(echo $ONFAIL | sed 's/</&lt;/g' | sed 's/>/&gt;/g' | sed 's/ /&nbsp;/g' | sed 's/\n/<br>/g')
    cch_onfail=$(echo "$ONFAIL" | sed 's/</\&lt;/g' | sed 's/>/\&gt;/g' | sed 's/\n/<br>/g' )
    cch_onfail="<pre>$cch_onfail</pre>";
    echo "<tr><td>Recommendation</td><td>$cch_onfail</td></tr>" >> $CID_HTML_REPFILE
    # Write links and close table.
    if [ ! -z "$G_LINKS" ] ; then
      echo "<tr><td>Links</td><td><ul>$G_LINKS</ul></td></tr>" >> $CID_HTML_REPFILE
    fi;
    # At this point we don't know all hosts where check was run. So just create a placeholder
    # which is replaced with actual host names before writing rachcheck.html
    echo "<tr><td><a name=\"${cch_check_id}_machines\"></a>Needs attention on</td><td>PLACEHOLDER_TO_REPLACE_FAIL</td></tr>" >> $CID_HTML_REPFILE
    echo "<tr><td></a>Passed on</td><td>PLACEHOLDER_TO_REPLACE_PASS</td></tr>" >> $CID_HTML_REPFILE
    echo "</table>" >> $CID_HTML_REPFILE
  fi
  unset G_LINKS
}

# Show the contents of .out file.
# If the file has more than $G_OUT_LINES (default 20) lines (excluding blank lines), 
#  show a more link and truncate rest of contents
# div id for hidden region will be <filename>_more_text
# id for more/hide link is <filename>_more_text_mh
# In file name replace "." with "_"
show_file_in_html ()
{
  sfh_index=0
  sfh_dindex=0
  sfh_show_line=1
  sfh_id=$(echo $G_SOURCEFIL_REPORT | awk -F"/" '{print $NF}' | sed 's/\./_/g')
  sfh_display_more=0

  sfh_hosts="$g_hosts"
  sfh_suffix="$cch_check_id"
  if [[ -n "$parse_passed_list" && $parse_passed_list -eq "1" ]]
  then
    sfh_hosts="$g_hosts_passed"
    sfh_suffix=$cch_check_id"_passed"
  fi

  sfh_suffix=$RANDOM

  sfh_rcnt=$(grep -ic "TO REVIEW COLLECTED" $G_SOURCEFIL_REPORT)
  if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ] ; then  sfh_rcnt=0; fi;

  echo "<a name=\"${sfh_id}_more_text${sfh_suffix}_a\"></a>" >> $CID_HTML_REPFILE

  old_IFS=$IFS
  IFS=$'\n'

  while read sfh_line
  do
    sfh_lined=$(echo "$sfh_line" | sed 's/TO REVIEW COLLECTED //' | sed 's/>/\&gt;/g' | sed 's/</\&lt;/g')

    if [[ $sfh_rcnt -gt "1" && `echo "$sfh_line" | grep -ic "TO REVIEW COLLECTED DATA"` -gt 0 ]]
    then # Multiple o/p in a single file
      if [[ `echo "$sfh_line" | grep -ic " DATABASE -"` -gt "0" || `echo "$sfh_line" | grep -ic " ORACLE_HOME -"` -gt "0" ]]
      then # by db/instance/oracle_home name
        sfh_mname=$(echo "$sfh_line" | awk '{print $8}')
      else # by host name
        sfh_mname=$(echo "$sfh_line" | awk '{print $6}')
      fi
      if [[ `echo $sfh_hosts | grep -icw $sfh_mname` -gt 0 ]]
      then # Its from failed host
        sfh_show_line=1
      else # Its not from failed host
        sfh_show_line=0
      fi
    fi
    if [ $sfh_show_line -eq "1" ]
    then
      if [[ $sfh_dindex -eq $G_OUT_LINES ]]
      then # After $G_OUT_LINES lines are displayed, hide rest of lines
        echo "<div id=\"${sfh_id}_more_text$sfh_suffix\" style=\"DISPLAY: none\">" >> $CID_HTML_REPFILE
        sfh_display_more=1
      fi

      echo "$sfh_lined" >> $CID_HTML_REPFILE
      let sfh_dindex=$sfh_dindex+1
    fi

    let sfh_index=$sfh_index+1
    # sfh_index may not be visible outside while.. so below workaround
    if [[ $sfh_index -ge $woh_line_cnt && $sfh_dindex -gt $G_OUT_LINES && $sfh_display_more -eq 1 ]]
    then
      echo "</div><a id=\"${sfh_id}_more_text${sfh_suffix}_mh\" class=more_less_style onclick=\"javascript:ShowHide('${sfh_id}_more_text$sfh_suffix')\" href=\"javascript:;\" >Click for more data</a>" >> $CID_HTML_REPFILE
    fi
  done < ${G_SOURCEFIL_REPORT}
  IFS=$old_IFS

  # Alternatives
  # 1. cat ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
  # 2. a.txt has 48 lines. then
  # head -20 a.txt > 1.txt
  # Display div
  # tail -28 readme.txt >> 1.txt
  # Close div
}

# Append the .out file contents  to <checkid>.html from each run for the check.
write_output_to_html ()
{
  wh_status="$1"
  parse_passed_list=0
  wh_hosts=$g_hosts

  if [[ $wh_status = "PASS" && -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi

  if [ ! -e "$CID_HTML_REPFILE" ]
  then # OS_PACKAGE does not print from appendix. So create_checkid_html was never called
    echo "<hr><br>" >> $CID_HTML_REPFILE
    echo "<a name=\"${cch_check_id}_details\"></a>" >> $CID_HTML_REPFILE
    echo "<a href=\"#${cch_check_id}_summary\" class=\"a_bgw\">Top</a><br>" >> $CID_HTML_REPFILE
  fi

  if [[ `echo ${G_SOURCEFIL_REPORT} |grep -ic "$CHECK_ID.html"` -gt 0 ]] ; then
    # just append contents
    lines=$(grep -n -w "Status on $sl_hosts" ${G_SOURCEFIL_REPORT} | cut -d":" -f1)
    if [ -z "$lines" ] ; then lines=0; fi;
    tlines=$(wc -l ${G_SOURCEFIL_REPORT}| awk '{print $1}')
    lines_to_tail=$(expr $tlines - $lines)
    lines_to_tail=$(expr $lines_to_tail + 1)
    #tail -$lines_to_tail ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
    tail -$lines_to_tail ${G_SOURCEFIL_REPORT} > ${G_SOURCEFIL_REPORT}.tailed
    if [[ `grep -ic "<b>Status on" ${G_SOURCEFIL_REPORT}.tailed` -gt 1 ]] ; then
      hlines=$(grep -n "<b>Status on" ${G_SOURCEFIL_REPORT}.tailed | cut -d":" -f1 |head -2 |tail -1)
      hlines=$(expr $hlines - 1)
      head -$hlines ${G_SOURCEFIL_REPORT}.tailed >> $CID_HTML_REPFILE
    else
      cat ${G_SOURCEFIL_REPORT}.tailed >> $CID_HTML_REPFILE
    fi
    #rm -f ${G_SOURCEFIL_REPORT}
    return;
  fi

  if [[ -n "$g_hosts_passed" && $wh_status = "PASS" ]]
  then # On cells when check passed on all cells
    wh_hosts=$g_hosts_passed
    parse_passed_list=1
  fi

  show_full_file=1
  if [[ `echo $COMTYPE | grep -ic "PARAM"` -gt 0 ]]
  then
    show_full_file=0
  fi

  if [[  $COMTYPE = "OS_PACKAGE" || $COMTYPE = "OS_PATCH" ]]
  then
    show_full_file=0
  fi
  if [[ "$PARAM_PATH" = "UNSPECIFIED" ]]
  then
    show_full_file=1
  fi

  if [ -e "${G_SOURCEFIL_REPORT}" ]
  then
    # Write status only if there is output
    echo "<br>" >> $CID_HTML_REPFILE
    echo "<table class=\"td_output\" summary=\"Audit check output\"><tr class=\"td_output\"><td class=\"td_output\"><p class=a_bgw><b>Status on $wh_hosts</b>:<br/><span class=\"status_$wh_status\">$wh_status</span> => ${cch_cname}</p></td></tr>" >> $CID_HTML_REPFILE
    woh_line_cnt=$(cat $G_SOURCEFIL_REPORT | wc -l | sed 's/ //g')
    if [ $woh_line_cnt -gt 0 ]
    then # We dont want to show row if file is blank
      echo "<tr class=\"td_output\"><td class=\"td_output\"><pre>" >> $CID_HTML_REPFILE
      if [[ $show_full_file -eq 1 ]]
      then
        show_file_in_html ${G_SOURCEFIL_REPORT}
      else
        # When the check is about a parameter, dont display the whole file. 
        # Just grep for parameter
        woth_param=$(echo $PARAM_PATH | awk -F"|" '{print $1}') # PARAM_PATH can be like gcc|4.0.1 In such cases we only grep first token
        #echo "PARAM_PATH=$PARAM_PATH ${g_hosts}.$woth_param" >> $CID_HTML_REPFILE
        wot_param_line=$(grep -i "${g_hosts}.$woth_param" ${G_SOURCEFIL_REPORT})
        if [ -z "$wot_param_line" ]
        then # Instance name is not added to parameter name. So grep just param name
          grep -i "$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
        else
          grep -i "${g_hosts}.$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
        fi
      fi
      echo "</pre></td></tr>" >> $CID_HTML_REPFILE
    fi # end if  $woh_line_cnt -gt 0 
    echo "</table>" >> $CID_HTML_REPFILE
  fi # end if -e $G_SOURCEFIL_REPORT

  if [[ -n "$g_hosts_passed" && $wh_status != "PASS" ]]
  then #Passed on some cells. No seperate message.
    if [ -e "${G_SOURCEFIL_REPORT}" ]
    then
      echo "<br>" >> $CID_HTML_REPFILE
      echo "<table class=\"td_output\" summary=\"Audit check output\"><tr class=\"td_output\"><td class=\"td_output\"><p class=a_bgw><b>Status on $g_hosts_passed</b>:<br/><span class=\"status_PASS\">PASS</span></p></td></tr>" >> $CID_HTML_REPFILE
      woh_line_cnt=$(cat $G_SOURCEFIL_REPORT | wc -l | sed 's/ //g')
      if [ $woh_line_cnt -gt 0 ]
      then # We dont want to show row if file is blank
        echo "<tr class=\"td_output\"><td class=\"td_output\"><pre>" >> $CID_HTML_REPFILE
        if [[ $show_full_file -eq 1 ]]
        then
          parse_passed_list=1
          show_file_in_html ${G_SOURCEFIL_REPORT}
          parse_passed_list=0
        else
          # When the check is about a parameter, dont display the whole file. 
          # Just grep for parameter
          woth_param=$(echo $PARAM_PATH | awk -F"|" '{print $1}') # PARAM_PATH can be like gcc|4.0.1 In such cases we only grep first token
          wot_param_line=$(grep -i "${g_hosts_passed}.$woth_param" ${G_SOURCEFIL_REPORT})
          if [ -z "$wot_param_line" ]
          then # Instance name is not added to parameter name. So grep just param name
            grep -i "$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
          else
            grep -i "${g_hosts_passed}.$woth_param" ${G_SOURCEFIL_REPORT} >> $CID_HTML_REPFILE
          fi
        fi
        echo "</pre></td></tr>" >> $CID_HTML_REPFILE
      fi # end if  $woh_line_cnt -gt 0 
      echo "</table>" >> $CID_HTML_REPFILE
    fi # end if -e $G_SOURCEFIL_REPORT
 
  fi
}

# Link can be like
# 1 VMM Page Replacement Tuning - http://publib.boulder.ibm.com/infocenter/pseries/v5r3/index.jsp?topic=/com.ibm.aix.prftungd/doc/prftungd/values_minperm_maxperm_param.htm
# 2 Virtual Memory Mgmt -Tuning Parameter: lru_file_repage (PDF) - http://www-03.ibm.com/support/techdocs/atsmastr.nsf/5cb5ed706d254a8186256c71006d2e0a/125bda8fe26e45008625718000719309/$FILE/LruFileRepage.pdf
# 3 Optimizing AIX 5L performance: Tuning your memory settings - http://www.ibm.com/developerworks/aix/library/au-aixoptimization-memtun1/index.html?ca=drs-
# 4 Note: 811293.1 - RAC Starter Kit (AIX) - 
#
# When there is a http://, just create text before that as a link to http url.
# When there is a note, link like below
#      https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=<noteid>
append_links_html ()
{
  if [[ $1 = "PASS" && -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] ; then return; fi

  # Remove the first digit
  alh_link=$(echo $LINK | sed 's/^[0-9]* //')
  if [[ `echo "$alh_link" | grep -ic "http:"` -ge 1 ]]
  then # Link exists in variable
    alh_link_text=$(echo $alh_link | sed 's/http:.*//'| sed 's/- *$//')
    alh_link_url=$(echo $alh_link | sed 's/.*http:/http:/'| sed 's/ *$//')
    alh_link="<a href=\"$alh_link_url\" target=\"_blank\">$alh_link_text</a>";
  elif [[ `echo "$alh_link" | grep -ic "https:"` -ge 1 ]]
  then # Link exists in variable
    alh_link_text=$(echo $alh_link | sed 's/https:.*//'| sed 's/- *$//')
    alh_link_url=$(echo $alh_link | sed 's/.*https:/https:/'| sed 's/ *$//')
    alh_link="<a href=\"$alh_link_url\" target=\"_blank\">$alh_link_text</a>";
  elif [[ `echo "$alh_link" | grep -ic "Note: "` -ge 1 ]]
  then # MOS Note
    alh_link_text=$(echo "$alh_link" | sed 's/[ -]*$//g')
    alh_note_id=$(echo $alh_link | sed 's/Note: *//' | awk -F"-" '{print $1}' | sed 's/ //g')
    alh_link="<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=$alh_note_id\" target=\"_blank\">$alh_link_text</a>";
  fi
  G_LINKS="$G_LINKS<li>$alh_link</li>"
}

# Display only $G_HOST_CNT hosts and display more link
# When all hosts, then display All
# Output:
#   $crh_hosts with html for displaying in summary table
get_host_string_html ()
{
  ghs_cid="A${G_CHECKIDS[$crh_cnt]}"
  ghs_status=$(eval echo \${$ghs_cid})

  el_prefix=""
  ghs_ctype=""
  crh_rep_ptext_h=""
  crh_rep_prefix="compute" # Compute node check is default
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
  then
    crh_rep_ptext="Compute Node"
    if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
      crh_first_host=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | awk -F"," '{print $1}')
      crh_second_host=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | awk -F"," '{print $2}')
      get_el_prefix "$crh_first_host"
      el_prefix_first=$el_prefix
      if [[ -n "$crh_second_host" && $el_prefix_first != "CN" ]] ; then
        get_el_prefix "$crh_second_host"
        if [[ $el_prefix_first = "PC" && $el_prefix = "PC" ]] ; then
          el_prefix="PC"
        else
          el_prefix="CS"
        fi
      fi
      if [[ $el_prefix = "DB" ]] ; then
        crh_rep_ptext="Control DB Node"
      elif [[ $el_prefix = "EC" ]] ; then
        crh_rep_ptext="Enterprise Controller"
      elif [[ $el_prefix = "PC" ]] ; then
        crh_rep_ptext="Proxy Controller"
      elif [[ $el_prefix = "OVMM" ]] ; then
        crh_rep_ptext="OVM Manager Node"
      elif [[ $el_prefix = "CS" ]] ; then
        crh_rep_ptext="Control vServer"
      fi
      if [[ $el_prefix != "CN" ]] ; then
        crh_rep_prefix="cvserver"
        crh_rep_ptext_h="Control vServer"
        ghs_status="2"
      fi
    fi
  elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]] ; then
    crh_rep_ptext="Compute Node"
  else
    crh_rep_ptext="Database Server"
  fi

  case ${G_CHECKID_TYPE[$crh_cnt]} in
  "Storage Server Check")
                       ghs_ctype="Storage Servers"
                       crh_rep_prefix="cell" 
                       crh_rep_ptext="Storage Server"
                       ;;
  "ZFS Storage Appliance Check")
                       ghs_ctype="ZFS Storage Appliances"
                       crh_rep_prefix="zfscell" 
                       crh_rep_ptext="ZFS Storage Appliance"
                       ;;
  "Switch Check")
                       ghs_ctype="Infiniband Switches"
                       crh_rep_prefix="switch" 
                       crh_rep_ptext="Infiniband Switch"
                       ;;
  "OS Check")
                       ghs_ctype="${crh_rep_ptext}s"
                       ;;
  "Database Check"|"SQL Check")
                       ghs_ctype="Databases"
                       ;;
  "Patch Check")
                       ghs_ctype="Homes"
                       ;;
  "ORACLE_HOME Check")
                       ghs_ctype="ORACLE_HOME's"
                       ;;
  "ASM Check")
                       ghs_ctype="ASM Instances"
                       ;;
  "SQL Parameter Check")
                       ghs_ctype="Instances"
                       ;;
  esac
 
  if [ $ghs_status -eq "2" ]
  then # Partial hosts
    ghs_cnt=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | awk -F"," '{print NF}')
    if [ $ghs_cnt -gt $G_HOST_CNT ]
    then # Truncate and display more link
      crh_host_names=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | cut -d"," -f"1-5") #First 5 hosts
      crh_hosts="<a href=\"#${G_CHECKIDS[$crh_cnt]}_machines\" title=\"${G_CHECKID_HOSTS[$crh_cnt]}\">${crh_host_names}  more</a>";
    else
      crh_hosts=${G_CHECKID_HOSTS[$crh_cnt]}
    fi
  else
    if [ ${G_CHECKID_TYPE[$crh_cnt]} = "$html_rack_type Wide Check" ]
    then
      crh_hosts="$html_rack_type Wide"
      crh_rep_prefix="cluster"
      crh_rep_ptext="$html_rack_type Wide"
    else
      if [ ${G_CHECKID_TYPE[$crh_cnt]} = "System Wide Check" ]
      then
        crh_hosts="System Wide"
        crh_rep_prefix="system"
        crh_rep_ptext="System Wide"
      else
        if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]; then
          crh_hosts=${G_CHECKID_HOSTS[$crh_cnt]}
        else
          crh_hosts="All $ghs_ctype"
        fi
      fi
    fi
  fi
}

# Below function writes a row report directly to the <status>.html which later gets appended
# to raccheck.html. Some cluster-wide-checks does not use log_fail infrastructure. 
# This function is called in such cases. Status on is always "All" as its cluster-wide-check
# Input:
#    Status (FAIL/PASS etc)
#    Message (Actual message)
# Output:
#    <status>.html
write_cwc_status_html ()
{
  wts_status=$1
  wts_msg=$2

  if [[ $wts_status = "PASS" ]]
  then
    if [ ! -r "${OUTPUTDIR}/PASS_cluster.html" ]
    then # Write the header
      cat > ${OUTPUTDIR}/PASS_cluster.html <<EOF
           <a name="passed_checks_cluster"></a>
           <H2>$html_rack_type Wide</h2>
           <table border=1 id="passedtbl_cluster" summary="Clusterwide checks">
           <tr><th scope="col">Status</th>
           <th scope="col">Type</th>
           <th scope="col">Message</th>
           <th scope="col">Status On</th>
           <th scope="col">Details</th></tr>
EOF
    fi

    echo "<tr><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('passedtbl_cluster', this,'')\">$wts_status</td><td>$html_rack_type Wide Check</td><td scope=\"row\">$wts_msg</td><td>$html_rack_type Wide</td><td>-</td></tr>" >> ${OUTPUTDIR}/PASS_cluster.html
  else
    if [[ $wts_status = "ERROR" || $wts_status = "FAIL" || $wts_status = "WARNING" || $wts_status = "INFO" ]]
    then
      wts_file_name="${OUTPUTDIR}/${wts_status}_cluster.html"
    else
      wts_file_name="${OUTPUTDIR}/OTHER_cluster.html"
    fi
    echo "<tr><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_cluster', this,'')\">$wts_status</td><td>$html_rack_type Wide Check</td><td scope=\"row\">$wts_msg</td><td>$html_rack_type Wide</td><td>-</td></tr>" >> $wts_file_name
  fi
  let g_tr_index=$g_tr_index+1
}

# This function creates the raccheck.html file by appending all the <checkid>.html files
# Output:
#   raccheck.html
create_raccheck_html ()
{
  crh_obname=$(basename $OUTPUTDIR)
  HTML_REPFILE=${OUTPUTDIR}/${crh_obname}.html 
  HTML_PASS_FILE=${OUTPUTDIR}/passed_checks.html
  HTML_FAILED_FILE=${OUTPUTDIR}/failed_checks.html
  HTML_MAA_SC=${OUTPUTDIR}/maa_scorecard.html
  TOOL_NAME=$program_name

  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
  then
    SYSTEM_NAME="Exadata"
    chmod 755 $SCRIPTPATH/.cgrep/create_version.pl >/dev/null 2>&1
    $perl_exe $SCRIPTPATH/.cgrep/create_version.pl ${OUTPUTDIR}
  elif [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
  then
    SYSTEM_NAME="Database Appliance"
  elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
  then
    SYSTEM_NAME="Exalogic"
  elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
  then
    SYSTEM_NAME="Exalytics"
  elif [[ -n "$single_instance_run" && $single_instance_run -eq 1 ]]
  then
    SYSTEM_NAME="Database"
  else
    SYSTEM_NAME="RAC"
  fi

  if [ $upgrade_mode -gt 0 ]
  then
    report_type="Upgrade Readiness"
  else
    report_type="Assessment"
  fi

  # System Health Score
  let crh_failed_checks=$G_FAIL_CHECKS+$G_WARN_CHECKS+$G_INFO_CHECKS
  let crh_passed_checks=$G_TOTAL_CHECKS-$crh_failed_checks

  let crh_total_points=$G_TOTAL_CHECKS*10
  let crh_err_points=$G_FAIL_CHECKS*10+$G_WARN_CHECKS*5+$G_INFO_CHECKS*3
  let crh_less_points=$crh_total_points-$crh_err_points
  crh_health=0
  crh_health_int=0
  crh_health_text="";
  if [[ $crh_total_points -gt "0" && `echo $components|grep -icw EXALOGIC_VM` -lt 1 ]]
  then
    crh_health=$(echo "scale=0;($crh_less_points*100)/$crh_total_points" | bc)
    crh_health_int=$(echo "($crh_less_points*100)/$crh_total_points" | bc)
    crh_health_text="";
  fi

  crh_bar_color="#00FF00" # Green.. everything is passed
  if [[ -n "$crh_health_int" &&  $crh_health_int -lt 75 ]]
  then # less than 75.. bad condition
    crh_bar_color="#FF0000"
  elif [[ $crh_health_int -ge 75 && $crh_health_int -lt 85 ]]
  then # Better.. dark orange
    crh_bar_color="#FF6600"
  elif [[ $crh_health_int -ge 85 && $crh_health_int -lt 100 ]]
  then # Better.. dark orange
    crh_bar_color="#FF9933"
  fi
  # Number of nodes in cluster by type
  dbservers_cnt=0
  cells_cnt=0
  ibs_cnt=0
  zfs_cnt=0
  dbservers_link=""
  cells_link=""
  ibs_link=""

  # Cluster, platform details are read from end file in offline mode
  if [ -e "$OUTPUTDIR/check_env.out" ]
  then
    MASTERFIL1=$OUTPUTDIR/check_env.out
  else
    MASTERFIL1=$OUTPUTDIR/raccheck_env.out
  fi

  el_db_node=""
  el_ec1_node=""
  el_ovmm_node=""
  el_pc_nodes=""
  el_pc1_node=""
  el_pc2_node=""
  el_exclude=""
  if [[ -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ;then
    el_db_node=$(grep '\.COMPONENT = .*EXALOGIC_DB' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u)
    el_ec1_node=$(grep '\.COMPONENT = .*EXALOGIC_EC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u)
    el_ovmm_node=$(grep '\.COMPONENT = .*EXALOGIC_OVMM' $MASTERFIL1 |sed 's/\.COMPONENT.*//' | sort -u)
    el_pc_nodes=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u)
    el_pc1_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u | head -1)
    el_pc2_node=$(grep '\.COMPONENT = .*EXALOGIC_PC' $MASTERFIL1 |sed 's/\.COMPONENT.*//'| sort -u | tail -1)
  fi

  if [ -e "$HOSTLIST" ]
  then
    dbservers_cnt=0
    el_snode_cnt=0
    for hostname in `cat $HOSTLIST |grep "[a-zA-Z0-9]" `
    do
      if [[  -n "$in_ec_exalogic" &&  $in_ec_exalogic -eq "1" ]] ; then
        if [[ $hostname != $el_db_node && $hostname != $el_ec1_node && $hostname != $el_ovmm_node && `grep -ic "$hostname\.COMPONENT.*EXALOGIC_PC" $MASTERFIL1` -eq "0" ]] ; then
          dbservers_cnt=$(expr $dbservers_cnt + 1);
          dbservers_link="<br>&nbsp;&nbsp;$hostname$dbservers_link" 
        else
          el_snode_cnt=$(expr $el_snode_cnt + 1)
        fi
      else
        dbservers_cnt=$(expr $dbservers_cnt + 1);
        dbservers_link="<br>&nbsp;&nbsp;$hostname$dbservers_link" 
      fi
    done
    dbservers_link="<a href=\"javascript:ShowHideRegion('dbservers_summary');\">$dbservers_cnt</a><div id=\"dbservers_summary\" style=\"DISPLAY: none\">$dbservers_link<a href=\"javascript:ShowHideRegion('dbservers_summary');\"> ..Hide</a></div>"
  fi
  if [ $dbservers_cnt = "0" ]
  then
    dbservers_link="0"
  fi

  if [[ -n "$CELLDIR" && -e "$CELLDIR/cells.out" && -n "$cell_password_status" && $cell_password_status -ne 3  ]]
  then
    cells_cnt=$(cat $CELLDIR/cells.out|wc -l)
    for cellname in `cat $CELLDIR/cells.out | awk '{print $NF}' | cut -d. -f1`
    do
      cells_link="<br>&nbsp;&nbsp;$cellname$cells_link"
    done
    cells_link="<a href=\"javascript:ShowHideRegion('cells_summary');\">$cells_cnt</a><div id=\"cells_summary\" style=\"DISPLAY: none\">$cells_link<a href=\"javascript:ShowHideRegion('cells_summary');\"> ..Hide</a></div>"
  fi
  cells_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Storage Servers</td><td>$cells_link</td></tr>"
  if [ "$cells_cnt" = "0" ]
  then
    cells_link=""
  fi
#code to generate links for ZFS appliances
  zfs_link=""
  if [ $is_ssc_machine -eq 1 ]; then ZFSIP=$OUTPUTDIR/zfsip.ora;fi
  if [[ -n "$CELLDIR" && -e "$ZFSIP" && -n "$zfs_password_status" && $zfs_password_status -ne 3  ]]
  then
    zfs_cnt=$(cat $ZFSIP|wc -l)
    for zfsname in `cat $ZFSIP |cut -d= -f2 |sed 's/\"//g'`
    do
      zfs_link="<br>&nbsp;&nbsp;$zfsname$zfs_link"
    done
    zfs_link="<a href=\"javascript:ShowHideRegion('zfs_summary');\">$zfs_cnt</a><div id=\"zfs_summary\" style=\"DISPLAY: none\">$zfs_link<a href=\"javascript:ShowHideRegion('zfs_summary');\"> ..Hide</a></div>"
    zfs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;ZFS Storage Appliances</td><td>$zfs_link</td></tr>"
  fi


  if [[ -n "$OUTPUTDIR/o_ibswitches.out" && -e "$OUTPUTDIR/o_ibswitches.out" && -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3 ]]
  then
    ibs_cnt=$(cat $OUTPUTDIR/o_ibswitches.out|wc -l)
    for switchname in `cat $OUTPUTDIR/o_ibswitches.out`
    do
      sw_pname=$switchname
      if [[ `echo $switchname | grep -ic '[0-9]*\.[0-9]*\.[0-9]*\.[0-9]*'` -eq 0 ]] ; then
        sw_pname=$(echo $switchname |cut -d. -f1)
      fi
      ibs_link="<br>&nbsp;&nbsp;$sw_pname$ibs_link"
    done
    ibs_link="<a href=\"javascript:ShowHideRegion('ibs_summary');\">$ibs_cnt</a><div id=\"ibs_summary\" style=\"DISPLAY: none\">$ibs_link<a href=\"javascript:ShowHideRegion('ibs_summary');\"> ..Hide</a></div>"
  fi
  ibs_link="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;IB Switches</td><td>$ibs_link</td></tr>"
  if [ "$ibs_cnt" = "0" ]
  then
    ibs_link=""
  fi

  profile_link=""
  if [ -n "$profiles2run" ] ; then
    profile_link="<tr><td class=\"td_column\">Selected Profiles</td><td>$profiles2run</td></tr>"
  fi
  let nodes_cnt=$dbservers_cnt+$cells_cnt+$ibs_cnt+$el_snode_cnt+$zfs_cnt

  # db names
  if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
  then # User selected none
    db_cnt=0
  else
    db_cnt=${#mb_db_names[@]}
  fi

  upg_link="";
  if [[ -n "$upgrade_mode" && $upgrade_mode -eq 2 ]] 
  then
    upg_link="<tr><td class=\"td_column\">Upgrade Mode</td><td>Pre-upgrade</td></tr>";
  elif [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 ]]
  then
    upg_link="<tr><td class=\"td_column\">Upgrade Mode</td><td>Post-upgrade</td></tr>";
  fi

  dbn_link=""
  if [ $db_cnt -gt "0" ]
  then
    for db_name_to_check in "${mb_db_names[@]}"
    do
      dbn_link="<br>&nbsp;&nbsp;$db_name_to_check$dbn_link"
    done
    dbn_link="<tr><td class=\"td_column\">Database Names</td><td><a href=\"javascript:ShowHideRegion('dbn_summary');\">$db_cnt</a><div id=\"dbn_summary\" style=\"DISPLAY: none\">$dbn_link<a href=\"javascript:ShowHideRegion('dbn_summary');\"> ..Hide</a></div></td></tr>"
  else
     if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
     then # User selected none
        dbn_link="None"
     else
        dbn_link="0"
     fi
     if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "0" ]]
     then
       dbn_link="<tr><td class=\"td_column\">Database Names</td><td>$dbn_link</td></tr>";
     else
       dbn_link=""
     fi
  fi
  
  # DB versions
  rm -f $OUTPUTDIR/mb_db_tmp.out
  mb_db_counter=0
  #for db_name_to_check in "${mb_db_names[@]}"
  #do
  #  l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f2)
  #  format_l_version
  #  oh_version=$l_version
  #  running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL1 |awk '{print $3}'`
  #  echo "${mb_oracle_homes[$mb_db_counter]}|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
  #  mb_db_counter=$(expr $mb_db_counter + 1)
  #done

  none_db_text="None Discovered"
  for mb_db_homes in `grep "RDBMS_ORACLE_HOME =" $MASTERFIL1 | awk -F"=" '{print $2}' | awk -F"|" '{print $1}' | sed 's/ //g'`
  do
    l_version=$(grep "RDBMS_ORACLE_HOME = $mb_db_homes" $MASTERFIL1 | awk -F"=" '{print $2}' | awk -F"|" '{print $2}' | sed 's/ //g')
    format_l_version
    oh_version=$l_version
    if [[ `grep "DB_NAME =" $MASTERFIL1 |grep $mb_db_homes | awk -F"=" '{print $2}' | awk -F"|" '{print $1}' |wc -l` -gt 0 ]]
    then
      for db_name_to_check in `grep "DB_NAME =" $MASTERFIL1 |grep $mb_db_homes | awk -F"=" '{print $2}' | awk -F"|" '{print $1}'|sed 's/ //g'`
      do
        running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL1 |awk '{print $3}'`
        echo "$mb_db_homes|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
      done
    else
      if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
      then
        none_db_text="None Selected"
      fi
      if [[ -n "$db_name_to_check_all" &&  $db_name_to_check_all -eq 1 ]]
      then
        none_db_text="None Discovered"
      else
        none_db_text="None Selected"
      fi
      echo "$mb_db_homes|${oh_version}|$none_db_text|$none_db_text" >> $OUTPUTDIR/mb_db_tmp.out
    fi
  done

  db_versions=""
  mb_db_counter=0
  if  [ -e $OUTPUTDIR/mb_db_tmp.out ]
  then
    for mb_oh_name in `cut -d'|' -f1  $OUTPUTDIR/mb_db_tmp.out |sort -u`
    do
      oh_version=$(grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f2|sort -u)
      db_cnt=$(grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f3|sort -u|wc -l)
      if [ $db_cnt -gt 0 ]
      then
        if [ $db_cnt -gt 1 ]
        then
          running_db_line=""
          for running_db in `grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f3|sort -u`
          do
            running_db_line="<br>&nbsp;&nbsp;$running_db$running_db_line"
          done # Finished printing db info for a OH
          dbn_link="<a href=\"javascript:ShowHideRegion('dbn_summary2');\">$db_cnt</a><div id=\"dbn_summary2\" style=\"DISPLAY: none\">$running_db_line<a href=\"javascript:ShowHideRegion('dbn_summary2');\"> ..Hide</a></div>"
        else
          dbn_link=`grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f3|sort -u`
        fi
        db_versions="${mb_oh_name} - ${oh_version} - $dbn_link<br>$db_versions";
      else
        db_versions="${mb_oh_name} - ${oh_version} - 0<br>$db_versions";
      fi
      mb_db_counter=$(expr $mb_db_counter + 1)
    done # Finished printing all homes
  fi
  mb_db_counter=0

  #db_versions=$(grep "RDBMS_ORACLE_HOME =" $MASTERFIL1 | awk -F"=" '{print $2}' | awk -F"|" '{print $1" - "$2"<br>"}'| sort -u)
  crs_home_path=$(grep "CRS_HOME =" $MASTERFIL1 | awk '{print $3}')

  if [ -z "$cluster_name" ] 
  then
    cluster_name=$(grep CLUSTER_NAME $MASTERFIL1 | awk -F"=" '{print $2}')
  fi

  if [[ -n "$el_pc_nodes" && `echo $el_pc_nodes | wc -w` -gt 1 ]]
  then
    el_pc_node_cnt=0
    for hostname in $el_pc_nodes
    do
      el_pc_node_link="<br>&nbsp;&nbsp;$hostname$el_pc_node_link"
      el_pc_node_cnt=$(expr $el_pc_node_cnt + 1)
    done
    el_pc_node_link="<a href=\"javascript:ShowHideRegion('el_pc_summary');\">$el_pc_node_cnt</a><div id=\"el_pc_summary\" style=\"DISPLAY: none\">$el_pc_node_link<a href=\"javascript:ShowHideRegion('el_pc_summary');\"> ..Hide</a></div>"
  else
    el_pc_node_link="$el_pc_nodes"
  fi

  node_heading="Database Server"
  summary_heading="Cluster Summary"
  if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
  then
    summary_heading="Exalogic Rack summary"
    skipped_checks_pass=0
    node_heading="Compute Node"
    crs_hv_link=""
    dbhv_link=""
    cname_link=""
    el_cs_row=""
    if [[ -n "$el_ec1_node" ]] ; then
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Enterprise Controller</td><td>$el_ec1_node</td></tr>"
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Control DB Node</td><td>$el_db_node</td></tr>"
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;OVM Manager Node</td><td>$el_ovmm_node</td></tr>"
      el_cs_row="$el_cs_row<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;Proxy Controllers</td><td>$el_pc_node_link</td></tr>"
    fi
    if [[ `grep -ic EXALOGIC_ACTUAL_VERSION_CN $MASTERFIL1` -gt 0 ]] ; then
      l_version=$(grep EXALOGIC_ACTUAL_VERSION_CN $MASTERFIL1 | tail -1 | awk -F"=" '{print $2}')
    else
      l_version=$exalogic_version_actual
    fi
    #format_l_version 1
    exalogic_version_link="<tr><td class=\"td_column\">Exalogic Version</td><td>$l_version</td></tr><tr><td class=\"td_column\">System Identifier</td><td>$RackIdentifier</td></tr>"
  elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
  then
     summary_heading="Exalytics System Summary"
    skipped_checks_pass=0
    node_heading="Compute Node"
    crs_hv_link=""
    dbhv_link=""
    cname_link=""
    el_cs_row=""
    if [[ `grep -ic EXALYTICS_VERSION_ACTUAL $MASTERFIL1` -gt 0 ]] ; then
      l_version=$(grep EXALYTICS_VERSION_ACTUAL $MASTERFIL1 | tail -1 | awk -F"= " '{print $2}')
    else
      l_version=$exalytics_version
    fi
    #format_l_version 1
    obiee_homes_link=""
    if [ -e "$OUTPUTDIR/mb_db_homes_distinct.out" ] ; then
      for bi_home in `cat $OUTPUTDIR/mb_db_homes_distinct.out`
      do
        obiee_homes="$bi_home<br>$obiee_homes";
      done
      if [ -n "$obiee_homes" ] ; then
        obiee_homes_link="<tr><td class=\"td_column\">OBIEE Homes</td><td>$obiee_homes</td></tr>";
      fi
    fi

    exalogic_version_link="<tr><td class=\"td_column\">Exalytics Version</td><td>$l_version</td></tr><tr><td class=\"td_column\">System Identifier</td><td>$RackIdentifier</td></tr>"
  else
   #changed this to 0 for bug 14148335
    skipped_checks_pass=0
    exalogic_version_link=""
    el_cs_row=""
    crs_hv_link="<tr><td class=\"td_column\">CRS Home - Version</td><td>$crs_home_path - ${stack_crs_version[0]}</td></tr>"
    dbhv_link="<tr><td class=\"td_column\">DB Home - Version - Names</td><td>$db_versions</td></tr>"
    cname_link="<tr><td class=\"td_column\">Cluster Name</td><td>$cluster_name</td></tr>"
  fi

  if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]; then 
    hosts_txt=`cat $HOSTLIST |grep "[a-zA-Z0-9]" `
    node_dlink="<tr><td class=\"td_column\">${node_heading}</td><td>$hosts_txt</td></tr>"
  else
    node_slink="<tr><td class=\"td_column\">Number of nodes</td><td>$nodes_cnt</td></tr>"
    node_dlink="<tr><td class=\"td_column\">&nbsp;&nbsp;&nbsp;${node_heading}s</td><td>$dbservers_link</td></tr>"
  fi
  if [[ $single_instance_run -eq "1" ]] ; then
    node_slink=""
    hostname=`cat $HOSTLIST`;
    node_dlink="<tr><td class=\"td_column\">Database Server</td><td>$hostname</td></tr>"
  fi

  if [[ $single_instance_run -eq "1" ]] ; then
    summary_heading="Summary";
    crs_hv_link=""
    cname_link=""
  fi;

  if [ -z "$upload_dbplatform" ]
  then
    upload_dbplatform=$(grep DB_PLATFORM $MASTERFIL1 | awk -F"=" '{print $2}')
  fi
  if [ -z "$upload_osdistro" ] 
  then
    upload_osdistro=$(grep OS_DISTRO $MASTERFIL1 | awk -F"=" '{print $2}')
  fi
  if [ -z "$upload_oskernel" ]
  then
    upload_oskernel=$(grep OS_KERNEL $MASTERFIL1 | awk -F"=" '{print $2}')
  fi
  if [ -z "$upload_osversion" ]
  then
    upload_osversion=$(grep OS_VERSION $MASTERFIL1 | awk -F"=" '{print $2}')
  fi
  if [ -z "$collection_date" ]
  then
    collection_date=$(grep "COLLECTION DATE" $MASTERFIL1 | awk -F"=" '{print $2}')
  fi

  tool_version=$(echo $show_version_envfile | awk -F"=" '{print $2}')

  collection_name=$(basename "${UPLOADFIL}.zip")
  if [ -n "$current_exadata_version" ]
  then
    l_version=$current_exadata_version
    format_l_version
    cev_link="<tr><td class=\"td_column\">Exadata Version</td><td>$l_version</td></tr>"
  else
    cev_link=""
  fi

  if [ $upgrade_mode -gt 0 ]
  then
    if [ -z "$TARGET_VERSION" ]
    then
      targetversion=$(grep "TARGET_VERSION" $MASTERFIL1 | awk -F"=" '{print $2}')
    fi
    l_version=$targetversion
    format_l_version
    tv_link="<tr><td class=\"td_column\">Target Version</td><td>$l_version</td></tr>"
  else
    tv_link=""
  fi

  cat > $HTML_REPFILE <<EOF
<html lang="en"><head>
<style type="text/css">
body {font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
    font-size: 13px;
    background:white;
}
h1 {color:blue;}
h2 {color:blue; background:white}
h3 {color:blue; background:white}
a {color: #000000;}
p {font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
    font-size: 13px;
}

.a_bgw {
  color: #000000;
  background:white;
}

table {
    color: #000000;
    font-weight: bold;
    border-spacing: 0;
    outline: medium none;
font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
font-size: 12px;

}

th {
 background: #D7EBF9;
    border: 1px solid #AED0EA;
    font-size: 13px;
    font-weight: bold;
}
td {

 background: #F2F5F7;
    border: 1px solid #AED0EA;
    font-weight: normal;
    padding: 5;
}

.status_FAIL
{
    font-weight: bold;
    color: #c70303;
}
.status_WARNING
{
    font-weight: bold;
    color: #b05c1c;
}
.status_INFO
{
    font-weight: bold;
    color: blue;
}
.status_PASS
{
    font-weight: bold;
    color: #006600;
}

.td_output {
  color: #000000;
 background: #E0E0E0;
    border: 1px solid #AED0EA;
font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
font-size: 13px;
    font-weight: normal;
    padding: 1;
}
.td_column {
 background: #D7EBF9;
    border: 1px solid #AED0EA;
    font-size: 13px;
    font-weight: bold;
}

.td_title {

 background: #F2F5F7;
    border: 0px solid #AED0EA;
    font-weight: normal;
    padding: 5;
}

pre {
 overflow-x: auto; /* Use horizontal scroller if needed; for Firefox 2, not needed in Firefox 3 */
 white-space: pre-wrap; /* css-3 */
 white-space: -moz-pre-wrap !important; /* Mozilla, since 1999 */
 white-space: -pre-wrap; /* Opera 4-6 */
 white-space: -o-pre-wrap; /* Opera 7 */
 /* width: 99%; */
 word-wrap: break-word; /* Internet Explorer 5.5+ */
}

.shs_bar {
width: 500px ;
height: 20px ;
float: left ;
border: 1px solid #444444;
background-color: #656565 ;
}

.shs_barfill {
height: 20px ;
float: left ;
background-color: $crh_bar_color ;
width: $crh_health% ;
}

.more_less_style {
  font-family: Lucida Grande,Lucida Sans,Arial,sans-serif;
  font-weight: bold;
  color: blue;
}

</style>
<script language="JavaScript">
function ShowHide(divId)
{
  if(document.getElementById(divId).style.display == 'none')
  {
    document.getElementById(divId).style.display='block';
    document.getElementById(divId+'_mh').innerHTML = 'Click for less data';
  }
   else
  {
    document.getElementById(divId).style.display = 'none';
    document.getElementById(divId + '_mh').innerHTML = 'Click for more data';
    window.location.hash = divId + '_a';
  }
}

function ShowHideRegion(divId)
{
  if(document.getElementById(divId).style.display == 'none')
  {
    document.getElementById(divId).style.display='block';
  }
   else
  {
    document.getElementById(divId).style.display = 'none';
  }
}

function getParam(name)
{
  var start=location.search.indexOf("?"+name+"=");
  if (start<0) start=location.search.indexOf("&"+name+"=");
  if (start<0) return 0;
  return 1;
}

function deleteRow(t, r, s)
{
  var i=r.parentNode.parentNode.rowIndex;
  document.getElementById(t).deleteRow(i);
  if ( document.getElementById(s) != null )
    document.getElementById(s).innerHTML="";
}

function createDeleteButton(k)
{
  var rc=document.getElementById('checkscnt').innerHTML;

  if (k == 1)
  {
    for (i=0; i<=rc; i++)
    {
      var pn = 'deletebutton' +i;
      if (document.getElementById(pn) != null )
          document.getElementById(pn).style.display="";
    }
    document.getElementById("show_hide_link").style.display="";
    document.getElementById("message_on_hide").style.display="";
    document.getElementById("show_edit_link").style.display="none";
  }
   else
  {
    for (i=0; i<=rc; i++)
    {
      var pn = 'deletebutton' +i;
      if (document.getElementById(pn) != null )
          document.getElementById(pn).style.display="none";
    }
    document.getElementById("show_hide_link").style.display="none";
    document.getElementById("message_on_hide").style.display="none";
    document.getElementById("show_edit_link").style.display="";
  }
}
</script>
<title>Oracle $SYSTEM_NAME $report_type Report</title>
</head><body>
<!-- Adding below gif will add a dependency to html report. So removed
<img border=0 src="rac_assurance_home.gif">
-->
<center><table border=0 width=100% summary="Oracle $SYSTEM_NAME $report_type Report Summary"><tr><td class="td_title" align="center">
 <h1>Oracle $SYSTEM_NAME $report_type Report<br><br>
EOF

if [[ $crh_total_points -gt "0" && `echo $components|grep -icw EXALOGIC_VM` -lt 1 && $print_score_in_report -ne 0 ]]
then 
  cat >> $HTML_REPFILE <<EOF
<span style="color:black;">System Health Score is $crh_health out of 100 <a style="color:black;" href="javascript:ShowHideRegion('shs_help');" title="What is this">(detail)</a> </span></h1>
<div id="shs_help" style="DISPLAY: none"><table border=0 summary="System Health Score formula"><tr><td align=left>System Health Score is derived using following formula.<ul>
<li>Every check has 10 points</li>
<li>Failure will deduct 10 points</li>
<li>Warning will deduct 5 points</li>
<li>Info will deduct 3 points</li></ul>
<table summary="PASS and FAIL statistics">
<tr><td>Total checks</td><td align=center>$G_TOTAL_CHECKS</td></tr>
<tr><td>Passed checks</td><td align=center>$crh_passed_checks</td></tr>
<tr><td>Failed(fail/warn/info) checks</td><td align=center>$crh_failed_checks</td></tr>
</table>
<a href="javascript:ShowHideRegion('shs_help');"> ..Hide</a>
</td></tr></table>
</div>
EOF

fi

if [[ -n "$RAT_OS" ]] ; then
  os_version_print="$RAT_OS"
else
  os_version_print="$upload_dbplatform $upload_osdistro $upload_osversion $upload_oskernel"
fi

cat >> $HTML_REPFILE <<EOF
</td></tr></table></center>
<H2>$summary_heading</H2>
<table border=1 summary="Cluster Summary" role="presentation">
$cname_link
<tr><td class="td_column">OS/Kernel Version</td><td>$os_version_print</td></tr>
$exalogic_version_link
$crs_hv_link
$dbhv_link
$obiee_homes_link
$cev_link
$tv_link
$node_slink
$node_dlink
$el_cs_row
$cells_link
$zfs_link
$ibs_link
$upg_link
$profile_link
<tr><td class="td_column">$program_name Version</td><td>$tool_version</td></tr>
<tr><td class="td_column">Collection</td><td>$collection_name</td></tr>
<tr><td class="td_column">Collection Date</td><td>$collection_date</td></tr>
</table>


EOF


if [[ -n "$print_pass_in_report" && $print_pass_in_report -eq "1" ]] ; then
cat >$HTML_PASS_FILE <<EOF
<hr>
<a class="a_bgw" href="#">Top</a>
<a name="passed_checks"></a>
<H2>Findings Passed</h2>

EOF
fi


  crh_cnt=${#G_CHECKIDS[@]}
  maa_id=0
  #echo "Total=$crh_cnt"
  while [ $crh_cnt -gt 0 ] 
  do
    let crh_cnt=$crh_cnt-1
    chk_status=$(echo ${G_CHECKID_STATUS[$crh_cnt]} | awk -F":" '{print $1}')

    # Display only $G_HOST_CNT hosts and display more link
    # When all hosts, then display All
    crh_hosts=""
    # The prefix for seprating reports from storage servers, compute nodes etc
    # It will be compute, cell, switch, cluster or system
    crh_rep_prefix=""
    crh_rep_ptext=""
    get_host_string_html

    # MAA
    is_maa=0
    if [ ! -z "${G_CHECKID_MAA_SF[$crh_cnt]}" ]
    then # Show in maa scorecard. Files will be SF_STATUS_
      # echo "${G_CHECKID_MAA_SF[$crh_cnt]}"
      is_maa=1
      if [ ${G_CHECKID_MAA_SF[$crh_cnt]} = "DBMACHINE X2-2 AND X2-8 AUDIT CHECKS" ] 
      then # some exadata sql checks should be updated manualy
        G_CHECKID_MAA_SF[$crh_cnt]="DATA CORRUPTION PREVENTION BEST PRACTICES"
      fi

      maa_msg=$(echo "${G_CHECKID_INFO[$crh_cnt]}" | tr "[a-z]" "[A-Z]")
      maa_sf_uc=$(echo ${G_CHECKID_MAA_SF[$crh_cnt]} |tr "[a-z]" "[A-Z]")
      maa_sfname=$(echo ${G_CHECKID_MAA_SF[$crh_cnt]} |  sed 's/[^a-zA-Z0-9]//g')
      if [ $maa_msg = $maa_sf_uc ] 
      then # The SF = MSG. dont display view.
        if [ ! -e "${OUTPUTDIR}/${maa_sfname}_TOP.html" ]
        then
          MAA_IDS[$maa_id]=$maa_sfname
          let maa_id=$maa_id+1
        fi
        CHECK_ID=${G_CHECKIDS[$crh_cnt]}
        LINKNUM=`grep -c _$CHECK_ID-LINK $REFFIL1`
        BEGPAT="_$CHECK_ID-BEGIN_COMMENTS"
        ENDPAT="_$CHECK_ID-END_COMMENTS"
        ONFAIL=`sed -n /$BEGPAT/,/$ENDPAT/p $REFFIL1 |sed s/$BEGPAT//g | sed s/$ENDPAT//g |sed 's/ / /g'`
        if [ $LINKNUM -gt 0 ]
        then
          unset G_LINKS
          for ((j=1;j<=$LINKNUM;j+=1));
          do
            LINK=`grep "_"$CHECK_ID"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
            append_links_html "INFO"
          done
          if [ ! -z "$G_LINKS" ] ; then
            ONFAIL="<b>Description</b><br>$ONFAIL<br><b>Best Practices</b><br><ul>$G_LINKS</ul>"
          fi
        fi

        echo "<tr><td colspan=6 scope=\"row\">.</td></tr>" > ${OUTPUTDIR}/${maa_sfname}_TOP.html
        echo "<tr><td valign=center rowspan=PLACEHOLDER_TO_REPLACE>${G_CHECKID_MAA_SF[$crh_cnt]}</td><td scope=\"row\">PLACEHOLDER_STATUS</td><td colspan=4><pre>$ONFAIL</pre></td></tr>" >> ${OUTPUTDIR}/${maa_sfname}_TOP.html
      else # Normal message
        maa_ofile="${maa_sfname}_${chk_status}_SF.html"
        if [ ! -e "${OUTPUTDIR}/$maa_ofile" ]
        then
          MAA_IDS[$maa_id]=$maa_sfname
          let maa_id=$maa_id+1
        fi
        echo "<tr><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('maasctbl_${crh_rep_prefix}', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/$maa_ofile
      fi
    fi

    if [[ $is_maa -eq "0" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -ge 1 ]]
    then # Passed check
      if [ ! -r "${OUTPUTDIR}/PASS_${crh_rep_prefix}.html" ]
      then # Write the header
        if [[ -n "$crh_rep_ptext_h" ]] ; then crh_rep_ptext=$crh_rep_ptext_h; fi;
        if [[ -n "$crh_rep_ptext_h" ]] ; then crh_rep_ptext=$crh_rep_ptext_h; fi;
        cat > ${OUTPUTDIR}/PASS_${crh_rep_prefix}.html <<EOF
           <a name="passed_checks_${crh_rep_prefix}"></a>
           <H2>$crh_rep_ptext</h2>
           <table border=1 id="passedtbl_${crh_rep_prefix}" summary="Passed checks">
           <tr><th scope="col">Status</th>
           <th scope="col">Type</th>
           <th scope="col">Message</th>
           <th scope="col">Status On</th>
           <th scope="col">Details</th></tr>
EOF
      fi
      echo "<tr><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('passedtbl_${crh_rep_prefix}', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> ${OUTPUTDIR}/PASS_${crh_rep_prefix}.html
    elif [ $is_maa -eq "0" ]
    then
      # Split the checks into different html files to sort the table based on severity
      if [[ $chk_status = "ERROR" || $chk_status = "FAIL" || $chk_status = "WARNING" || $chk_status = "INFO" ]]
      then
        crh_file_name="${OUTPUTDIR}/${chk_status}_${crh_rep_prefix}.html"
      else
        crh_file_name="${OUTPUTDIR}/OTHER_${crh_rep_prefix}.html"
      fi

      echo "<tr><td><input  id=\"deletebutton$g_tr_index\" type=\"button\" value=\"X\" onclick=\"deleteRow('failedtbl_${crh_rep_prefix}', this,'${G_CHECKIDS[$crh_cnt]}_contents')\"><a name=\"${G_CHECKIDS[$crh_cnt]}_summary\"></a>$chk_status</td><td>${G_CHECKID_TYPE[$crh_cnt]}</td><td scope=\"row\">${G_CHECKID_INFO[$crh_cnt]}</td><td>$crh_hosts</td><td><a href=\"#${G_CHECKIDS[$crh_cnt]}_details\">View</a></td></tr>" >> $crh_file_name
    fi
    let g_tr_index=$g_tr_index+1
  done

  # Append all MAA files
  maa_ids_cnt=$maa_id
  if [ $maa_id -gt 0 ]
  then
    maa_toc_entry="<li><a href=\"#maa_scorecard\">MAA Scorecard</a></li>"
    cat > $HTML_MAA_SC <<EOF
      <hr>
      <a href="#"  class="a_bgw">Top</a>
      <a name="maa_scorecard"></a>
      <H2>MAA Scorecard</h2>
           <table border=1 id="maasctbl_${crh_rep_prefix}" summary="MAA scorecard">
           <tr><th>Outage Type</th>
           <th scope="col">Status</th>
           <th scope="col">Type</th>
           <th scope="col">Message</th>
           <th scope="col">Status On</th>
           <th scope="col">Details</th></tr>
EOF

    # Hack to sort the MAA Scorecard 
    # 1) computer failure 
    # 2) storage failure
    # 3) data corruptions
    # 4) logical corruptions
    # 5) database/cluster/site failure
    # 6) network failures
    # 7) client failover
    # 8) operational practices
    # 9) Software maintainance best practices
    # 10) consolidation practices
    # We read array from end to start. So add entries in reverse order

    for maa_sf2 in "CONSOLIDATION DATABASE PRACTICES" "OPERATIONAL BEST PRACTICES" "CLIENT FAILOVER OPERATIONAL BEST PRACTICES" "NETWORK FAILURE PREVENTION BEST PRACTICES" "DATABASE/CLUSTER/SITE FAILURE PREVENTION BEST PRACTICES" "LOGICAL CORRUPTION PREVENTION BEST PRACTICES" "DATA CORRUPTION PREVENTION BEST PRACTICES" "STORAGE FAILURES PREVENTION BEST PRACTICES" "COMPUTER FAILURE PREVENTION BEST PRACTICES" "DATABASE FAILURE PREVENTION BEST PRACTICES" "SOFTWARE MAINTENANCE BEST PRACTICES"
    do
      maa_sfname2=$(echo $maa_sf2 |  sed 's/[^a-zA-Z0-9]//g')
      MAA_IDS[$maa_id]=$maa_sfname2
      let maa_id=$maa_id+1
    done

    # echo "maa_id = $maa_id"
    while [ $maa_id -ge 0 ]
    do
      maa_otstatus="INFO"
      if [ -e "${OUTPUTDIR}/${MAA_IDS[$maa_id]}_PASS_SF.html" ]
      then
        maa_otstatus="PASS"
      fi
      for crh_etype in ERROR FAIL WARNING INFO OTHER
      do
        maa_ofile="${OUTPUTDIR}/${MAA_IDS[$maa_id]}_${crh_etype}_SF.html"
        if [ -e "$maa_ofile" ]
        then
          maa_otstatus="FAIL"
        fi
      done

      maa_ofile="${OUTPUTDIR}/${MAA_IDS[$maa_id]}_TOP.html"
      if [ -e "$maa_ofile" ] 
      then
        if [ $maa_otstatus = "INFO" ]
        then # No other *_SF files exists
          maa_otcnt=0
        else
          maa_otcnt=$(wc -l ${OUTPUTDIR}/${MAA_IDS[$maa_id]}_*_SF.html| tail -1 | awk '{print $1}')
        fi
        let maa_otcnt=$maa_otcnt+1
        replace_command="sed 's/PLACEHOLDER_TO_REPLACE/${maa_otcnt}/'"
        replace_command_status="sed 's/PLACEHOLDER_STATUS/${maa_otstatus}/'"
        cat $maa_ofile | eval $replace_command | eval $replace_command_status >> $HTML_MAA_SC
        rm -f $maa_ofile
      fi
      for crh_etype in ERROR FAIL WARNING INFO OTHER PASS
      do
        maa_ofile="${OUTPUTDIR}/${MAA_IDS[$maa_id]}_${crh_etype}_SF.html"
        # echo "-- $maa_ofile"
        if [ -e "$maa_ofile" ] 
        then
          cat $maa_ofile >> $HTML_MAA_SC
          rm -f $maa_ofile
        fi
      done
      if [ `echo ${MAA_IDS[$maa_id]} | grep 'SOFTWAREMAINTENANCEBESTPRACTICES'| wc -l` -eq 1 ] 
      then
      	version_ofile="${OUTPUTDIR}/versions.html"
	if [ -e "$version_ofile" ]
	then
		cat $version_ofile >> $HTML_MAA_SC
		echo "" > $version_ofile
	fi
      fi
      let maa_id=$maa_id-1
    done
    echo "</table>" >> $HTML_MAA_SC
  fi

  # append all passed html reports to HTML_PASS_FILE
  crh_toc_pass_compute=""
  if [ -r "${OUTPUTDIR}/PASS_compute.html" ]
  then
    cat ${OUTPUTDIR}/PASS_compute.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_compute.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_compute="<li><a class=\"a_bgw\" href=\"#passed_checks_compute\">On $node_heading</a></li>"
  fi

  crh_toc_pass_cvserver=""
  if [ -r "${OUTPUTDIR}/PASS_cvserver.html" ]
  then
    cat ${OUTPUTDIR}/PASS_cvserver.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_cvserver.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_cvserver="<li><a class=\"a_bgw\" href=\"#passed_checks_cvserver\">On Control vServer</a></li>"
  fi

  crh_toc_pass_cell=""
  if [ -r "${OUTPUTDIR}/PASS_cell.html" ]
  then
    cat ${OUTPUTDIR}/PASS_cell.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_cell.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_cell="<li><a class=\"a_bgw\" href=\"#passed_checks_cell\">On Storage Server</a></li>"
  fi

  crh_toc_pass_zfscell=""
  if [ -r "${OUTPUTDIR}/PASS_zfscell.html" ]
  then
    cat ${OUTPUTDIR}/PASS_zfscell.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_zfscell.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_zfscell="<li><a class=\"a_bgw\" href=\"#passed_checks_zfscell\">On ZFS Storage Appliance</a></li>"
  fi

  crh_toc_pass_switch=""
  if [ -r "${OUTPUTDIR}/PASS_switch.html" ]
  then
    cat ${OUTPUTDIR}/PASS_switch.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_switch.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_switch="<li><a class=\"a_bgw\" href=\"#passed_checks_switch\">On Infiniband Switch</a></li>"
  fi

  crh_toc_pass_cluster=""
  if [ -r "${OUTPUTDIR}/PASS_cluster.html" ]
  then
    cat ${OUTPUTDIR}/PASS_cluster.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_cluster.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_cluster="<li><a class=\"a_bgw\" href=\"#passed_checks_cluster\">$html_rack_type Wide</a></li>"
  fi

  crh_toc_pass_system=""
  if [ -r "${OUTPUTDIR}/PASS_system.html" ]
  then
    cat ${OUTPUTDIR}/PASS_system.html >> $HTML_PASS_FILE
    rm -f ${OUTPUTDIR}/PASS_system.html
    echo "</table>" >> $HTML_PASS_FILE
    crh_toc_pass_system="<li><a class=\"a_bgw\" href=\"#passed_checks_system\">System Wide</a></li>"
  fi


  # Append the <errortype>.html to FAILED_<type>.html 
  for crh_ctype in compute cvserver cell zfscell switch cluster system
  do
    case  $crh_ctype in
         compute)
            crh_ctext="$node_heading"
            ;;
         cvserver)
            crh_ctext="Control vServer"
            ;;
         zfscell)
            crh_ctext="ZFS Storage Appliance"
            ;;
         cell)
            crh_ctext="Storage Server"
            ;;
         switch)
            crh_ctext="Infiniband Switch"
            ;;
         cluster)
            crh_ctext="$html_rack_type Wide"
            ;;
         system)
            crh_ctext="System Wide"
            ;;
         *)
            crh_ctext="$node_heading"
            ;;
    esac

    for crh_etype in ERROR FAIL WARNING INFO OTHER
    do
      crh_file_name="${OUTPUTDIR}/${crh_etype}_${crh_ctype}.html";
      if [ -e "${crh_file_name}" ]
      then
        if [ ! -r "${OUTPUTDIR}/FAILED_${crh_ctype}.html" ]
        then
          cat > ${OUTPUTDIR}/FAILED_${crh_ctype}.html <<EOF
             <a name="failed_checks_${crh_ctype}"></a>
             <H2>$crh_ctext</h2>
             <table border=1 id="failedtbl_${crh_ctype}" summary="Failed checks">
             <tr><th scope="col">Status</th>
             <th scope="col">Type</th>
             <th scope="col">Message</th>
             <th scope="col">Status On</th>
             <th scope="col">Details</th></tr>
EOF
        fi
        cat ${crh_file_name} >> ${OUTPUTDIR}/FAILED_${crh_ctype}.html
        rm -f ${crh_file_name}
      fi
    done
    if [ -r "${OUTPUTDIR}/FAILED_${crh_ctype}.html" ]
    then
      echo "</table>" >> ${OUTPUTDIR}/FAILED_${crh_ctype}.html
    fi
  done

  has_killed_procs=0
  has_skipped_checks=0
  has_skipped_nodes=0
  all_passed_text=" - All Checks Passed"
  if [[ -e "$OUTPUTDIR/watchdog.log" && `grep -iv "watcher" $OUTPUTDIR/watchdog.log |grep -ivc "candidate" | grep -v '^[0-9]*$' | grep -v '^[0-9]*-$' ` -gt 0 ]]
  then
    has_killed_procs=1
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]]
  then
    has_skipped_checks=1
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]] 
  then
    has_skipped_nodes=1
  fi
  # Added this to print a warning if user ran older version of tool or print how many days this is version good
  if [[ -n "$cdfYes" && $cdfYes -eq 1 ]]
  then
    echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:red;font-size:14px\">WARNING!</span> $oldVersionWarningMessage.</p></b>" >> $HTML_REPFILE
  else
    echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:green;font-size:14px\">Note!</span> This version of ${program_name} is considered valid for ${validVersionDays} days from today or until a new version is available</p></b>" >> $HTML_REPFILE
     
  fi
  if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
  then
    echo "<br/><br/><p><b>NOTE : </b>$program_name is only one part of the MAA Best Practices recommendation methodology. My Oracle Support \"Oracle Exadata Best Practices (Doc <a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=757552.1\" target=\"_blank\">ID757552.1</a>)\" should be reviewed thoroughly as it is the driver for exachk and contains additional operational and diagnostic guidance that is not programmed within $program_name.</p>" >> $HTML_REPFILE
  fi

  if [[ $has_killed_procs -eq "1" || $has_skipped_checks -eq "1" ]] ; then
    if [[ `uname -s` = "SunOS" || `uname -s` = "AIX" || `uname -s` = "HP-UX" ]] ; then
      tname=$(echo ${program_name} | sed -e 's/^./\E/g')
    else
      tname=$(echo ${program_name} | sed -e 's/^./\U&\E/g')
    fi
    
    echo "<br/><b><p style=\"font-size:14px\"><span style=\"color:red;font-size:14px\">WARNING!</span> The data collection activity appears to be incomplete for this ${program_name} run.  Please review the \"Killed Processes\" and / or \"Skipped Checks\" section and refer to \"Appendix A - Troubleshooting Scenarios\" of the \"${tname} User Guide\" for corrective actions.</p></b>" >> $HTML_REPFILE
    all_passed_text=" - No Checks reported but \"Killed Processes\" and / or \"Skipped Checks\" exist"
  fi

  # append all failed html reports to HTML_FAILED_FILE
  crh_toc_failed_compute=""
  if [ -r "${OUTPUTDIR}/FAILED_compute.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_compute.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_compute.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_compute="<li><a class=\"a_bgw\" href=\"#failed_checks_compute\">On $node_heading</a></li>"
  else
    crh_toc_failed_compute="<li>On $node_heading$all_passed_text</li>"
  fi

  crh_toc_failed_cvserver=""
  if [ -r "${OUTPUTDIR}/FAILED_cvserver.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_cvserver.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_cvserver.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_cvserver="<li><a class=\"a_bgw\" href=\"#failed_checks_cvserver\">On Control vServer</a></li>"
  elif [[ $in_ec_exalogic -eq "1" ]] ; then
    crh_toc_failed_cvserver="<li>On Control vServer$all_passed_text</li>"
  fi

  crh_toc_failed_cell=""
  if [ -r "${OUTPUTDIR}/FAILED_cell.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_cell.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_cell.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_cell="<li><a class=\"a_bgw\" href=\"#failed_checks_cell\">On Storage Server</a></li>"
  elif [[ -n "$cells_link" ]] ; then
    crh_toc_failed_cell="<li>On Storage Server$all_passed_text</li>"
  fi

  crh_toc_failed_zfscell=""
  if [ -r "${OUTPUTDIR}/FAILED_zfscell.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_zfscell.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_zfscell.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_zfscell="<li><a class=\"a_bgw\" href=\"#failed_checks_zfscell\">On ZFS Storage Appliance</a></li>"
  elif [[ -n "$zfs_link" ]] ; then
    crh_toc_failed_zfscell="<li>On ZFS Storage Appliance$all_passed_text</li>"
  fi

  crh_toc_failed_switch=""
  if [ -r "${OUTPUTDIR}/FAILED_switch.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_switch.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_switch.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_switch="<li><a class=\"a_bgw\" href=\"#failed_checks_switch\">On Infiniband Switch</a></li>"
  elif [[ -n "$ibs_link" ]] ; then
    crh_toc_failed_switch="<li>On Infiniband Switch$all_passed_text</li>"
  fi

  crh_toc_failed_cluster=""
  if [ -r "${OUTPUTDIR}/FAILED_cluster.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_cluster.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_cluster.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_cluster="<li><a class=\"a_bgw\" href=\"#failed_checks_cluster\">$html_rack_type Wide</a></li>"
  elif [[ -z "$is_exalogic_machine" ]] ; then
    crh_toc_failed_cluster="<li>$html_rack_type Wide$all_passed_text</li>"
  fi

  crh_toc_failed_system=""
  if [ -r "${OUTPUTDIR}/FAILED_system.html" ]
  then
    cat ${OUTPUTDIR}/FAILED_system.html >> $HTML_FAILED_FILE
    rm -f ${OUTPUTDIR}/FAILED_system.html
    echo "</table>" >> $HTML_FAILED_FILE
    crh_toc_failed_system="<li><a class=\"a_bgw\" href=\"#failed_checks_system\">System Wide</a></li>"
    #crh_toc_failed_system="<li>System Wide$all_passed_text</li>"
  fi
  
  pass_toc="<li><a href=\"#passed_checks\">Findings Passed</a></li>";
  if [[ -n "$print_pass_in_report" && $print_pass_in_report -eq "0" ]] 
  then 
    pass_toc=""
  fi

  cat >> $HTML_REPFILE <<EOF
<H2>Table of Contents</H2>

<ul>
<li><a class="a_bgw" href="#failed_checks">Findings Needing Attention</a></li>
<ul>
$crh_toc_failed_compute
$crh_toc_failed_cvserver
$crh_toc_failed_cell
$crh_toc_failed_zfscell
$crh_toc_failed_switch
$crh_toc_failed_cluster
$crh_toc_failed_system
</ul>
$maa_toc_entry
$pass_toc
<ul>
$crh_toc_pass_compute
$crh_toc_pass_cvserver
$crh_toc_pass_cell
$crh_toc_pass_zfscell
$crh_toc_pass_switch
$crh_toc_pass_cluster
$crh_toc_pass_system
</ul>
EOF

  patch_heading_prefix="GRID and";
  if [[ $single_instance_run -eq "1" ]] ; then
    patch_heading_prefix="";
  fi

  if [ -e "$OUTPUTDIR/patch_summary.html" ]
  then
    echo "<li><a href=\"#patch_summary\">$patch_heading_prefix RDBMS patch recommendation Summary report</a></li>" >> $HTML_REPFILE
  fi
  if [[ -e "$OUTPUTDIR/patch_detailed.html" ]]
  then
    echo "<li><a href=\"#patch_detailed\">$patch_heading_prefix RDBMS patch recommendation Detailed report</a></li>" >> $HTML_REPFILE
  fi

  if [ -e "$OUTPUTDIR/${program_name}_versions.html" ]
  then
    echo "<li><a href=\"#fs_versions\">Systemwide firmware and software versions</a></li>" >> $HTML_REPFILE
  fi
  if [[ -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ]]
  then
    echo "<li><a href=\"#fs_asrreport\">Systemwide Automatic Service Request (ASR) healthcheck</a></li>" >> $HTML_REPFILE
  fi
  if [[ -e "$OUTPUTDIR/watchdog.log" ]]; then
  if [[ `grep -ic "killing stuck command" $OUTPUTDIR/watchdog.log` -gt 0 || `grep -ic "timed out" $OUTPUTDIR/watchdog.log` -gt 0 ]]
  then
    echo "<li><a href=\"#killed_procs\">Killed Processes</a></li>" >> $HTML_REPFILE
  fi
  fi

  if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]] 
  then
    echo "<li><a href=\"#skipped_checks\">Skipped Checks</a></li>" >> $HTML_REPFILE
  fi
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]]
  then
    echo "<li><a href=\"#skipped_nodes\">Skipped Nodes</a></li>" >> $HTML_REPFILE
  fi


  cat >> $HTML_REPFILE <<EOF
</ul>
<br>
<a href="javascript:createDeleteButton(1);" id="show_edit_link">Remove finding from report</a>
<a href="javascript:createDeleteButton(0);" id="show_hide_link" style="DISPLAY: none">Hide Remove Buttons</a> 
<p id="message_on_hide" style="DISPLAY: none"><br><b><span style="color:red">Removing findings in page does not change the original html file. Please use browsers save page button (or press Ctrl+S) to save the report.</span></b></p>
<hr>
<a name="failed_checks"></a>
<H2>Findings Needing Attention</h2>
<p style="backrgound:white"><b>FAIL, WARNING, ERROR and INFO finding details should be reviewed in the
context of your environment.</b></br>
<br/><b>NOTE:</b> Any recommended change should be applied to and thoroughly tested (functionality and load) in one or more non-production environments before applying the change to a production environment.</p>
EOF

  # Append failed file to report
  if [ -e "$HTML_FAILED_FILE" ] 
  then
    cat $HTML_FAILED_FILE >> $HTML_REPFILE
    rm -f $HTML_FAILED_FILE
  fi

  if [ -e "$HTML_MAA_SC" ]
  then
    cat $HTML_MAA_SC >> $HTML_REPFILE
    rm -f $HTML_MAA_SC
  fi
  #for crh_ctype in compute cell switch cluster system
  #do
  #  crh_file_name="${OUTPUTDIR}/FAILED_${crh_ctype}.html";
  #  if [ -e "${crh_file_name}" ]
  #  then
  #    cat ${crh_file_name} >> $HTML_REPFILE
  #    rm -f ${crh_file_name}
  #  fi
  #done

  #append patch summary
  if [[ -e "$OUTPUTDIR/patch_summary.html" ]]
  then
    echo "<hr><a name=\"patch_summary\"></a><a href=\"#\"  class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>$patch_heading_prefix RDBMS patch recommendation Summary report</h2>" >> $HTML_REPFILE
    cat $OUTPUTDIR/patch_summary.html >> $HTML_REPFILE
    rm -f $OUTPUTDIR/patch_summary.html
  fi

  # append detailed patch report
  if [[ -e "$OUTPUTDIR/patch_detailed.html" ]]
  then
    echo "<hr><a name=\"patch_detailed\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>$patch_heading_prefix RDBMS patch recommendation Detailed report</h2>" >> $HTML_REPFILE
    cat $OUTPUTDIR/patch_detailed.html >> $HTML_REPFILE
    rm -f $OUTPUTDIR/patch_detailed.html
  fi

  # append passed checks report
  echo "</table>" >> $HTML_PASS_FILE
  cat $HTML_PASS_FILE >> $HTML_REPFILE
  rm -f $HTML_PASS_FILE

  # Now append the detailed description for each check
  echo "<hr><a href=\"#\" class=\"a_bgw\">Top</a><h2>Best Practices and Other Recommendations</h2>" >> $HTML_REPFILE
  echo "<p>Best Practices and Other Recommendations are generally items documented in various sources which could be overlooked. ${program_name} assesses them and calls attention to any findings.</p>" >> $HTML_REPFILE

  # replace the host names
  crh_cnt=${#G_CHECKIDS[@]}
  while [ $crh_cnt -gt 0 ] 
  do
    let crh_cnt=$crh_cnt-1
    #if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]] 
    if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" ]]
    then 
      crh_hosts=$(echo ${G_CHECKID_HOSTS[$crh_cnt]} | sed 's/\//\\\//g') # ORACLE_HOME will have / and below sed fails. So replace / with \/
      crh_hosts_passed=$(echo ${G_CHECKID_HOSTS_PASSED[$crh_cnt]} | sed 's/\//\\\//g') # ORACLE_HOME will have / and below sed fails. So replace / with \/
      if [[ `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]]
      then
        replace_command="sed 's/PLACEHOLDER_TO_REPLACE_FAIL/${crh_hosts}/'"
      else
        if [ -n "$crh_hosts_passed" ]
        then
          replace_command="sed 's/PLACEHOLDER_TO_REPLACE_PASS/${crh_hosts_passed}/'"
        else
          replace_command="sed 's/PLACEHOLDER_TO_REPLACE_PASS/${crh_hosts}/'"
        fi
      fi
      cat $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html | eval $replace_command > $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new
      mv $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
      if [[ -n "$crh_hosts_passed" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]]
      then # Partially failed on cells
        replace_command="sed 's/PLACEHOLDER_TO_REPLACE_PASS/${crh_hosts_passed}/'"
        cat $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html | eval $replace_command > $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new
        mv $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html.new $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
      fi
    fi
  done
  
  # Append each check-id.html to main report
  crh_cnt=${#G_CHECKIDS[@]}
  while [ $crh_cnt -gt 0 ] 
  do
    let crh_cnt=$crh_cnt-1

    if [ ! -z "${G_CHECKID_MAA_SF[$crh_cnt]}" ]
    then # MAA
      maa_msg=$(echo "${G_CHECKID_INFO[$crh_cnt]}" | tr "[a-z]" "[A-Z]")
      maa_sf_uc=$(echo ${G_CHECKID_MAA_SF[$crh_cnt]} |tr "[a-z]" "[A-Z]")
      if [ $maa_msg = $maa_sf_uc ]
      then # The SF = MSG. dont display detailed as its a dummy check.
        rm -f $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
      fi
    fi

    #if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" && `echo ${G_CHECKID_STATUS[$crh_cnt]} | grep -ic "PASS"` -eq "0" ]] 
    if [[ -e "$OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html" ]]
    then # No html details for passed checks
      echo "<div id=\"${G_CHECKIDS[$crh_cnt]}_contents\">" >> $HTML_REPFILE
      replace_command="sed 's/PLACEHOLDER_TO_REPLACE_..../-/'"
      cat $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html | eval $replace_command >> $HTML_REPFILE
      # Add a top link at bottom also
      echo "<a href=\"#${G_CHECKIDS[$crh_cnt]}_summary\" class=\"a_bgw\">Top</a><br>" >>$HTML_REPFILE
      echo "</div>" >> $HTML_REPFILE
      rm -f $OUTPUTDIR/${G_CHECKIDS[$crh_cnt]}.html
    fi
  done
  
  # append exadata version report if available.
  #if [[ $OFFLINE -eq 0 &&  -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 ]]
  if [ -e "$OUTPUTDIR/${program_name}_versions.html" ]
  then
    echo "<hr><a name=\"fs_versions\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_versions.html | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $HTML_REPFILE
  fi
  # append Exadata ASR healthcheck report if available.
  if [ -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ]
  then
    echo "<hr><a name=\"fs_asrreport\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_${ASREXACHK}.html | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $HTML_REPFILE
  fi

  # Append info about killed processes
  #if [[ -e "$OUTPUTDIR/watchdog.log" && `grep -iv "watcher" $OUTPUTDIR/watchdog.log |grep -ivc "candidate" | grep -v '^[0-9]*$' | grep -v '^[0-9]*-$' ` -gt 0 ]]
  if [[ -e "$OUTPUTDIR/watchdog.log" ]] ; then
  if [[ `grep -ic "killing stuck command" $OUTPUTDIR/watchdog.log` -gt 0 || `grep -ic "timed out" $OUTPUTDIR/watchdog.log` -gt 0 ]]
  then
    echo "<hr><a name=\"killed_procs\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Killed Processes</h2>" >> $HTML_REPFILE
    echo "<p>${program_name} found that below commands were killed during the run, so some checks might have failed to execute properly. Refer to the troubleshooting section of the user guide to resolve the issues.</p>" >> $HTML_REPFILE
    echo "<pre>" >> $HTML_REPFILE
    grep -iv "watcher" $OUTPUTDIR/watchdog.log |grep -iv "candidate" | grep -v '^[0-9]*$' | grep -v '^[0-9]*-$' |grep -v "LOG FROM" >> $HTML_REPFILE
    echo "</pre>" >> $HTML_REPFILE
  fi
  fi

  # append skipped checks
  if [ -e $OUTPUTDIR/${program_name}_skipped_checks.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_checks.log|wc -l` -gt $skipped_checks_pass || `cat $OUTPUTDIR/${program_name}_skipped_checks.log|grep -ic "A4C28178C200A9CBE040E50A1EC00952"` -ge 1 ]] 
  then
    echo "<hr><a name=\"skipped_checks\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Skipped Checks</h2>" >> $HTML_REPFILE
    echo "<pre>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_skipped_checks.log >> $HTML_REPFILE
    echo "</pre>" >> $HTML_REPFILE
  fi

  # append skipped nodes
  if [ -e $OUTPUTDIR/${program_name}_skipped_nodes.log  ] && [[ `cat $OUTPUTDIR/${program_name}_skipped_nodes.log|wc -l` -gt 0 ]]
  then
    echo "<hr><a name=\"skipped_nodes\"></a><a href=\"#\" class=\"a_bgw\">Top</a>" >> $HTML_REPFILE
    echo "<h2>Skipped Nodes</h2>" >> $HTML_REPFILE
    echo "<pre>" >> $HTML_REPFILE
    cat $OUTPUTDIR/${program_name}_skipped_nodes.log >> $HTML_REPFILE
    echo "</table></pre>" >> $HTML_REPFILE
  fi

  echo "<div id=\"checkscnt\" style=\"display: none\">$g_tr_index</div>" >> $HTML_REPFILE
  cat >> $HTML_REPFILE <<EOF
    <script>
      var k=getParam('debug');
      createDeleteButton(k);
    </script>
EOF
  echo "</body></html>" >> $HTML_REPFILE
}

# Prints the Clusterware patches summary report table.
print_cluster_patch_summary_html ()
{
  if [[ $single_instance_run -eq "1" ]] ; then return; fi;
  cat >> $OUTPUTDIR/patch_summary.html <<EOF
    <a name="${i}_crssummary"></a>
    <h3>Summary Report for "$i"</h3>
    <b>Clusterware patches</b>
    <table border=1 summary="Clusterware patches">
    <tr><th>Total patches</th>
    <th scope="col">Applied on CRS</th>
    <th scope="col">Applied on RDBMS</th>
    <th scope="col">Applied on ASM</th>
    <th scope="col">Details</th></tr>
    <tr><td align="right" scope="row">$PCW_NUM</td>
    <td align="right">$pp_crs_pcount</td>
    <td align="right">$pp_rdbms_pcount</td>
    <td align="right">$pp_asm_pcount</td>
    <td align="center"><a href="#${i}_crsdetailed">View</a></td>
    </tr></table>
EOF

}

# Print heading for each host. Can't use print_crs_patch_detail_html as its called
# only if there are patchs
print_crs_patch_detail_heading_html ()
{
  if [[ $single_instance_run -eq "1" ]] ; then return; fi;
  echo "<h3>Detailed report for \"${fmt_hname}\"</h3><hr>" >> $OUTPUTDIR/patch_detailed.html
}

# Prints the Clusterware patches detailed table.
print_crs_patch_detail_html ()
{
  if [[ $single_instance_run -eq "1" ]] ; then return; fi;
  if [ $crs_patch_printed_html -eq "0" ] 
  then
    crs_patch_printed_html=1
    pcp_hostname=$(echo ${stack_crs_version[$stack_counter]}|sed 's/\.//g')
    cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <a name="${fmt_hname}_crsdetailed"></a>
      <br><br><b>$PCW_NUM Recommended CRS patches for $pcp_hostname from ${CRS}</b>
EOF

    if [ $PCW_NUM -gt 0 ]
    then
      cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <table border=1 summary="Detailed CRS patches">
      <tr><th scope="col">Patch#</th>
      <th scope="col">CRS</th>
      <th scope="col">ASM</th>
      <th scope="col">RDBMS</th>
      <th scope="col">RDBMS_HOME</th>
      <th scope="col">Patch-Description</th></tr>
EOF
    else
      echo "<br>" >> $OUTPUTDIR/patch_detailed.html
    fi
  fi
  if [ $PCW_NUM -gt 0 ]
  then
    if [[ -n "$fmt_crs_applied" && $fmt_crs_applied = "yes" ]] ; then
      fmt_crs_applied_p="applied"
    else
      fmt_crs_applied_p="not-applied"
    fi
    if [[ -n "$fmt_asm_applied" && $fmt_asm_applied = "yes" ]] ; then
      fmt_asm_applied_p="applied"
    else
      fmt_asm_applied_p="not-applied"
    fi
    if [[ -n "$fmt_rdbms_applied" && $fmt_rdbms_applied = "yes" ]] ; then
      fmt_rdbms_applied_p="applied"
    else
      fmt_rdbms_applied_p="not-applied"
    fi
    if [[ -n "$crs112" && $crs112 -ge 1 ]]
    then # No seperate asm home in 11.2
      fmt_asm_applied_p="n/a"
    fi
    if [[ -z "$ASM_HOME" ]] ; then
      fmt_asm_applied_p="n/a"
    fi

    echo "<tr><td>$PATCH</td><td>$fmt_crs_applied_p</td><td>$fmt_asm_applied_p</td><td>$fmt_rdbms_applied_p</td><td>$fmt_patch_type</td><td>$SUBJ</td></tr>" >> $OUTPUTDIR/patch_detailed.html
    if [ $j -eq $PCW_NUM ]
    then
      echo "</table><a href=\"#${fmt_hname}_crssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
    fi
  else
    echo "<a href=\"#${fmt_hname}_crssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
  fi
}

# Print the rdbms patch summary report table.
# As we may have more oracle home's, print headings only when mb_db_counter=0
# else just print the row. At the end print </table>, 
# i.e when $mb_db_counter = ${#mb_oracle_homes_distinct[@]}
print_rdbms_patch_summary_html ()
{
  pr_print=$1
  if [ $mb_db_counter_printed -eq "0" ]
  then # Its first time 
    mb_db_counter_printed=1
    cat >> $OUTPUTDIR/patch_summary.html <<EOF
      <br><b>RDBMS homes patches</b>
      <table border=1 summary="RDBMS homes patches">
      <tr><th scope="col">Total patches</th>
      <th scope="col">Applied on RDBMS</th>
      <th scope="col">Applied on ASM</th>
      <th scope="col">ORACLE_HOME</th>
      <th scope="col">Details</th></tr>
EOF
  fi
  
  if [[ -n "$pr_print" && "$pr_print" = "1" ]]
  then
    prp_ohome=$(echo "${i}_${mb_db_homes}" | sed 's/\///g')
    cat >> $OUTPUTDIR/patch_summary.html <<EOF
      <tr><td align="right" scope="row"><a name="${prp_ohome}_rdbmssummary"></a>${mb_non_pcw_num[$mb_db_counter]}</td>
      <td align="right">${mb_rp_rdbms_pcount[$mb_db_counter]}</td>
      <td align="right">${mb_rp_asm_pcount[$mb_db_counter]}</td>
      <td align="right">$mb_db_homes</td>
      <td align="center"><a href="#${prp_ohome}_rdbmsdetailed">View</a></td></tr>
EOF
  fi

  let prp_index=$mb_db_counter+1
  if [ $prp_index -eq ${#mb_oracle_homes_distinct[@]} ]
  then # No more rows
    echo "</table>" >> $OUTPUTDIR/patch_summary.html
  fi
}

# Print detailed patch report for every oracle_home
print_rdbms_patch_detailed_html ()
{
  if [ $printed_rdbms_patch_html -eq "0" ]
  then
    printed_rdbms_patch_html=1;
    prp_ohome=$(echo "${i}_${mb_oracle_homes_distinct[$mb_db_counter]}" | sed 's/\///g')
    cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <a name="${prp_ohome}_rdbmsdetailed"></a>
      <br><br><b>$NON_PCW_NUM Recommended RDBMS patches for ${rdbms_home_version} from ${mb_oracle_homes_distinct[$mb_db_counter]}</b>
EOF
    if [ "$NON_PCW_NUM" -gt 0 ]
    then
      cat >> $OUTPUTDIR/patch_detailed.html <<EOF
      <table border=1 summary="Detailed rdbms home patches">
      <tr><th>Patch#</th>
      <th scope="col">RDBMS</th>
      <th scope="col">ASM</th>
      <th scope="col">Type</th>
      <th scope="col">Patch-Description</th></tr>
EOF
    else
      echo "<br>" >> $OUTPUTDIR/patch_detailed.html
    fi
  fi
  if [ "$NON_PCW_NUM" -gt 0 ]
  then
    if [[ -n "$2" && $2 = "yes" ]] ; then
      fmt_rdbms_applied_p="applied"
    else
      fmt_rdbms_applied_p="not-applied"
    fi
    if [[ -n "$3" && $3 = "yes" ]] ; then
      fmt_asm_applied_p="applied"
    else
      fmt_asm_applied_p="not-applied"
    fi
    if [[ -n "$crs112" && $crs112 -ge 1 ]] 
    then # No seperate asm home in 11.2
      fmt_asm_applied_p="n/a"
    fi
    if [[ -z "$ASM_HOME" ]] ; then
      fmt_asm_applied_p="n/a"
    fi
    echo "<tr><td>$1</td><td>$fmt_rdbms_applied_p</td><td>$fmt_asm_applied_p</td><td>$4</td><td>$SUBJ</td></tr>" >> $OUTPUTDIR/patch_detailed.html
    if [ $j -eq $NON_PCW_NUM ]
    then
      echo "</table>" >> $OUTPUTDIR/patch_detailed.html
      if [[ -f $napply_missing_list  ]]
      then
        echo "<pre>" >> $OUTPUTDIR/patch_detailed.html
        cat $napply_missing_list >> $OUTPUTDIR/patch_detailed.html
        echo "</pre>" >> $OUTPUTDIR/patch_detailed.html
      fi
      echo "<a href=\"#${prp_ohome}_rdbmssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
    fi
  else
    echo "<a href=\"#${prp_ohome}_rdbmssummary\" class=\"a_bgw\">Top</a>" >> $OUTPUTDIR/patch_detailed.html
  fi
}
#-- End writing html reports

function assign_scr_switches ()
{
  crs_version_switch="crs activeversion"
  #if [ `uname -s` = "HP-UX" ] ; then
  #  crs_version_switch="has releaseversion"
  #fi
  bash_scr="/bin/env bash"
  bash_path=""
  if [[ ! -f "/bin/bash" || ! -f "/bin/env" ]] ; then
    bash_scr=$(which bash)
  fi
  if [[ ! -f "/bin/bash" ]] ; then
    bash_path=$(dirname $bash_scr)
  fi
#read -p "bash_scr = $bash_scr and bash_path=$bash_path" somevar
  #bash_scr="/bin/bash -xv";
  bash_source="if [ -e \"/etc/profile\" ] ; then . /etc/profile >/dev/null 2>&1; fi; if [ -e \"\$HOME/.bash_profile\" ] ; then . \$HOME/.bash_profile >/dev/null 2>&1; elif [ -e \"\$HOME/.bash_login\" ] ; then . \$HOME/.bash_login >/dev/null 2>&1; elif [ -e \"\$HOME/.profile\" ] ; then . \$HOME/.profile >/dev/null 2>&1; fi;set +u"
   
}

log_fail ()
{

   #we should never end up in here when in SILENT mode
   #pass/fail is not a concept for SILENT mode
   if [ $SILENT -eq "1" ]
   then
     echo "DEBUG MESSAGE - log_fail() should not be called in SILENT mode".|tee -a $LOGFIL >/dev/null
   fi

   if [[ $ISBRANCH -eq 1 && $SILENT -eq 0 ]]
   then
     echo "BRANCH CONDITION FALSE" >>$LOGFIL
   elif [[ $ISBRANCH -ne 1 && $SILENT -eq 0 ]]
   then
     # gadiga for SHS
     case "$ALVL" in
      "FAIL")
            let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
            ;;
      "WARNING")
            let G_WARN_CHECKS=$G_WARN_CHECKS+1
            ;;
      "INFO")
            let G_INFO_CHECKS=$G_INFO_CHECKS+1
            ;;
      *)
            let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
            ;;
    esac
    let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1
    # end code for SHS

     echo "" >>$LOGFIL
     if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
     then
         echo "" >>$CELLREPFIL_FAIL
     elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
     then
          echo "" >>$IBREPFIL_FAIL
     else
         echo "" >>$REPFIL_FAIL
     fi
     #ACREPCOUNT=`expr $ACREPCOUNT + 1`
     #echo "------------------------------" >>$LOGFIL
     #echo "------------------------------" >>$REPFIL
     #read -p "ACREPCOUNT1=$ACREPCOUNT1"
     echo  "Check:- $ALVL => $FMSG" >>$LOGFIL
      
     if [ $CREATE_HTML_REPORT -eq 1 ]
     then # gadiga
       init_arrays_html "FAIL"
     fi

     if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
     then 
         echo  "Check:- $ALVL => $FMSG" >>$CWCREPFIL_FAIL
         echo  "Check:- $ALVL => $FMSG" >>$SCWCREPFIL_FAIL
     else  
         if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
         then
              echo "" >>$CELLREPFIL_FAIL
              echo "Check:- $ALVL => $FMSG" >>$CELLREPFIL_FAIL
              echo "Check:- $ALVL => $FMSG" >>$CELLSREPFIL_FAIL
          elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
          then
              echo "" >>$IBREPFIL_FAIL
              echo "Check:- $ALVL => $FMSG" >>$IBREPFIL_FAIL
              echo "Check:- $ALVL => $FMSG" >>$IBSREPFIL_FAIL
          else
              echo "" >>$REPFIL_FAIL
              echo "Check:- $ALVL => $FMSG" >>$REPFIL_FAIL
              echo "Check:- $ALVL => $FMSG" >>$SREPFIL_FAIL
          fi 
     fi
     if [ $COMTYPE = "OS_PACKAGE" ]
     then
         echo  "Audit check # $ACREPCOUNT@RPM Version Check@$actual@$PARAM_PATH@$ALVL=>$FMSG@$rpm_status@$rpm_arch">>$OSCHECKRESULT
     else        
         if [ -z "$audit_check_name" ]
         then
             audit_check_name=$COM
         fi
         echo  "Audit check # $ACREPCOUNT@$audit_check_name@$VAL@$COMP@$ALVL=>$FMSG">>$OSCHECKRESULT
     fi
     #audit_check_name=""
     #echo "------------------------------" >>$LOGFIL
     #echo "------------------------------" >>$REPFIL
     echo "" >>$LOGFIL
     if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
     then
         echo "" >>$CELLREPFIL_FAIL
     elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
     then
          echo "" >>$IBREPFIL_FAIL
     else 
         echo "" >>$REPFIL_FAIL
     fi

     #echo "DEBUG - ALERT_LEVEL = $ALVL"
     #read -p "stop"

     if [[ $ALVL = "WARNING" && $ISBRANCH -eq 0 ]]
     then
         echo -e "$ORANGE $ALVL =>$NORM $FMSG"
     elif [[ $ALVL = "FAIL" && $ISBRANCH -eq 0 ]]
     then
         echo -e "$RED $ALVL =>$NORM    $FMSG"
     elif [[ $ALVL = "INFO" && $ISBRANCH -eq 0 ]]
     then 
         echo -e "$BLUE $ALVL =>$NORM    $FMSG"
     elif [[ $ALVL = "ERROR" && $ISBRANCH -eq 0 ]]
     then
         echo -e "$RED $ALVL =>$NORM    $FMSG"
     fi
     generate_result_xml "FAIL"     
     #follwoing if is not to print anything in report for for package from appendix
     if [ $COMTYPE != "OS_PACKAGE-DISABLED" ]
     then
         #grab the details from the appendix
         LINKNUM=0
         LINK=
         if [ $op_mode -eq 0 ]
         then
             LINKNUM=`grep -c _$ROW-LINK $REFFIL1`
             BEGPAT="_$ROW-BEGIN_COMMENTS"
             ENDPAT="_$ROW-END_COMMENTS"
         else
             if [ $COMTYPE = "CLUSTERWIDE_CHECK" ]
             then
                CHECK_ID=${crs_check_id[$crs_check_file_counter]} 
             fi 
             LINKNUM=`grep -c _$CHECK_ID-LINK $REFFIL1`
             BEGPAT="_$CHECK_ID-BEGIN_COMMENTS"
             ENDPAT="_$CHECK_ID-END_COMMENTS"
         fi
         ONFAIL=`sed -n /$BEGPAT/,/$ENDPAT/p $REFFIL1 |sed s/$BEGPAT//g | sed s/$ENDPAT//g |sed 's/ / /g'`
         #Added this line to add pass/fail message as rational if its ORACLE_PATH and ratinoal is empty
         if [[ "$COMTYPE" = "ORACLE_PATCH" && `echo $ONFAIL|sed '/^$/d'|wc -l` -eq 0 ]];then ONFAIL=$FMSG;fi
  
         case  $OP in
         -eq)
            rep_op="="
           ;;
         -ne)
            rep_op="!="
          ;;
         -ge)
            rep_op=">="
          ;;
         -gt)
            rep_op=">"
          ;;
         -lt)
            rep_op="<"
          ;;
         -le)
            rep_op="<="
          ;;
          *)
           rep_op=$OP
          ;;
         esac 
          #echo "LINKNUM = $LINKNUM"
           #echo "$ROW LINKNUM = $LINKNUM" >>$REPFIL
           #if [ -n "$LINK" ]
            #then
          #  echo "" >>$LOGFIL
          #  echo "" >>$REPFIL
          #fi
          #echo "COMMENTS - $ONFAIL" >>$LOGFIL
          #echo " Additional information to resolve above problem ">>$LOGFIL
         #echo "$ONFAIL" >>$LOGFIL
         if [[  $COMTYPE = "CLUSTERWIDE_CHECK" && -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
         then
             echo "Additional information to resolve above problem">>$CWCREPFIL_FAIL
	     echo "-----------------------------------------------">>$CWCREPFIL_FAIL
	     if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]]; then echo -e "Success factor name = $SF \n">>$CWCREPFIL_FAIL;fi
	     #echo -e "Recommended value is  \"$COMP\", Comparision operator is \"$rep_op\"  and Actual found on system is  \"$VAL\" \n">>$REPFIL
	     echo "$ONFAIL" >>$CWCREPFIL_FAIL
             if [[ -e $SOURCEFIL_REPORT ]]
             then
                 echo -e "TO REVIEW COLLECTED DATA :- ${SOURCEFIL_REPORT_NEW}\n">>$CWCREPFIL_FAIL
             fi
             unset SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW
         elif [[ -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
         then
             if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
             then
	         echo "Additional information to resolve above problem">>$CELLREPFIL_FAIL
	         echo "-----------------------------------------------">>$CELLREPFIL_FAIL
	         if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]];then echo -e "Success factor name = $SF \n">>$CELLREPFIL_FAIL;fi
	         echo "$ONFAIL" >>$CELLREPFIL_FAIL
                 if  [ -e $SOURCEFIL_REPORT ]
                 then
                     echo -e "TO REVIEW COLLECTED DATA FROM $(echo $cellname|tr "[a-z]" "[A-Z]") :- ${SOURCEFIL_REPORT_NEW}\n">>$CELLREPFIL_FAIL
                 fi
             elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
             then 
                 echo "Additional information to resolve above problem">>$IBREPFIL_FAIL
                 echo "-----------------------------------------------">>$IBREPFIL_FAIL
                 if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]];then echo -e "Success factor name = $SF \n">>$IBREPFIL_FAIL;fi
                 echo "$ONFAIL" >>$IBREPFIL_FAIL
                 if [ -e $SOURCEFIL_REPORT ]
                 then
                     echo -e "TO REVIEW COLLECTED DATA FROM $(echo $switchname|tr "[a-z]" "[A-Z]") :- ${SOURCEFIL_REPORT_NEW}\n">>$IBREPFIL_FAIL
                 fi 
             else
                 echo "Additional information to resolve above problem">>$REPFIL_FAIL
                 echo "-----------------------------------------------">>$REPFIL_FAIL
                 if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]];then echo -e "Success factor name = $SF \n">>$REPFIL_FAIL;fi
                 echo "$ONFAIL" >>$REPFIL_FAIL
                 if [[ -e $SOURCEFIL_REPORT ]]
                 then
                         echo -e "TO REVIEW COLLECTED DATA :- ${SOURCEFIL_REPORT_NEW}\n">>$REPFIL_FAIL
                 fi 
             fi
             unset SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW
         fi
         if [ $LINKNUM -gt 0 ]
         then
            #echo "$ROW LINKNUM = $LINKNUM" >>$REPFIL
            for ((j=1;j<=$LINKNUM;j+=1));
            do
              #echo "j=$j, ROW=$ROW" >>$REPFIL
              if [ $op_mode -eq 0 ]
              then
                  LINK=`grep "_"$ROW"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
              else
                  LINK=`grep "_"$CHECK_ID"-LINK"$j" " $REFFIL1 |sed  -n 's/.*-LINK//p'`
              fi
              if [ $CREATE_HTML_REPORT -eq 1 ]
              then
                append_links_html "$ALVL"
              fi
              if [[  $COMTYPE = "CLUSTERWIDE_CHECK" && -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
              then 
                  echo "  $LINK" >>$CWCREPFIL_FAIL;
              elif [[ -n "$write_report_on_fail" && $write_report_on_fail -eq 1 ]]
              then 
                  if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
                  then
                      echo "  $LINK" >>$CELLREPFIL_FAIL; 
                  elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]]
                  then
                      echo "  $LINK" >>$IBREPFIL_FAIL; 
                  else
                      echo "  $LINK" >>$REPFIL_FAIL; 
                  fi
              fi
            done
         fi
         if [ $CREATE_HTML_REPORT -eq 1 ]
         then # gadiga - for html reports
           create_checkid_html $ALVL
           write_output_to_html $ALVL
         fi
     else
         if [[ -e $SOURCEFIL_REPORT ]]
         then
             echo -e "TO REVIEW COLLECTED DATA :- ${SOURCEFIL_REPORT_NEW}\n">>$REPFIL_FAIL
         fi
         if [ $CREATE_HTML_REPORT -eq 1 ]
         then  # gadiga - for html reports
           write_output_to_html $ALVL
         fi
         unset SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW
     fi # end if not to print in report file for OS_PACAKGE
     echo -e "CHECK ID = $CHECK_ID \nAUDIT CHECK NAME = $audit_check_name\n">>$LOGFIL
     echo "---------------------------------------------" >>$LOGFIL
     if [  $COMTYPE = "CLUSTERWIDE_CHECK" ]
     then
         echo "">>$CWCREPFIL_FAIL
         echo "">>$CWCREPFIL_FAIL
     else
         if [[ $COMTYPE = "OS_OUT_CHECK" || $COMTYPE = "OS" ]] && [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
         then
             echo "" >>$CELLREPFIL_FAIL
             echo "" >>$CELLREPFIL_FAIL
         elif [[ $COMTYPE = "OS_OUT_CHECK" ]] && [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH"  ]] 
         then
            echo "" >>$IBREPFIL_FAIL
            echo "" >>$IBREPFIL_FAIL
         else
             echo "">>$REPFIL_FAIL
             echo "">>$REPFIL_FAIL
         fi
     fi
   fi
   #echo "---------------------------------------------" >>$LOGFIL


   case $COMTYPE in
   SQL|SQL_PARAM)
     #echo ""
     ;;
   OS|OS_PARAM)
     SQL1=`echo "$SQL'$PARAM_PATH' ,'$OP $COMP','$VAL');"`
     #this loop is a hack to eliminate error for missing comma
     #in the sql statements that are output which contain strings
     #like 'print $1', these need double single quotes
     #this will handle up to |awk {'print $5'}, more than that
     #and we would need to increase the number of loops
     for ((s=1;s<=5;s+=1));
     do
       SQL1=${SQL1/\{print \$$s\}/\'\{print \$$s\}\'}
       #echo "SQL1 = $SQL1"
     done

   #set failure flag
     ;;
    *)
     echo "Unexpected argument log_result [1] = $TYPE" >>$UPDATEFIL
     ;;
   esac
}

get_log_result ()
{

  cmd_type=$1 # Populate m_opstat
  cmd_value=$2 # db name or ohome
#$1 = SQL or OS, what type of command is being processed
#$2 = whether to print the SF (1 - for standalone SF or root branch) or branch step (0) info
#$3 = the number of the current step within a branch
#$4 = the total number of steps in the branch
#   echo "TYPE = $TYPE" >>$LOGFIL
#added to remove space before and after from value returned by command 
   VAL=$(echo $VAL|tr -d ' ')
   #To add correct audit_check_name in log file and fix bug 14514471, added this one following line
   if [ -z "$audit_check_name" ]; then audit_check_name=$PARAM_PATH;fi
   echo "" >>$LOGFIL
   if [[ $ISBRANCH -eq 1 && $COMTYPE = OS ]]
   then
     echo "HOST $i BRANCH $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS ]]
   then
     echo "HOST $i STEP $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 1 && $COMTYPE = SQL ]]
   then
     echo "SQL BRANCH $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 0 && $COMTYPE = SQL ]]
   then
     echo "SQL STEP $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 1 && $COMTYPE = OS_PARAM ]]
   then
     echo "HOST $i BRANCH $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS_PARAM ]]
   then
     echo "HOST $i STEP $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 1 && $COMTYPE = OS_PACKAGE ]]
   then
     echo "HOST $i BRANCH $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS_PACKAGE ]]
   then
     echo "HOST $i STEP $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 1 && $COMTYPE = SQL_PARAM ]]
   then
     echo "SQL BRANCH $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 0 && $COMTYPE = SQL_PARAM ]]
   then
     echo "SQL STEP $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 0 && $COMTYPE = SQL_COLLECT ]]
   then
     echo "SQL DATA COLLECTION $ROW" >>$LOGFIL
   elif [[ $ISBRANCH -eq 0 && $COMTYPE = OS_COLLECT ]]
   then
     echo "OS DATA COLLECTION $ROW" >>$LOGFIL
   fi

   if [[ $LEVEL -eq "1" && $SILENT -eq "0" ]]
   then
     if [[ $COMTYPE != "OS_COLLECT" && $COMTYPE != "SQL_COLLECT" ]]
     then
         #only want the verbose output for root level checks
         #everything in the hierarchy below that is referring
         #to the original check
         echo "  SF = $SF" >>$LOGFIL
         echo "  CATEGORY = $CAT" >>$LOGFIL
         echo "  SUBCATEGORY = $SUBCAT" >>$LOGFIL
         echo "  IS_BRANCH = $ISBRANCH" >>$LOGFIL 
     fi
   fi
   echo "  PARAMETER OR PATH = $PARAM_PATH" >>$LOGFIL
   echo "  COMMAND = $COM" >>$LOGFIL
   echo "AUDIT_CHECK_COMPONENTS = $check_components" >>$LOGFIL
   echo "AUDIT_CHECK_ID = $CHECK_ID" >>$LOGFIL
   if [[ $COMTYPE != "OS_COLLECT" && $COMTYPE != "SQL_COLLECT" ]]
   then
     echo "  COMMAND RESULT = $VAL" >>$LOGFIL
   fi
   if [ $SILENT -eq "0" ]
   then
     echo "  OPERATOR = $OP" >>$LOGFIL
     echo "  COMPARISON VALUE = $COMP" >>$LOGFIL
   fi
   echo "" >>$LOGFIL
  #code to print audit check number in report file 
   sql_collect=$(grep -c  "SQL_COLLECT_COMMAND" $REFFIL)
   os_collect=$(grep -c  "OS_COLLECT_COMMAND" $REFFIL)
   sql_os_collect=$(expr $sql_collect + $os_collect)
   curr_row_number=$(echo $ROW|cut -d. -f1)
   ACREPCOUNT=$(expr $curr_row_number - $sql_os_collect)
#  echo "ROW number is $ROW">/dev/null
 case $OP in
  -z|-f|-d|-n|"! -f"|"! -d")
   #we should never come in here if in SILENT mode
   #we will have no comparison operator if that is the case
   #SO nothing to do here if in SILENT mode
   #
#   echo "DEBUG: This should be correct - $COMP"

   #this handles -n and -z type operators where there is no comparison value
   #$VAL is either empty or non-empty, non-empty = TRUE, EM{TY = FALSE
   #This should never be the case for OS_COLLECT or SQL_COLLECT
   case $COMTYPE in
   SQL_PARAM)
     #echo "VAL=$VAL  for $PARAM_PATH"
     if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_conter]} -ne 0 ]]
     then 
        VAL=$(echo $VAL|tr "[a-z]" "[A-Z]")
        if [ "$OP" "$VAL" ]
        then
           if [[ $execute_once -eq 1 && $i != $localnode ]]
           then
              execute_once_sql_param=0
           elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
           then
              execute_once_sql_param=0
           else
              execute_once_sql_param=1
              OPSTAT=1
              log_pass
           fi
        else
           OPSTAT=0
           echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
           log_fail
        fi
        if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
        if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
        if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
            echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
            echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        fi
        if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]] 
        then
            if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
            if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	    if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
            echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}');">>$upload_raccheck_result_fil
        fi
     elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
     then 
        VAL=$(echo $VAL|tr "[a-z]" "[A-Z]")
        if [ "$OP" "$VAL" ]
        then
           if [[ $execute_once -eq 1 && $i != $localnode ]]
           then
              execute_once_sql_param=0
           elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
           then
              execute_once_sql_param=0
           else
              execute_once_sql_param=1
              OPSTAT=1
              log_pass
           fi
        else
           OPSTAT=0
           echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
           log_fail
        fi
        if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
        if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
        if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
            echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL_ACTUAL">>$AACTUAL
        elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
            echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL_ACTUAL">>$AACTUAL
        fi
        if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
	then
	    if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	    if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	    if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	    echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','ASM on $i','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A');">>$upload_raccheck_result_fil
	fi 
     elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
     then
        VAL=$(echo $VAL|tr "[a-z]" "[A-Z]")
        if [ "$OP" "$VAL" ]
        then
           if [[ $execute_once -eq 1 && $i != $localnode ]]
           then
              execute_once_sql_param=0
           elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
           then
              execute_once_sql_param=0
           else
              execute_once_sql_param=1
              OPSTAT=1
              log_pass
           fi
        else
           OPSTAT=0
           echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
           log_fail
        fi
        if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
        if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
        if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
            echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
        then
            echo "$inst_name|$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
        fi
	if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
	then
	    if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	    if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	    if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	    echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}');">>$upload_raccheck_result_fil
	fi
     fi  
     ;;
   SQL|SQL_OUT_CHECK)
     if [ $SILENT -eq "0"  ]
     then
        if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_dbinst_up[$stack_counter]} -eq 3 ]]
        then
            if [ "$OP" "$VAL" ] 
            then
                if [[ $execute_once -eq 1 && $i != $localnode ]]
                then
                   execute_once_sql=0
                else
                    execute_once_sql=0
                    OPSTAT=1
                    log_pass
                fi
            else
               OPSTAT=0
               log_fail

            fi
	    #if [ $ISBRANCH -eq 0 ]; then echo "$CHECK_ID|$VAL">>$DBACTUAL ; fi
	    if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
	    then
                #echo "$CHECK_ID|$VAL">>$DBACTUAL
		if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
                if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	        if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
		echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}');">>$upload_raccheck_result_fil
	    fi
        fi  
     elif [ $SILENT -eq "1" ]
     then
         OPSTAT=1
         log_pass
     fi 
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi 
     if [[ "$OP" = "-z" || "$OP" = "-n"  ]]; then VAL_ACTUAL=$OPSTAT; fi;
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
         if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]]
          then
              echo "$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
         fi;
     elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
         if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]]
         then
             echo "$CHECK_ID|$VAL_ACTUAL">>$DBACTUAL
         fi
     fi    
   ;;
   *)
     if [[ "$OP" = "-f" || "$OP" = "-d" || "$OP" = "! -f" || "$OP" = "! -d" ]]; then VAL=$COMP; fi;
     if [[ "$OP" = "-f" && `echo $COMP|grep -ic OUTPUTDIR`  -ge 1 ]]
     then
         VAL_DIR=$OUTPUTDIR
         VAL_FIL=$(echo $COMP|cut -d/ -f2)
         VAL=$(echo ${VAL_DIR}/${VAL_FIL})
         os_check_needs_collect_file=1  
     else
         os_check_needs_collect_file=0 
     fi
     if [ $RAT_DEBUG -eq 1 ]
     then
	 if [ $OP "$VAL" ]
	 then
	    if [[ $execute_once -eq 1 && $i != $localnode ]]
	    then
		execute_once_os=0
	    elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
	    then
		execute_once_os=0
	    else
		execute_once_os=1
		OPSTAT=1
		log_pass
	    fi
	 else
	     OPSTAT=0
	     log_fail
	 fi
     else
	 if [ $OP "$VAL"  2>>$ERRFIL ]
	 then
	    if [[ $execute_once -eq 1 && $i != $localnode ]]
	    then
		execute_once_os=0
	    elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
	    then
		execute_once_os=0
	    else
		execute_once_os=1
		OPSTAT=1
		log_pass
	    fi
	 else
	     OPSTAT=0
	     log_fail
	 fi
     fi
     if [[ "$OP" = "-f" || "$OP" = "-d" || "$OP" = "! -f" || "$OP" = "! -d" || "$OP" = "-z" || "$OP" = "-n" ]]; then VAL_ACTUAL=$OPSTAT; fi;
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi 
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
         if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
         then
             echo "${db_name_to_check}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
         elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
         then
             echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
         else
             echo "${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
         fi
     elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0  ]] && [ $write_info_actual_files -eq 1 ]
     then
         if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
         then
             echo "${db_name_to_check}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
         elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
         then
             echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
         else
             echo "${CHECK_ID}|${VAL_ACTUAL}" >>$OSACTUAL
         fi
     fi
     if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
     then 
         if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
         if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	 if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
         echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','NA','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}');">>$upload_raccheck_result_fil
     fi
      ;;
   esac
    ;;
   *)
   #if we have a comaprison value then the operator must not be -n or -z

#   echo "DEBUG: What am I doing in here? - $COMP"  

  #read -p "it comes here execute_once=$execute_once node=$i and localnode=$localnode com type =$COMTYPE"
   #read -p "DEBUG OP=$OP VAL=$COMP $ROW $SOURCEFIL it came here for -f OPSTAT=$OPSTAT VAL_DIR=$VAL_DIR VAL_FIL=$VAL_FIL VAL=$VAL"
   case $COMTYPE in

   OS_COLLECT)
     #if in SILENT mode, just collect the data as usual
     #all this branch does is run the OS command
     #no pass fail decisions to be made at this point
     #
     #echo "DEBUG - PATH = $OUTPUTDIR/$PARAM_PATH.out"
     #VAL would have been intialized in OS_COLLECT section below
     #same for $OUTFIL
     if [ $OFFLINE -eq "0"  ]  
     then
         if [[ $execute_once -eq 1 && $i != $localnode  ]]
         then
             execute_once_exce=0
         elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave"  ]]
         then
             execute_once_exce=0
         else
             execute_once_exce=1
            COMSUBSTR=`echo $COM |awk '{print substr($0,0,67)}' |sed 's/ //g'`
            #COMSUBSTR=`echo $COM |awk '{print substr($0,0,57)}' |sed 's/ //g'`
            if [ -z "$COLLECTION_NAME" ] 
            then
                echo "Collecting - $COMSUBSTR" 
                #echo "Collecting $COLLECTION_NAME - $COMSUBSTR" 
            else
                echo "Collecting - $COLLECTION_NAME" 
            fi
            echo "" >>$LOGFIL
            echo "Command executed on $i - $COM" >>$LOGFIL
            echo "" >>$LOGFIL
            #execute the command and redirect output to specified file
            #read -p "OUTFILE=$OUTFIL"
            echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $COLLECTION_NAME on $i">>$COLLECT_TIMING
            if [ $RAT_DEBUG -eq 1 ]
            then
                #read -p "$VAL"
                if [[ $i = $localnode ]]
                then
                    if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
                    then
                        for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                        do
                           skip_this_version=0
                           set_skip_this_version "$mb_db_homes"
                           if [ $skip_this_version -eq 1 ]
                           then #dont run
                             mb_db_counter=$(expr $mb_db_counter + 1)
                             echo "Skipping check($CHECK_ID) on version(9) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                             continue
                           fi
                           mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                           mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
                           OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                           OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                           TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
                           cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                           chmod 755 $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                           localcmd=/tmp/localcmd.sh
                           echo "#!$bash_scr" >$localcmd
                           echo "$bash_source" >>$localcmd
                           chmod 755 $localcmd
                           echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                           echo $COM>>$localcmd
                           if [ -n "$COM_REPORT" ]
                           then
                               localcmd_report=/tmp/localcmd_report.sh
                               echo "#!$bash_scr" >$localcmd_report
                               echo "$bash_source" >>$localcmd_report
                               chmod 754 $localcmd_report
                               echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
                               echo $COM_REPORT>>$localcmd_report
                           fi
                           $localcmd >>$OUTFIL
                           if [ -e $localcmd_report ]; then $localcmd_report >>$OUTFIL_REPORT;fi
                        done  
                    else
                        $localcmd >>$OUTFIL
                        if [ -e $localcmd_report ]; then $localcmd_report >>$OUTFIL_REPORT;fi
                    fi
                else
                    if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
                    then
                        for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                        do
                           skip_this_version=0
                           set_skip_this_version "$mb_db_homes"
                           if [ $skip_this_version -eq 1 ]
                           then #dont run
                             mb_db_counter=$(expr $mb_db_counter + 1)
                             echo "Skipping check($CHECK_ID) on version(10) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                             continue
                           fi
                           mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                           mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
                           OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                           OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                           TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
                           cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                           chmod 755 $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                           echo "#!$bash_scr" >$localcmd
                           echo "$bash_source" >>$localcmd
                           chmod 755 $localcmd
                           echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                           echo $COM>>$localcmd
                           if [ -n "$COM_REPORT" ]
                           then
                               localcmd_report=/tmp/localcmd_report.sh
                               echo "#!$bash_scr" >$localcmd_report
                               echo "$bash_source" >>$localcmd_report
                               chmod 755 $localcmd_report
                               echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
                               echo $COM_REPORT>>$localcmd_report
                           fi
                           $SCOPY $localcmd $localcmd_report $i:/tmp >/dev/null 2>&1 
			   $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                           $SSHELL $i $localcmd >>$OUTFIL
                           if [ -e $localcmd_report ]; then $SSHELL $i $localcmd_report >>$OUTFIL_REPORT;fi
                           $SSHELL $i rm -f $localcmd $localcmd_report >/dev/null 2>&1
			   $SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                        done 
                    else
                        $SCOPY $localcmd $i:/tmp >/dev/null 2>&1
                        $SSHELL $i $localcmd >>$OUTFIL
                        if [ -e $localcmd_report ]; then $SCOPY $localcmd_report $i:/tmp >/dev/null 2>&1;fi
                        if [ -e $localcmd_report ]; then $SSHELL $i $localcmd_report >>$OUTFIL_REPORT;fi
                        $SSHELL $i rm -f $localcmd >/dev/null 2>&1
                        $SSHELL $i rm -f $localcmd_report >/dev/null 2>&1
                    fi
                fi
                #cat $localcmd
                #read -p "see above"
                #ssh ratus-vm2 . /tmp/set_orcl_env.sh;/sbin/sysctl -a >>$OUTFIL
            else
                if [[ $i = $localnode ]]
                then
                    if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
                    then
                        for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                        do
                           skip_this_version=0
                           set_skip_this_version "$mb_db_homes"
                           if [ $skip_this_version -eq 1 ]
                           then #dont run
                             mb_db_counter=$(expr $mb_db_counter + 1)
                             echo "Skipping check($CHECK_ID) on version(11) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                             continue
                           fi
                           mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                           mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
                           OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                           OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                           TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
                           cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                           chmod 755 $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                           localcmd=/tmp/localcmd.sh
                           echo "#!$bash_scr" >$localcmd
                           echo "$bash_source" >>$localcmd
                           chmod 755 $localcmd
                           echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                           echo $COM>>$localcmd
                           if [ -n "$COM_REPORT" ]
                           then
                               localcmd_report=/tmp/localcmd_report.sh
                               echo "#!$bash_scr" >$localcmd_report
                               echo "$bash_source" >>$localcmd_report
                               chmod 755 $localcmd_report
                               echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
                               echo $COM_REPORT>>$localcmd_report
                           fi
                           $localcmd >>$OUTFIL 2>>$ERRFIL
                           if [ -e $localcmd_report ]; then $localcmd_report >>$OUTFIL_REPORT 2>>$ERRFIL;fi
                        #cat $TRGTORCLENV_PATCEHS
                        #cat $localcmd
                        #cat $localcmd_report 
                        done
                        
                    else
                        $localcmd >>$OUTFIL 2>>$ERRFIL
                        if [ -e $localcmd_report ]; then $localcmd_report >>$OUTFIL_REPORT 2>>$ERRFIL;fi
                    fi
                else
                    if [[ "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
                    then
                        for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                        do
                           skip_this_version=0
                           set_skip_this_version "$mb_db_homes"
                           if [ $skip_this_version -eq 1 ]
                           then #dont run
                             mb_db_counter=$(expr $mb_db_counter + 1)
                             echo "Skipping check($CHECK_ID) on version(12) db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                             continue
                           fi
                           mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                           mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
                           OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i".out"
                           OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_${mb_db_homes_without_slash}_"$i"_report.out"
                           TRGTORCLENV_PATCEHS=${RTEMPDIR}/set_orcl_env_patches.sh
                           cp $TRGTORCLENV $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                           chmod 755 $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                           localcmd=/tmp/localcmd.sh
                           echo "#!$bash_scr" >$localcmd
                           echo "$bash_source" >>$localcmd
                           chmod 755 $localcmd
                           echo "export ORACLE_HOME=$mb_db_homes">>$TRGTORCLENV_PATCEHS
                           echo ". $TRGTORCLENV_PATCEHS">>$localcmd
                           echo $COM>>$localcmd
                           if [ -n "$COM_REPORT" ]
                           then
                               localcmd_report=/tmp/localcmd_report.sh
                               echo "#!$bash_scr" >$localcmd_report
                               echo "$bash_source" >>$localcmd_report
                               chmod 755 $localcmd_report
                               echo ". $TRGTORCLENV_PATCEHS">>$localcmd_report
                               echo $COM_REPORT>>$localcmd_report
                           fi  
                           $SCOPY $localcmd $localcmd_report $i:/tmp >/dev/null 2>&1
                           $SCOPY $TRGTORCLENV_PATCEHS $i:${RTEMPDIR} >/dev/null 2>&1
                           $SSHELL $i $localcmd >>$OUTFIL 2>>$ERRFIL 
                           if [ -e $localcmd_report ]; then $SSHELL $i $localcmd_report >>$OUTFIL_REPORT 2>>$ERRFIL;fi
                           #read -p "stop for remote patch collection"   
                           $SSHELL $i rm -f $localcmd $localcmd_report >/dev/null 2>&1
                           $SSHELL $i rm -f $TRGTORCLENV_PATCEHS >/dev/null 2>&1
                        done
                    else  
                        $SCOPY $localcmd $i:/tmp 1>/dev/null >/dev/null 2>&1
                        $SSHELL $i $localcmd >>$OUTFIL 2>>$ERRFIL
                        if [ -e $localcmd_report ]; then $SCOPY $localcmd_report $i:/tmp >/dev/null 2>&1;fi
                        if [ -e $localcmd_report ]; then $SSHELL $i $localcmd_report >>$OUTFIL_REPORT 2>>$ERRFIL;fi
                        $SSHELL $i rm -f $localcmd >/dev/null 2>&1
                        $SSHELL $i rm -f $localcmd_report >/dev/null 2>&1
                    fi
                fi
                #$localcmd >>$OUTFIL 2>>$ERRFIL
            fi
            if [ -e $localcmd ]; then rm -f $localcmd 2>/dev/null;fi
            if [ -e $localcmd_report ]; then rm -f $localcmd_report  2>/dev/null;fi
            if [ -e $TRGTORCLENV_PATCEHS ]; then rm -f $TRGTORCLENV_PATCEHS 2>/dev/null;fi
         fi
     fi
     ;;
   SQL_COLLECT)
     #if in SILENT mode then just collect the data as usual
     #
     #all this branch does is run the SQL command
     #no pass or fail decisions to be made at this point
     #
     #for each SQL_COLLECT we'll make a new script file
     #execute it in SQLPLUS and spool the result to the outpu directory
     #echo "DEBUG - PARAM_PATH = $PARAM_PATH, COM = $COM"
   
     #we only want to do these spool files once per database
     #not once per node so we check here if the file already exists
     #if it does we do not want to do the collection again
      #echo " $SF `echo $SF|grep -ic "DBMACHINE V1"` db_machine_compute=$db_machine_compute " 
      #read -p "see this"
      
     if [ ! -f $OUTFIL ] && [ $OFFLINE -eq "0" ] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]&& [ ${stack_asm_up[$stack_counter]} -eq 1 -o ${stack_db_status[$mb_db_counter]} -ne 0 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ]
     then
         if  [[ $component_match_count  -lt 1 ]]
         then
             echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
         #commented this branch to execute all SQL_COLLECT to on all databases  
         #elif [[ "${mb_database_role[$mb_db_counter]}" != "$check_database_role" ]] 
         #then
         #    echo "$COM skipped for $db_name_to_check because database role does not match">>$LOGFIL
         #    call_get_log_result=0
         else
	     #create the script file that will be executed in SQL*Plus
	     #echo "DEBUG - INFIL = $INFIL"
	     #COMSUBSTR_NAME=`echo $COM |awk '{print substr($0,0,57)}' |sed 's/ //g'`
	     COMSUBSTR=`echo $COM |awk '{print substr($0,0,67)}' |sed 's/ //g'`
	     echo "$COM" >>$INFIL
	     pl_sql=`echo $COM|grep -ic "begin" `
	     if [ $pl_sql -gt 0 ]
	     then
		 echo "/" >>$INFIL
	     #read -p "see $INFIL for /"
	     fi
	     if [[ "$NEEDS_RUNNING" = "ASM" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
	     then
		 if [ -z "$COLLECTION_NAME" ] 
		 then
		     echo "Collecting - $COMSUBSTR" 
		 else
		    echo "Collecting - $COLLECTION_NAME " 
		 fi
		 #OLD_ORACLE_HOME=$ORACLE_HOME
		 #OLD_ORACLE_SID=$ORACLE_SID
                 if [[ -n "$crs112" && $crs112 -ge 1 ]]
		 then
		      export ORACLE_SID=${stack_asm_sid[$stack_counter]}
		      export ORACLE_HOME=$CRS
		else
		      export ORACLE_HOME=${stack_asm_home[$stack_counter]}
		      export ORACLE_SID=${stack_asm_sid[$stack_counter]}
		 fi
		 #read -p "ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID infile is $INFIL and query is $COM"
                 echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $COLLECTION_NAME">>$COLLECT_TIMING
                 #added 1=2 not to execute first part of this if not execute asm collection with username/password becuase we never ask asm sysdba password
		 if [[ -n "${mb_checksysdba[$mb_db_counter]}" && ${mb_checksysdba[$mb_db_counter]} -eq 0 && 1 -eq 2 ]]
		 then
                     DBUSR=${mb_sysdba_user[$mb_db_counter]}
                     DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
		     $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
		     set serveroutput on
		     spool $OUTFIL
		     @@$INFIL
		     spool off
		     exit
EOF
		 else
		     #read -p "before asm collection"
		     $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
		     set serveroutput on
		     spool $OUTFIL
		     @@$INFIL
		     spool off
		     exit
EOF
		  #read -p "check asm collection $ORACLE_SID and $ORACLE_HOME $OUTFIL and infile=$INFIL"
		 fi
		 #ORACLE_SID=$OLD_ORACLE_SID
		 #ORACLE_HOME=$OLD_ORACLE_HOME   
	     elif [[ "$NEEDS_RUNNING" != "ASM" ]] && [ ${stack_db_status[$mb_db_counter]} -ne 0 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ]
	     then
                 #echo "calling sql collect for $db_name_name_to_check oralce_Sid $ORACLE_SID and Oracle_home $ORACLE_HOME"
		 if [ -z "$COLLECTION_NAME" ] 
		 then
		     echo "Collecting - $COMSUBSTR for ${db_name_to_check} database" 
		 else
		     echo "Collecting - $COLLECTION_NAME for ${db_name_to_check} database " 
		 fi
		 #read -p "IS_SYSDBA=$IS_SYSDBA" 
                 echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $COLLECTION_NAME on ${db_name_to_check}">>$COLLECT_TIMING
		 if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]
		 then
		     #mb_checksysdba[$mb_db_counter]=0
		     dbConnectString="${RAT_PDB_USER}/${mb_db_sys_password[$mb_db_counter]}@"${mb_db_connect_string[$mb_db_counter]}" as sysdba"
		 else
                     DBUSR=${mb_sysdba_user[$mb_db_counter]}
                     DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
		     dbConnectString="$DBUSR/$DBPWD as sysdba"
		 fi      
		 if [ ${mb_checksysdba[$mb_db_counter]} -eq 0 ]
		 then
		   if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
		   then
		    #read -p "came here for SQL_COLLECT RDBMS without issysdba"
		     $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
		     set serveroutput on
		     spool $OUTFIL
		     @@$INFIL
		     spool off
		     exit
EOF
		   else #remote_database_code
		     $SCOPY $INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
		     $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
				      export ORACLE_HOME=$ORACLE_HOME;
				      export ORACLE_SID=$ORACLE_SID;
		     $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
		     set serveroutput on
		     spool $RTEMPDIR/sqltorun.out
		     @@$RTEMPDIR/sqltorun.sql
		     spool off
		     exit
EOF
EOF2
		     $SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
		     cat $RTEMPDIR/sqltorun.out > $OUTFIL
		   fi
		 else
		 #$ORACLE_HOME/bin/sqlplus -s / as sysdba
		     #read -p "came here for SQL_COLLECT RDBMS with issysdba see $OUTFIL"
		   if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
		   then
		     $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
		     set serveroutput on
		     spool $OUTFIL
		     @@$INFIL
		     spool off
		     exit
EOF
		   else #remote_database_code
		     $SCOPY $INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
		     $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
				      export ORACLE_HOME=$ORACLE_HOME;
				      export ORACLE_SID=$ORACLE_SID;
		     $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set feedback off
		     set serveroutput on
		     spool $RTEMPDIR/sqltorun.out
		     @@$RTEMPDIR/sqltorun.sql
		     spool off
		     exit
EOF
EOF2
		     $SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
		     cat $RTEMPDIR/sqltorun.out > $OUTFIL
		   fi
		 fi
	     fi
         fi
#       log_pass
     fi
     ;;
   OS_PACKAGE)
    #OS PAckages are a special case
    #what we want to know is if the package is installed
    #is the package that is installed a bad version of the package?
    #if the package is installed and it's not a bad version then => PASS
    #if the package that is installed is bad then => WARN/FAIL
    #read -p "RPM status $rpm_status"
  
  if [ $SILENT -eq 0 ]
  then
     echo "ROW=$ROW" >>$LOGFIL
     echo "RPM Checked.recommended rpm is $PARAM_PATH and actual found on system is $actual" and rpm status=$rpm_status>>$LOGFIL
     PARAM_PATH_PASS=""
     if [ -n "${rpm_arr1}" ]
     then
         for array_item in ${rpm_arr1[*]}
         do
          #if [ $element_count -ne 3 ] && [ -n "$array_item" ]
          if [ -n "$array_item" ]
          then
             if [ -z "$PARAM_PATH_PASS" ]
             then
                 PARAM_PATH_PASS=$array_item
             else
                 PARAM_PATH_PASS=$(echo $PARAM_PATH_PASS"-"$array_item)
             fi
          fi
      
          element_count=$(expr $element_count + 1)
         done 
     else
         PARAM_PATH_PASS=$(echo $PARAM_PATH|sed 's/|/-/g')
         PARAM_PATH_PASS=$(echo $PARAM_PATH_PASS|sed 's/--/-/g')
     fi
     element_count=0
     ACTUAL_PASS=""
     if [ -n "${rpm_arr2}" ]
     then
         for array_item in ${rpm_arr2[*]}
         do
          #if [ $element_count -ne 3 ] && [ -n "$array_item" ]
          if [ -n "$array_item" ]
          then
             if [ -z "$ACTUAL_PASS" ]
             then
                 ACTUAL_PASS=$array_item
             else
                 ACTUAL_PASS=$(echo $ACTUAL_PASS"-"$array_item)
             fi
          fi
      
          element_count=$(expr $element_count + 1)
         done 
     else
         ACTUAL_PASS=$(echo $actual|sed 's/|/-/g')
         ACTUAL_PASS=$(echo $ACTUAL_PASS|sed 's/--/-/g')
     fi
     element_count=0
     if [ $RAT_DEBUG -eq 1 ]
     then
         #if [ "$VAL" "$OP" "$COMP" ] #2>>$ERRFIL
         if [ $rpm_status -eq 0 ] 
         then
             OPSTAT=1
             #PARAM_PATH_PASS=$(echo $PARAM_PATH|sed 's/|/-/g')
             #PMSG="Package $PARAM_PATH_PASS fulfills recommendation"
             #if [ $rpm_arch -eq 1 ]
             #then
             if [ $rpm_arch -ne 99 ]
             then
                echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
             fi     
             PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation"
             log_pass
             ALVL="PASS"
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
         elif [ $rpm_status -eq 1 ]
         then
             OPSTAT=1
             if [ $rpm_arch -ne 99 ]
             then
                echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
             fi     
             PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation"
             log_pass
             ALVL="PASS"
             #PMSG="Package ${rpm_arr1[0]}-${rpm_arr1[1]}-${rpm_arr1[2]} is higher than recommended"
             #PMSG="Package $PARAM_PATH_PASS is higher than recommended"
             #if [ $rpm_arch -eq 1 ]
             #then
             #    PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation"
             #if [ $rpm_arch -ne 99 ]
             #then
             #    PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation but different architecture"
             #    ALVL="INFO"
             #fi
             #log_pass
         elif [ $rpm_status -eq 2 ]
         then
            OPSTAT=0
            #FMSG="Package ${rpm_arr1[0]}-${rpm_arr1[1]}-${rpm_arr1[2]} is lower than recommended"
            #FMSG="Package $PARAM_PATH_PASS is lower than recommended"
            FMSG="Package $ACTUAL_PASS does not meet recommendation for $PARAM_PATH_PASS "
            echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
            log_fail
            ALVL="WARNING"
         elif [ $rpm_status -eq 3 ]
         then
            OPSTAT=0
            ALVL="FAIL"
            FMSG="Package $PARAM_PATH_PASS is recommended but NOT installed"
            echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
            log_fail
         fi
     else
         if [ $rpm_status -eq 0 ] 
         then
             OPSTAT=1
             #PARAM_PATH_PASS=$(echo $PARAM_PATH|sed 's/|/-/g')
             #PMSG="Package $PARAM_PATH_PASS fulfills recommendation"
             #if [ $rpm_arch -eq 1 ]
             #then
             if [ $rpm_arch -ne 99 ]
             then
                echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
             fi     
             PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation"
             log_pass
             ALVL="PASS"
             #     PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation"
             #if [ $rpm_arch -ne 99 ]
             #then
             #     PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation but different architecture "
             #     ALVL="INFO"
             #fi     
             #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
             #log_pass
         elif [ $rpm_status -eq 1 ]
         then
             OPSTAT=1
             #PMSG="Package ${rpm_arr1[0]}-${rpm_arr1[1]}-${rpm_arr1[2]} is higher than recommended"
             #PMSG="Package $PARAM_PATH_PASS is higher than recommended"
             #if [ $rpm_arch -eq 1 ]
             #then
             if [ $rpm_arch -ne 99 ]
             then
                echo "Package $PARAM_PATH_PASS meets or exceeds recommendation but different ${rpm_arr2[3]} architecture">>$LOGFIL
             fi     
             PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation"
             ALVL="PASS"
             log_pass
             #    PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation"
             #if [ $rpm_arch -ne 99 ]
             #then
             #    PMSG="Package $PARAM_PATH_PASS meets or exceeds recommendation but different architecture"
             #    ALVL="INFO"
             #fi
             #log_pass
         elif [ $rpm_status -eq  2 ]
         then
            OPSTAT=0
            #FMSG="Package ${rpm_arr1[0]}-${rpm_arr1[1]}-${rpm_arr1[2]} is lower than recommended"
            #FMSG="Package $PARAM_PATH_PASS is lower than recommended"
            FMSG="Package $ACTUAL_PASS does not meet recommendation for $PARAM_PATH_PASS "
            echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
            log_fail
            ALVL="WARNING"
         elif [ $rpm_status -eq 3 ]
         then
            OPSTAT=0
            ALVL="FAIL"
            FMSG="Package $PARAM_PATH_PASS is recommended but NOT installed"
            echo "Package $PARAM_PATH_PASS failed for node $i">>$CWOSPKG
            log_fail
         fi 
     fi 
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi 
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]] && [ $write_info_actual_files -eq 1 ]
     then
          echo "${CHECK_ID}|${rpm_status}@$PARAM_PATH_PASS" >>$OSACTUAL
     elif [ $OFFLINE -eq 0 ] && [ $write_info_actual_files -eq 1 ]
     then
         echo "${CHECK_ID}|${rpm_status}@$actual" >>$OSACTUAL
     fi
     if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
     then
        if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
        if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
        if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
        echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$PARAM_PATH_PASS','$PARAM_PATH_PASS','$ALVL_MB','$status_message','$PARAM_PATH_PASS','$ACTUAL_PASS','NA','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','NA','$CHECK_ID','N/A','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A');">>$upload_raccheck_result_fil
     fi
  else
  #commented below code and above if condition not to generate silent files because i did not find these files being used anywhere else
   #code to generate os check result file in slent mode
          #ACREPCOUNT=`expr $ACREPCOUNT + 1`
          echo  "RPM check # $ACREPCOUNT@RPM Version Check@$actual@$PARAM_PATH@$ALVL=>$FMSG@$rpm_status@$rpm_arch">>$OSPKGSILENT
  fi
  ;;
   OS_PATCH)
   if [ $SILENT -eq 0 ] 
   then
      if [ $RAT_DEBUG -eq 1 ]
      then
        if [ $os_patch_status -eq 1 ]
        then
           #ALVL="PASS"
           OPSTAT=1
           PMSG="OS Patch $PARAM_PATH meets or exceeds recommendation"
           log_pass
           ALVL="PASS"
        elif [ $os_patch_status -eq 2 ]
        then
           #ALVL="WARNING"
           OPSTAT=0
           FMSG="OS Patch $PARAM_PATH does not satisfy recommendation"
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           log_fail
           ALVL="WARNING"
        else
           #ALVL="FAIL"
           OPSTAT=0
           FMSG="OS Patch $PARAM_PATH is recommended but not installed"
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           log_fail
           ALVL="FAIL"
        fi 
      else   
        if [ $os_patch_status -eq 1 2>>$ERRFIL ]
        then
           #ALVL="PASS"
           OPSTAT=1
           PMSG="OS Patch $PARAM_PATH meets or exceeds recommendation"
           log_pass
           ALVL="PASS"
        elif [ $os_patch_status -eq 2 2>>$ERRFIL ]
        then
           #ALVL="WARNING"
           OPSTAT=0
           FMSG="OS Patch $PARAM_PATH does not satisfy recommendation"
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           log_fail
           ALVL="WARNING"
        else
           #ALVL="FAIL"
           OPSTAT=0
           FMSG="OS Patch $PARAM_PATH is recommended but not installed" 
           echo "OS Patch $PARAM_PATH failed for node $i">>$CWOSPATCH
           log_fail
           ALVL="FAIL"
        fi 
      fi
      if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
      then
       #   echo "${CHECK_ID}|${os_patch_status}@$os_patch_rls_actual" >>$OSACTUAL  
          if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
          if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	  if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
          echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'NA','$PARAM_PATH','$ALVL_MB','$status_message','$os_patch_rls_actual','$PARAM_PASS','NA','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','NA','$CHECK_ID','N/A','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A');">>$upload_raccheck_result_fil
      fi
   fi
   if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
   if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
   then
       echo "$CHECK_ID|$os_patch_status">>$OSACTUAL
   elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
   then
       echo "$CHECK_ID|$os_patch_status">>$OSACTUAL
   fi
    ;;
   SQL|SQL_OUT_CHECK)
     if [ $SILENT -eq "0"  ]
     then
       echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value $COMP">>$LOGFIL
       #read -p  "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value $COMP alert level=$ALVL"
       #if [ $COMTYPE = "SQL_OUT_CHECK" ]
       #then
       #read -p "Press any key"    
       #read -p "rdbms status = ${stack_dbinst_up[$stack_counter]} and asm status =${stack_asm_up[$stack_counter]} and needs running=$NEEDS_RUNNING comtype=$COMTYPE" 
       #fi
        if [[ $i = $localnode &&  ${stack_dbinst_up[$stack_counter]} -ge ${database_mode} && $NEEDS_RUNNING = "RDBMS" && $RAT_RUNMODE_INTERNAL = "master" ]]
        #if [[ $i = $localnode &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS"  ]]
        #if [[ $i = ${mb_running_host[$mb_db_counter]} &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS"  ]]
        then
           if [ $RAT_DEBUG -eq 1 ]
           then
               if [ "$VAL" "$OP" "$COMP" ] #2>>$ERRFIL
               then
                   OPSTAT=1
                   #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                   if [[ -e $SOURCEFIL_REPORT && `cat $SOURCEFIL_REPORT|sed '/^$/d'|wc -l` -lt 2 ]]
                   then
                       echo -e "\nQuery returned no rows which is expected when the SQL check passes.\n">>$SOURCEFIL_REPORT
                   fi
                   log_pass
               else
                   OPSTAT=0
                   log_fail
               fi
           else
               if [ "$VAL" "$OP" "$COMP" ] 2>>$ERRFIL
               then
                   OPSTAT=1
                   if [[ -e $SOURCEFIL_REPORT && `cat $SOURCEFIL_REPORT|sed '/^$/d'|wc -l` -lt 2 ]]
                   then
                       echo -e "\nQuery returned no rows which is expected when the SQL check passes.\n">>$SOURCEFIL_REPORT
                   #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                   fi 
                   log_pass
               else
                   OPSTAT=0
                   log_fail
               fi
           fi 
          #read -p "ALVL=$ALVL and ALVL_MB=$ALVL_MB"
	  if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
	  then
             # echo "$CHECK_ID|$VAL">>$DBACTUAL
	      if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	      if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	      if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
           #   read -p "ALVL=$ALVL and ALVL_MB=$ALVL_MB"
	      #read -p "ALVL=$ALVL status_message=$status_message"
	      echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}');">>$upload_raccheck_result_fil
	  fi
        elif [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_asm_up[$stack_counter]} -eq 1 && $NEEDS_RUNNING = "ASM"  ]]
        then
            if [ $RAT_DEBUG -eq 1 ]
           then
               if [ "$VAL" "$OP" "$COMP" ] #2>>$ERRFIL
               then
                   OPSTAT=1
                   #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                   log_pass
               else
                   OPSTAT=0
                   log_fail
               fi
           else
               if [ "$VAL" "$OP" "$COMP" ] 2>>$ERRFIL
               then
                   OPSTAT=1
                   #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                   log_pass
               else
                   OPSTAT=0
                   log_fail
               fi
           fi
	   if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
	   then
              # echo "$CHECK_ID|$VAL">>$AACTUAL
	       if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	       if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	       if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	       #read -p "ALVL=$ALVL status_message=$status_message"
	       echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A');">>$upload_raccheck_result_fil
	   fi
        fi 
     elif [ $SILENT -eq "1" ]
     then
       #whenever we are in SILENT mode we want every branch to evaluate to 
       #true so that we traverse the entire tree and so we do not miss 
       #collecting any data for any branch or step
       #
       # so we will declare each pass to be TRUE and go on to log_pass()
       #as if we had evaluated the expression and found it to be TRUE
        OPSTAT=1
        log_pass
     else
       echo "SILENT was not equal to 1 or 0.  This should not happen" >>$LOGFIL
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
         #if [[ $i = $mb_running_host[$mb_db_counter]} &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
         if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
          then 
              echo "$CHECK_ID|$VAL">>$DBACTUAL
         elif [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_asm_up[$stack_counter]} -eq 1 && $NEEDS_RUNNING = "ASM"  ]] 
         then  
             echo "$CHECK_ID|$VAL">>$AACTUAL
         fi
     elif [[ $OFFLINE -eq 0 &&  $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
         #if [[ $i = ${mb_running_host[$mb_db_counter]} &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
         if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_db_status[$mb_db_counter]} -eq 3 && $NEEDS_RUNNING = "RDBMS" ]] 
         then 
             echo "$CHECK_ID|$VAL">>$DBACTUAL
         elif [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  ${stack_asm_up[$stack_counter]} -eq 1 && $NEEDS_RUNNING = "ASM"  ]] 
         then 
             echo "$CHECK_ID|$VAL">>$AACTUAL
         fi
     fi
      # if [ $COMTYPE = "SQL_OUT_CHECK" ]
      # then
      # read -p "Press any key"    
      # read -p " after execute rdbms status = ${stack_dbinst_up[$stack_counter]} and asm status =${stack_asm_up[$stack_counter]} and needs running=$NEEDS_RUNNING comtype=$COMTYPE" 
      #fi
     ;;
 SQL_PARAM)
      
     if [ $SILENT -eq "0"  ]
     then
       #echo "$VAL $OP $COMP at $ROW"
       #read -p "Press any key"
       echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value $COMP SOURCEFILENAME=$SOURCEFILENAME">>$LOGFIL
       #read -p "Insance status= ${stack_dbinst_up[$stack_counter]} and stack counter is $stack_counter"
        #read -p "${stack_dbinst_name[$stack_counter]}.${PARAM_PATH} compare=$COMP and $FMSG"
       if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       #if [[ ${stack_dbinst_up[$stack_counter]} -ne 0 || ${stack_asm_up[$stack_counter]} -eq 1 ]]
       then
           VAL=$(echo $VAL|tr "[a-z]" "[A-Z]") 
           COMP=$(echo $COMP|tr "[a-z]" "[A-Z]")
           if [ $RAT_DEBUG -eq 1 ]
           then
               if [ "$VAL" "$OP" "$COMP" ]  #2>>$ERRFIL
               then
                   OPSTAT=1
                      #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                   log_pass
               else
                   OPSTAT=0
                   echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
                   log_fail
               fi
           else
               if [ "$VAL" "$OP" "$COMP" ]  2>>$ERRFIL
               then
                   OPSTAT=1
                      #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                   log_pass
               else
                   OPSTAT=0
                   echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
                   log_fail
               fi
           fi
           if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
           then
               #echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
               if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	       if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	       if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
               echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}');">>$upload_raccheck_result_fil
           fi
       elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
       then
           if [ $RAT_DEBUG -eq 1 ]
           then
               if [ "$VAL" "$OP" "$COMP" ]  #2>>$ERRFIL
               then
                   OPSTAT=1
                      #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                   log_pass
               else
                   OPSTAT=0
                   echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
                   log_fail
               fi
           else
               if [ "$VAL" "$OP" "$COMP" ]  2>>$ERRFIL
               then
                   OPSTAT=1
                      #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                   log_pass
               else
                   OPSTAT=0
                   echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
                   log_fail
               fi
           fi
           if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
           then
	       #echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL">>$AACTUAL
	       if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	       if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	       if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	       echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','ASM on $i','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A');">>$upload_raccheck_result_fil
           fi
       elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
       then
           if [ $RAT_DEBUG -eq 1 ]
           then
               if [ "$VAL" "$OP" "$COMP" ]  #2>>$ERRFIL
               then
                   OPSTAT=1
                      #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                   log_pass
               else
                   OPSTAT=0
                   echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
                   log_fail
               fi
           else
               if [ "$VAL" "$OP" "$COMP" ]  2>>$ERRFIL
               then
                   OPSTAT=1
                      #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                   log_pass
               else
                   OPSTAT=0
                   echo "SQL parameter $PARAM_PATH failed for instance ${stack_dbinst_name[$stack_counter]} on node $i">>$CWSQLPARAM
                   log_fail
               fi
           fi
           if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
           then 
               #echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
               if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	       if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	       if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
               echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','$inst_name','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}');">>$upload_raccheck_result_fil
           fi
       fi
     elif [ $SILENT -eq "1" ]
     then
       #whenever we are in SILENT mode we want every branch to evaluate to
       #true so that we traverse the entire tree and so we do not miss
       #collecting any data for any branch or step
       #
       # so we will declare each pass to be TRUE and go on to log_pass()
       #as if we had evaluated the expression and found it to be TRUE
        OPSTAT=1
        log_pass
     else
       echo "SILENT was not equal to 1 or 0.  This should not happen" >>$LOGFIL
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
         if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
         then 
             echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL;
         elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 && -e $SOURCEFIL ]]
         then 
             echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL">>$AACTUAL
         elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
         then
             echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
         fi;
     elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]] && [ $write_info_actual_files -eq 1 ]
     then
         if [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
         then
             echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL;
         elif [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 && -e $SOURCEFIL ]]
         then
	     echo "${stack_asm_sid[$stack_counter]}|$CHECK_ID|$VAL">>$AACTUAL
         elif  [[ -n "$SOURCEFILENAME" &&  "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
         then
             echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL
         fi
     fi
     ;;
 CLUSTERWIDE_CHECK)
     #if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]]
     #then
     #    echo "$CHECK_ID|$CRS_VAL">>$CCACTUAL
     #elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]]
     #then
     #    echo "$CHECK_ID|$CRS_VAL">>$CCACTUAL
     #fi   
     if [[ -n "$cross_node_get_log_result_call" && $cross_node_get_log_result_call -eq 1 ]]
     then 
	 if [ $RAT_DEBUG -eq 1 ]
	 then
	     if [ "$VAL" "$OP" "$COMP" ]; then CRS_VAL=1; else CRS_VAL=0;fi
	 else
	     if [ "$VAL" "$OP" "$COMP" ] 2>>$ERRFIL; then CRS_VAL=1; else CRS_VAL=0;fi
	 fi 
     fi
     if [[ -n $CRS_VAL && $CRS_VAL -eq 1 ]]
     then
          #read -p  "cls_check_val1=$cls_check_val1 and cls_check_val2=$cls_check_val2 and CRS_VAL=$CRS_VAL $ROW $PMSG $FMSG $audit_check_name $COMTYPE"
          #read -p "COMTYPE=$COMTYPE"
          OPSTAT=1
          log_pass
	  if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
	  then
              #echo "$CHECK_ID|$VAL">>$CCACTUAL
	      if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	      if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	      if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	      echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$FILVAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A');">>$upload_raccheck_result_fil
	  fi
     elif [[ -n $CRS_VAL && $CRS_VAL -eq 0 ]]
     then
          OPSTAT=0
          log_fail
	  if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
	  then
	      if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	      if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
	      if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
	      echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$FILVAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','NA','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','N/A','$CRSVERSION_UPLOAD','N/A');">>$upload_raccheck_result_fil
	  fi
     fi   
    ;;
   *)
     #read -p "Press any key in get log result" 
     #We only want to do this comparison if we're NOT in SILENT mode
     #in SILENT mode we will not have a comparison operator or comparison value
     
     if [ $SILENT -eq "0"  ]
     then
       echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value =$COMP execute once=$execute_once ">>$LOGFIL
  #     echo "ROW=$ROW command=$COM actual value=$VAL opeartor=$OP required value =$COMP execute once=$execute_once "
      # read -p "Press any key"     
       #echo "VAL=%%%$VAL%%%%"
       if [[ $execute_once -eq 1 && $i != $localnode  ]]
         then
             execute_once_exec=0
       elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave"  ]]
         then
             execute_once_exec=0
       else
	     #if [ `echo $COM|grep -ic copy_collect_file` -ge 1 ]
	     #then
	     #    copy_collect_file_name=$(echo $COM >/dev/null|cut -d= -f2|cut -d; -f1)
	     #    cp ${OUTPUTDIR}/${copy_collect_file_name} .
             #    read -p "see file $copy_collect_file_name"
	     #fi
             execute_once_exec=1
             if [ $RAT_DEBUG -eq 1 ] 
             then
                 if [ "$VAL" "$OP" "$COMP" ] # 2>>$ERRFIL
                 then
                    OPSTAT=1
                    #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                    log_pass
                 else
                     OPSTAT=0
                     log_fail
                     if [ "$COMTYPE" = "OS_PARAM" ]; then echo "OS(kernel) parameter $PARAM_PATH failed for node $i">>$CWOSPARAM;fi;
                 fi 
             else
                 if [ "$VAL" "$OP" "$COMP" ]  2>>$ERRFIL
                 then
                    OPSTAT=1
                    #echo "DEBUG - VAL = $VAL, OP = $OP, COMP = $COMP"
                    log_pass
                 else
                     OPSTAT=0
                     log_fail
                     if [ "$COMTYPE" = "OS_PARAM" ]; then echo "OS(kernel) parameter $PARAM_PATH failed for node $i">>$CWOSPARAM;fi;
                 fi 
             fi
             #if [[ -n  "$os_check_needs_collect_file" && $os_check_needs_collect_file -eq 1 ]]; then rm $VAL_FIL;os_check_needs_collect_file=0; unset VAL_DIR VAL_FIL ;fi;
            # if [[ `echo $COM|grep -ic copy_collect_file` -ge 1 && -f $copy_collect_file_name ]]; then rm $copy_collect_file_name;fi;
	     if [[ $ISBRANCH -eq 0 && $OFFLINE -eq 0 ]]
	     then
                 #if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
                 #then
                 #    echo "${db_name_to_check}|${CHECK_ID}|${VAL}" >>$OSACTUAL
                 #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
                 #then
                 #    echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL}" >>$OSACTUAL
                 #else
                 #    echo "${CHECK_ID}|${VAL}" >>$OSACTUAL
                 #fi
		 if [ $OPSTAT -eq 1 ]; then status_message=$PMSG; else status_message=$FMSG; fi;
	         if [[ $OPSTAT -eq 1 && "$ALVL" != "INFO" ]]; then ALVL_MB="PASS"; else ALVL_MB=$ALVL;fi
                 if [[ $OPSTAT -eq 1 && "$ALVL" = "INFO" ]]; then ALVL_MB="INFO-PASS"; elif [ "$ALVL" = "INFO" ]; then ALVL_MB=$ALVL;fi; 
		  echo "insert into $RAT_UPLOAD_TABLE(collection_date,check_name,param_name,status,status_message,actual_value,recommended_value,comparison_operator,hostname,instance_name,check_type,db_platform,os_distro,os_kernel,os_version,db_version,cluster_name,db_name,check_id,needs_running,modules,database_role,clusterware_version,global_name)values(to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$audit_check_name','$PARAM_PATH','$ALVL_MB','$status_message','$VAL','$COMP','$OP','$i','NA','$COMTYPE','$upload_dbplatform','$upload_osdistro','$upload_oskernel','$upload_osversion','$DBVERSION','$cluster_name','$db_name_to_check','$CHECK_ID','$NEEDS_RUNNING','$old_check_components','${mb_database_role[$mb_db_counter]}','$CRSVERSION_UPLOAD','${mb_database_global_name[$mb_db_counter]}');">>$upload_raccheck_result_fil
	     fi
       fi
     elif [ $SILENT -eq "1" ]
     then
       #whenever we are in SILENT mode we want every branch to evaluate to 
       #true so that we traverse the entire tree and so we do not miss 
       #collecting any data for any branch or step
       #
       # so we will declare each pass to be TRUE and go on to log_pass()
       #as if we had evaluated the expression and found it to be TRUE
        OPSTAT=1
        log_pass
     else
       echo "SILENT was not equal to 1 or 0.  This should not happen" >>$LOGFIL
     fi
     if [[ $ALVL = "INFO" && $OPSTAT -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
     if [[ $execute_once -eq 1 && $i != $localnode  ]]
     then
         echo "" >/dev/null 2>&1 
     elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave"  ]]
     then
         echo "" >/dev/null 2>&1 
     elif [ $write_info_actual_files -eq 1 ]
     then
	 if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 && $ISBRANCH -eq 0 ]]  
	 then
	     if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
	     then
		 echo "${db_name_to_check}|${CHECK_ID}|${VAL}" >>$OSACTUAL
             elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]   
	     #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
	     then
		 echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL}" >>$OSACTUAL
             elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ -e $switch_name_file && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
             then
		 echo "${switchname}|${CHECK_ID}|${VAL}" >>$OSACTUAL
	     else
		 echo "${CHECK_ID}|${VAL}" >>$OSACTUAL
	     fi
	 elif [[ $OFFLINE -eq 0 && $ISBRANCH -eq 0 ]]
	 then
	     if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
	     then
		 echo "${db_name_to_check}|${CHECK_ID}|${VAL}" >>$OSACTUAL
             elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -gt 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]]   
	     #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && `echo $COM|grep -ic "limits.conf"` -lt 1 ]]
	     then
		 echo "${mb_db_homes_without_slash}|${CHECK_ID}|${VAL}" >>$OSACTUAL
             elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ -e $switch_name_file && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
             then
		 echo "${switchname}|${CHECK_ID}|${VAL}" >>$OSACTUAL    
	     else
		 echo "${CHECK_ID}|${VAL}" >>$OSACTUAL
	     fi
	 fi
     fi
     ;;
   esac
  ;;  
 esac
 
  if [[ -n "$cmd_type" && $cmd_type = "inloop" && $mb_db_counter_log -eq "0" ]]
  then
    m_opstat[$CUR_LEVEL]=""
  fi

  if [[ -n "$cmd_type" && $cmd_type = "inloop" && $OPSTAT -eq "1" ]]
  then # Load all succeeded target names into array
    # l_mb_db_homes is already set in set_skip_this_version
    if [ $cmd_value = "switch" ] ; then
      #echo "Pass on ${m_opstat[$CUR_LEVEL]},$switchname"
      m_opstat[$CUR_LEVEL]="${m_opstat[$CUR_LEVEL]},$switchname";
    else
      m_opstat[$CUR_LEVEL]="${m_opstat[$CUR_LEVEL]},$l_mb_db_homes-$l_mb_db_home_dname";
    fi
  elif [[  -n "$cmd_type" && $cmd_type = "inloop" && $OPSTAT -eq "0" ]]
  then
    m_opstat[$CUR_LEVEL]="${m_opstat[$CUR_LEVEL]},failedontarget"
  elif [[ -z "$cmd_type" && $OPSTAT -eq "1" ]] ; then
    m_opstat[$CUR_LEVEL]="passed_on_all_targets";
  elif [[ -z "$cmd_type" && $OPSTAT -eq "0" ]] ; then
    m_opstat[$CUR_LEVEL]="failedontarget"
  fi;
}

check_patch ()
{
    #if [ `$CRS/bin/olsnodes |wc -l` -gt 4 ]
    if [ `cat $HOSTLIST|wc -l` -gt 999 ] 
    then
        if [ "$1" = "crs" ]
        then
            APPLIED=`$SSHELL $i grep -c Oneoffs21\/$2 $CRS_INVENTORY`
        elif [ "$1" = "rdbms" ]
        then
            APPLIED=`$SSHELL $i grep -c Oneoffs21\/$2 $RDBMS_INVENTORY`
        elif [ "$1" = "asm" ]
        then
            APPLIED=`$SSHELL $i grep -c Oneoffs21\/$2 $ASM_INVENTORY`
        fi
    else
        if [ $OFFLINE -eq 0 ]
	then
            if [[ "$1" = "rdbms" ]]
            then 
                APPLIED=`grep -c $2 ${OUTPUTDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out`
                if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${OUTPUTDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out" "$2" "$1";fi
                #read -p " ${OUTPUTDIR}/o_${1}_inventory_${i}_${mb_db_homes_fil}.out"
            else 
                APPLIED=`grep -c $2 ${OUTPUTDIR}/o_${1}_inventory_${i}.out`
                if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${OUTPUTDIR}/o_${1}_inventory_${i}.out" "$2" "$1";fi
            fi
        else
            if [[ "$1" = "rdbms" ]]
            then
	        APPLIED=`grep -c $2 ${DUMPDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out`
                if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${DUMPDIR}/o_${1}_inventory_${mb_db_homes_fil}_${i}.out" "$2" "$1";fi
                #read -p " ${OUTPUTDIR}/o_${1}_inventory_${i}_${mb_db_homes_fil}.out"
            else
	        APPLIED=`grep -c $2 ${DUMPDIR}/o_${1}_inventory_${i}.out`
                if [[ -z "$APPLIED" || $APPLIED -eq 0 ]]; then check_higher_patch "${DUMPDIR}/o_${1}_inventory_${i}.out" "$2" "$1";fi
            fi
        fi
    fi
  #read -p "stop for higher_patch"
return $APPLIED
}

check_higher_patch ()
{
  if [ "$3" = "rdbms" ]
  then 
      applied_patches=$(cat $1|grep  ^"Patch description"|grep -i database|awk '{print $NF}'|sed 's/[^0-9]*//g')
  else
      applied_patches=$(cat $1|grep  ^"Patch description"|grep -iv database|awk '{print $NF}'|sed 's/[^0-9]*//g')
  fi
  #applied_patches="14727309 14727318 14727329 14727349"
  if [[ -e $1 && -n "$applied_patches" ]]
  then
      for applied_patch in $applied_patches
      do
        if [ "$applied_patch" -gt $2 ]
        then
            APPLIED=1
            PATCH=$applied_patch
            SUBJ=$(cat $1|grep -iw $PATCH|grep -iw "description")
            break
        else
            APPLIED=0
        fi
     done
  fi
}
checksysdba()
{
  if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
  then
    IS_SYSDBA=$(echo "select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba 2>>$ERRFIL|grep -v ^$) 
  else #remote_database_code
    IS_SYSDBA=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
    export ORACLE_HOME=$ORACLE_HOME ; \
    export ORACLE_SID=$ORACLE_SID; \
    echo "select 1 from dual;" | $ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^$
EOF
)
  fi
    echo "Value back from Database is  $IS_SYSDBA">>$LOGFIL
    if [ `echo $IS_SYSDBA|grep -c "ORA-"` -ge 1 ]
    then
        IS_SYSDBA=0
    else
        IS_SYSDBA=1
    fi
    echo -e "\nValue set to IS_SYSDBA for $db_name_to_check = ${IS_SYSDBA}\n\n">>$LOGFIL
}
checkpassword ()
{
  if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
  then
    is_password_correct=$(echo "select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^$)
  else #remote_database_code
    is_password_correct=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
    export ORACLE_HOME=$ORACLE_HOME
    export ORACLE_SID=$ORACLE_SID; \
    echo "select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^$
EOF
)
  fi
  if [[ -n "$is_password_correct" && `echo $is_password_correct|grep -c "ORA-"` -ge 1 ]]
  then
     echo -e "\n${is_password_correct}\n"
     WRNDBPWD=`expr $WRNDBPWD + 1`
     if [ $WRNDBPWD -lt 3 ]; 
     then
          nosysdba
     else    
          unset mb_db_names[$mb_db_counter] 
          echo -e "${RED}\n\n$DBUSR is not able to login as sysdba to ${db_name_to_check}.Make sure password file is available on ${mb_running_host[$mb_db_counter]} and you are using password file password to login as sysdba.\nYou can cancel (ctrl+c) this run,configure password file and run it again. Otherwise best practice checks for $db_name_to_check database will be skipped.\n\n"${NORM}|tee -a $LOGFIL
          echo -e "$is_password_correct">>$LOGFIL 
          #removing database from list becauase password did not work
      fi
  fi
}

checkdictionary ()
{
  if [ $IS_SYSDBA -eq 0 ]
  then
    if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
    then
      IS_DICTIONARY=$(echo "select name from v\$database;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD sysdba |grep -v ^$)     
    else #remote_database_code
      IS_DICTIONARY=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
    export ORACLE_HOME=$ORACLE_HOME
    export ORACLE_SID=$ORACLE_SID; \
     echo "select name from v\\\$database;" | $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD sysdba|grep -v ^$
EOF
)
    fi
  fi
  #echo "checkdictionary IS_DICTIONARY=$IS_DICTIONARY";

  if [ `echo $IS_DICTIONARY|grep -c "ORA-00942"` -ge 1 ]
  then
     IS_DICTIONARY=0
  else
     IS_DICTIONARY=1
  fi
}

nosysdba ()
{
  if [ $WRNDBPWD -gt 0 ]
  then
      
      read -p "Enter user name again for $db_name_to_check:- " DBUSR
      printf  "Enter password for $DBUSR@$db_name_to_check:- " 
      stty -echo
      read DBPWD
      stty echo
      if [ `echo $DBUSR|wc -w` -gt 1 ]; then    DBUSR=`echo $DBUSR|awk '{print $1}'`; fi
      checkpassword
  else
      #read -p "ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID"
      echo -e "\n"
      read -p "OS authenticaltion is not enabled so please enter sysdba privileged user name for $db_name_to_check:- " DBUSR
      printf  "Enter password for $DBUSR@$db_name_to_check:- " 
      stty -echo
      read DBPWD
      stty echo
      if [ `echo $DBUSR|wc -w` -gt 1 ]; then    DBUSR=`echo $DBUSR|awk '{print $1}'`; fi
      checkpassword
 fi
 #If user enter sys as sysdba, take only sys because script appends "as sysdba".
}

singleSqlValue ()
{
 colname=`echo $1 |tr 'a-z' 'A-Z'` 
 if [ ${mb_checksysdba[$mb_db_counter]} -eq 1 ]
 then
     if [ $# -eq 3  ]
     then 
       if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
       then
         sqlValue=$( echo "set heading off feedback off timing off;
                     select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$|tail -1)
       else #remote_database_code
         sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
           export ORACLE_HOME=$ORACLE_HOME
           export ORACLE_SID=$ORACLE_SID; \
           echo "set heading off feedback off timing off;
                     select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$|tail -1
EOF
)
       fi
     else
       if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
       then
         sqlValue=$( echo "set heading off feedback off timing off;
               select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^\$|tail -1)
       else #remote_database_code
         sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
           export ORACLE_HOME=$ORACLE_HOME
           export ORACLE_SID=$ORACLE_SID; \
           echo "set heading off feedback off timing off;
                     select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba |grep -v ^\$|tail -1
EOF
)
       fi
    fi
 else
     mb_sysdba_user[$mb_db_counter]=$DBUSR
     mb_sysdba_pswd[$mb_db_counter]=$DBPWD 
     if [ $# -eq 3  ]
     then
       if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
       then
         sqlValue=$( echo "set heading off feedback off timing off;
                     select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$|tail -1)
       else #remote_database_code
         sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
           export ORACLE_HOME=$ORACLE_HOME
           export ORACLE_SID=$ORACLE_SID; \
           echo "set heading off feedback off timing off;
               select '$colname = ' ||$colname from $3\$"$2";"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$|tail -1
EOF
)
       fi
     #echo $sqlValue
     #read -p "press any key f"
     else
       if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
       then
         sqlValue=$( echo "set heading off feedback off timing off;
               select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba |grep -v ^\$|tail -1)
       else #remote_database_code
         sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
           export ORACLE_HOME=$ORACLE_HOME
           export ORACLE_SID=$ORACLE_SID; \
           echo "set heading off feedback off timing off;
               select '$colname = '||$colname from $2;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$|tail -1
EOF
)
       fi
    fi
fi
}

multipleSqlValue ()
{
 if [ ${mb_checksysdba[$mb_db_counter]} -eq 1 ]
 then
    if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
    then
      sqlValue=$( echo "set heading off feedback off timing off;
		  $1;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$)
    else #remote_database_code
      sql_stmt=$(echo "$1" | sed 's/\$/\\\$/g')
      sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
	export ORACLE_HOME=$ORACLE_HOME
	export ORACLE_SID=$ORACLE_SID; \
	echo "set heading off feedback off timing off;
		  $sql_stmt;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^\$
EOF
 )
    fi
 else
    mb_sysdba_user[$mb_db_counter]=$DBUSR
    mb_sysdba_pswd[$mb_db_counter]=$DBPWD
    if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
    then
      sqlValue=$( echo "set heading off feedback off timing off;
		  $1;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$)
    else #remote_database_code
      sql_stmt=$(echo "$1" | sed 's/\$/\\\$/g')
      sqlValue=$($SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF
	export ORACLE_HOME=$ORACLE_HOME
	export ORACLE_SID=$ORACLE_SID; \
	echo "set heading off feedback off timing off;
	    $sql_stmt;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^\$
EOF
)
    fi
 fi
}
is_crs_up ()
{
  check_crsd=$(ps -ef |grep -ic "crsd\.bin")
  check_crs=`ps -ef|grep -ic "d.bin"`
  if [ ${check_crs} -ge 4 ]
  then
      crs_up=1
  else
      crs_up=0
  fi
  if [[ ${crs_up} -eq 1 && -n "$check_crsd" && $check_crsd -lt 1 ]]; then oracle_restart=1;else oracle_restart=0;fi
}
is_db_up ()
{
 somebgproc=`echo $bgproc|cut -d_ -f2`
 somebgsid=`echo $bgproc|cut -d_ -f3|cut -d' ' -f1`
 #read -p "$bgproc and $somebgsid somebgproc=$somebgproc"
 if [ `echo $bgproc|grep -c "ora_pmon_$ORACLE_SID"` -ge 1 ]
    then
       db_up=1
       somedb_up=1  
       somedb_up=1  
    elif [ "$somebgproc" = "pmon" ]
    then
        somedb_up=1
        db_up=0
    else
       db_up=0
       somedb_up=0
 fi
       #read -p "db_up=$db_up"
}

#this function is to find out the inventory location dependet on platform
#if no inventory is found , means no CRS and RDBMS is installed
search_invntr_platform ()
{
   if [ $is_exalogic_machine -eq "1" ] ; then return; fi;
  invntr_counter=0
  for invntr in `cat $HOSTLIST`
  do
    case `/bin/uname` in
    Linux)
       v_oratab="/etc/oratab"
       if [ $invntr = $localnode ]
       then
           if [[ -e /etc/oraInst.loc && -z "$RAT_INV_LOC" ]]
           then
	      invntr_location[$invntr_counter]=`cat /etc/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
              if [ -z "${invntr_location[$invntr_counter]}" ] 
                 then   
                 echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
              fi
           elif [[ ! -e /etc/oraInst.loc && -z "$RAT_INV_LOC" ]]
           then 
               read -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
               case $ask_inv_loc in
               y|Y|yes|YES|Yes)
                 echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
                 ;;
               n|N|No|NO)   
                         #read -p "invntr_location= ${invntr_location[$invntr_counter]}"
                 ;;
               *)     
                ;;    
               esac
           else 
              invntr_location[$invntr_counter]=$RAT_INV_LOC
           fi
       else
          $SSHELL $invntr ls -l /etc/oraInst.loc >/dev/null 2>&1
          inv_ptr_exist=$(echo $?) 
          if [[ $inv_ptr_exist -eq 0 && -z "$RAT_INV_LOC" ]]
          then
              invntr_location[$invntr_counter]=`$SSHELL $invntr cat /etc/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
              if [ -z "${invntr_location[$invntr_counter]}" ] 
              then   
                  echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
              fi
          elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
          then 
               read -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
               case $ask_inv_loc in
               y|Y|yes|YES|Yes)
                 echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
                 ;;
               n|N|No|NO)   
                 ;;
               *)     
                ;;    
               esac
          else
              invntr_location[$invntr_counter]=$RAT_INV_LOC
          fi
       fi
    ;;
    SunOS)
       v_oratab="/var/opt/oracle/oratab"
       if [ $invntr = $localnode ]
       then
           if [[ -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
           then
	      invntr_location[$invntr_counter]=`cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
              if [ -z "${invntr_location[$invntr_counter]}" ] 
              then   
                  echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
              fi
           elif [[ ! -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
           then 
               read -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
               case $ask_inv_loc in
               y|Y|yes|YES|Yes)
                 echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
                 ;;
               n|N|No|NO)   
                 ;;
               *)     
                ;;    
               esac
           else
              invntr_location[$invntr_counter]=$RAT_INV_LOC
           fi
       else
          $SSHELL $invntr ls -l /var/opt/oracle/oraInst.loc >/dev/null 2>&1
          inv_ptr_exist=$(echo $?) 
          if [[ $inv_ptr_exist -eq 0 && -z "$RAT_INV_LOC" ]]
          then
              invntr_location[$invntr_counter]=` $SSHELL $invntr cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
              if [ -z "${invntr_location[$invntr_counter]}" ] 
              then   
                  echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
              fi
          elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
          then 
              read -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
              case $ask_inv_loc in
              y|Y|yes|YES|Yes)
               echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                exit 1; 
                ;;
              n|N|No|NO)   
                ;;
              *)     
               ;;    
              esac
              #read -p "inventory found at ${invntr_location[$invntr_counter]}"
          else
              invntr_location[$invntr_counter]=$RAT_INV_LOC
          fi
       fi
    ;;
    HP-UX) 
       v_oratab="/etc/oratab"
       if [ $invntr = $localnode ]
       then
           if [[ -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
           then
	      invntr_location[$invntr_counter]=`cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
              if [ -z "${invntr_location[$invntr_counter]}" ] 
              then   
                  echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
              fi
           elif [[ ! -e /var/opt/oracle/oraInst.loc && -z "$RAT_INV_LOC" ]]
           then 
	       read -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	       case $ask_inv_loc in
	       y|Y|yes|YES|Yes)
		echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
		 exit 1; 
		 ;;
	       n|N|No|NO)   
		 ;;
	       *)     
		;;    
	       esac
           else
              invntr_location[$invntr_counter]=$RAT_INV_LOC
           fi
       else
          $SSHELL $invntr ls -l /var/opt/oracle/oraInst.loc  >/dev/null 2>&1
          inv_ptr_exist=$(echo $?) 
          if [[ $inv_ptr_exist -eq 0 && -z "$RAT_INV_LOC" ]]
          then
              invntr_location[$invntr_counter]=`$SSHELL $invntr cat /var/opt/oracle/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
              if [ -z "${invntr_location[$invntr_counter]}" ] 
              then   
                  echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
              fi
          elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
          then 
	      read -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
	      case $ask_inv_loc in
	      y|Y|yes|YES|Yes)
	       echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
		exit 1; 
	         ;;
	      n|N|No|NO)   
		;;
	      *)     
	       ;;    
	      esac
          else
              invntr_location[$invntr_counter]=$RAT_INV_LOC
          fi
       fi
    ;;
    AIX)
       v_oratab="/etc/oratab"
       if [ $invntr = $localnode ]
       then
           if [[ -f /etc/oraInst.loc && -z "$RAT_INV_LOC" ]]
           then
	      invntr_location[$invntr_counter]=`cat /etc/oraInst.loc|grep -v "#"|grep inventory_loc|cut -d= -f2`
              if [ -z "${invntr_location[$invntr_counter]}" ] 
              then   
                  echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                  exit 1; 
              fi
           elif [[ ! -e /etc/oraInst.loc && -z "$RAT_INV_LOC" ]]
           then 
               read -p "${program_name} did not find the inventory location on $invntr from environment.Does $invntr have Oracle software installed [y/n][n]?" ask_inv_loc
               case $ask_inv_loc in
               y|Y|yes|YES|Yes)
                 echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
                 ;;
               n|N|No|NO)   
                         #read -p "invntr_location= ${invntr_location[$invntr_counter]}"
                 ;;
               *)     
                ;;    
               esac 
           else
              invntr_location[$invntr_counter]=$RAT_INV_LOC
           fi
       else
          $SSHELL $invntr ls -l /etc/oraInst.loc >/dev/null 2>&1
          inv_ptr_exist=$(echo $?) 
          if [[ $inv_ptr_exist -eq 0 && -z $RAT_INV_LOC ]]
          then
              invntr_location[$invntr_counter]=`$SSHELL $invntr cat /etc/oraInst.loc|grep -v "^#"|grep inventory_loc|cut -d= -f2`
              if [ -z "${invntr_location[$invntr_counter]}" ] 
              then   
                  echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                 exit 1; 
              fi
          elif [[ $inv_ptr_exist -ne 0 && -z "$RAT_INV_LOC" ]]
          then 
              case $ask_inv_loc in
              y|Y|yes|YES|Yes)
                echo -e "${RED}${program_name} did not find the inventory location on $invntr from environment.\n\nPlease set RAT_INV_LOC to your global inventory home in current shell to override and re-run it${NORM}.\n\neg export RAT_INV_LOC=/u01/app/oraInventory"
                exit 1; 
                 ;;
              n|N|No|NO)   
                        #read -p "invntr_location= ${invntr_location[$invntr_counter]}"
                ;;
              *)     
               ;;    
              esac 
          else
              invntr_location[$invntr_counter]=$RAT_INV_LOC
          fi
       fi
    ;;
    *)   /bin/echo "ERROR: Unknown Operating System"
        exit -1
    ;;
   esac
   invntr_counter=`expr $invntr_counter + 1 `
done
 invntr_counter=0
}

#this function is to check that CRS is installed or not on all nodes in cluster
is_crs_installed()
{
 search_invntr_platform
 crs_counter=0
 for crs_install in `cat $HOSTLIST`
 do
   unset invntr_CH
   if [ $crs_install = $localnode ]
   then
      if [ -n "${invntr_location[$crs_counter]}" ]
      then
          invntr_CH=`cat ${invntr_location[$crs_counter]}/ContentsXML/inventory.xml |grep "CRS=\"true\""|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'`
          local_invntr_CH=$invntr_CH
	  if [[ -z "$invntr_CH" ||! -d $invntr_CH ||! -f $invntr_CH/bin/crsd ]] && [ -z "$RAT_CRS_HOME" ]
	  then 
	      echo -e "${RED}${program_name} did not find the CRS binaries on $crs_install from environment.\n\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
		  exit 1; 
	  fi
      fi
      if [[  -d $invntr_CH || -n "$RAT_CRS_HOME" ]] 
      then
          if [[ -f $invntr_CH/bin/crsd || -n "$RAT_CRS_HOME" ]]
          then
              crs_installed[$crs_counter]=1
              echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>$MASTERFIL
              if [ -n "$RAT_CRS_HOME" ]
              then 
                  echo "CRS_HOME = $RAT_CRS_HOME" >>$MASTERFIL
                  crsSoftwareOwner=$(ls -l $RAT_CRS_HOME/bin/ocssd 2>/dev/null|awk '{print $3}')
              else  
                  echo "CRS_HOME = $invntr_CH" >>$MASTERFIL
                  #read -p "$nvntr_CH ls -l $invntr_CH/bin/crsd"
                  crsSoftwareOwner=$(ls -l $invntr_CH/bin/ocssd 2>/dev/null|awk '{print $3}')
              fi
              #read -p "userid=$userid"
              root_user_allowed=0
              if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] ; then
                root_user_allowed=1
              fi

              if [[ $root_user_allowed -eq "0" ]] && [[ "$usern" = "root" || $userid -eq 0 ]]
              then
                  echo -e "${RED}${program_name} found that oracle software owner exists and its being run by root."
                  echo -e "\nPlease change ownership and permission for ${program_name} and all accompanied files being root to rdbms software owner,login as rdbms software owner and run it again\n${NORM}"
                  exit 1
              fi
          else
             crs_installed[$crs_counter]=0
             echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>$MASTERFIL
          fi
      else
          crs_installed[$crs_counter]=0  
          echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>$MASTERFIL
      fi
   else
      if [ -n "${invntr_location[$crs_counter]}" ]
      then
          invntr_CH=`$SSHELL $crs_install cat ${invntr_location[$crs_counter]}/ContentsXML/inventory.xml |grep "CRS=\"true\""|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'`
      #read -p "inventory laction ${invntr_location[$crs_counter]} and CRS_HOME $invntr_CH"
	  $SSHELL $crs_install ls -l $invntr_CH >/dev/null 2>&1
	  remote_crs_home_status=$(echo $?) 
	  if [[ $remote_crs_home_status -ne 0 &&  -z "$RAT_CRS_HOME" ]]
	  then
	      echo -e "${RED}${program_name} did not find the CRS binaries on $crs_install from environment.\n\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
	      exit 1;
	  fi
      fi
	  if [[ $remote_crs_home_status -eq 0 || -n "$RAT_CRS_HOME" ]] 
	  then
	      $SSHELL $crs_install ls -l $invntr_CH/bin/crsd >/dev/null 2>&1
	      remote_crsd_file_status=$(echo $?)
	      if [[ $remote_crsd_file_status -ne 0 &&  -z "$RAT_CRS_HOME" ]]
	      then
                  echo -e "${RED}${program_name} did not find the CRS binaries on $crs_install from environment.\n\nPlease set RAT_CRS_HOME to CRS_HOME or GI_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_CRS_HOME=/u01/app/11.2.0/grid"
	          exit 1;
              fi
	      if [[ $remote_crsd_file_status -eq 0 || -n "$RAT_CRS_HOME" ]]
	      then
		  crs_installed[$crs_counter]=1
		  echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
	      else
		 crs_installed[$crs_counter]=0
		 echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
	      fi
	  else
	      crs_installed[$crs_counter]=0  
	      echo $crs_install.CRS_INSTALLED = ${crs_installed[$crs_counter]}>>$MASTERFIL
          fi
   fi
  #read -p "crs installed at on $crs_install ${crs_installed[$crs_counter]}"
 crs_counter=`expr $crs_counter + 1`
 done
 crs_counter=0
}


function is_valid_ohome
{
  export ORACLE_SID=$1
  export ORACLE_HOME=$2
  export LD_LIBRARY_PATH=$ORACLE_HOME/lib
  if [ ! -e "$ORACLE_HOME/bin/sqlplus" ] ; then
    valid_ohome=0
    return;
  fi
  iname=`echo 'set feedback  off heading off lines 120 
        select INSTANCE_NAME from     gv\$instance;' | $ORACLE_HOME/bin/sqlplus -s "/as sysdba" |  grep -v ^$ 2>&1`
  if [[ $iname = $ORACLE_SID || `echo "$iname" | grep -ic "insufficient privileges"` -gt 0 ]] ; then
    valid_ohome=1
    what_db=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
    if [[ -n "$what_db" && $what_db -gt "$latest_si_version" ]] ; then
      latest_si_version=$what_db
    fi
  else
    valid_ohome=0
  fi
}

function search_oh_si()
{
  # Search config file ${program_name}_homes.conf
  oconf_file="${program_name}_homes.conf"
  if [ -e "$oconf_file" ] ; then
    if [[ `cat $oconf_file | grep -ic "$sid|"` -gt 0 ]] ; then
      oh=$(grep "$sid|" $oconf_file | head -1 | cut -d'|' -f2)
      valid_ohome=0
      in_conf=1
      is_valid_ohome $sid $oh
      if [ $valid_ohome -eq 1 ] ; then found_in="c"; return; fi;
    fi
  fi

  # oratab
  oh=$(cat /etc/oratab |grep ":/" |grep -v "+"|grep -v "^#"|grep -w "$sid:" |cut -d: -f2)
  if [[ -n "$oh" && "$oh" ]]
  then
    valid_ohome=0
    is_valid_ohome $sid $oh
    if [ $valid_ohome -eq 1 ] ; then
      found_in="oratab";
      return;
    fi;
  fi

  # If pmap exists, try parsing pmap output
  pmap_found=$(which pmap >/dev/null 2>&1;echo $?)
  if [[ -n "$pmap_found" && $pmap_found -eq "0"  ]] ; then
    ppid=$(ps -ef |grep "ora_pmon_$sid"|grep -v grep |awk '{print $2}')
    oh=$(pmap $ppid  | grep bin/oracle | awk '{print $NF}' | sort -u | sed 's/\/bin\/oracle//');
    is_valid_ohome $sid $oh
    if [ $valid_ohome -eq 1 ] ; then found_in="pmap"; return; fi;
  fi

  # Ask user if we are not in silent mode.
  attempt_cnt=3
  while [[ $attempt_cnt -ge "0" ]] ; do
    printf "Enter ORACLE_HOME for $sid : "
    read oh
    valid_ohome=0
    if [ -n "$oh" ] ; then
      is_valid_ohome $sid $oh
      if [ $valid_ohome -eq 1 ] ; then found_in="input"; return; fi;
    fi
    if [[ $attempt_cnt -gt "0" ]] ; then
      echo "Could not login to $sid using $oh. Try again ($attempt_cnt attempts remaining)"
    else
      echo "Skipping database $sid"
    fi
    attempt_cnt=$(expr $attempt_cnt - 1)
  done
  oh=""
}

function save_to_conf ()
{
  if [[ $in_conf -eq "1" && $found_in = "c" ]] ; then
    return; # Valid one in conf file
  fi
  if [[ $in_conf -eq "0" ]] ; then
    echo "$sid|$oh" >> $oconf_file
  else
    grep -v "$sid|" $oconf_file > $oconf_file.bak
    echo "$sid|$oh" >> $oconf_file.bak
    mv -f $oconf_file.bak $oconf_file
  fi
}

function search_si ()
{
  cnt=0
  latest_si_version=0
  for sid in `ps -ef |grep ora_pmon|grep -v grep |awk '{print $NF}'`
  do
    sid=$(echo $sid | sed 's/ora_pmon_//')
    oh=""
    in_conf=0
    search_oh_si
    if [ -n "$oh" ] ; then
      save_to_conf 
      sids_si[$cnt]=$sid
      homes_si[$cnt]=$oh
      if [[ -z "$RAT_DBNAMES" || `echo $RAT_DBNAMES | grep -ic $sid` -eq "0" ]]
      then # Add to RAT_DBNAMES If not exists
        RAT_DBNAMES="$RAT_DBNAMES $sid";
        RAT_DBHOMES="$RAT_DBHOMES $oh";
      fi
      cnt=$(expr $cnt + 1)
    fi
  done
}


function get_ohome_si_oh ()
{
  i_sid=$1
  l_cnt=0
  for l_sid in "${sids_si[@]}"
  do
    if [ "$l_sid" = "$i_sid" ] ; then
      l_oh=${homes_si[$l_cnt]}
      return;
    fi
    l_cnt=$(expr $l_cnt + 1);
  done
}

# Check for rdbms installation location for single instance db
function is_rdbms_installed_si()
{
  if [[ -z "$RAT_DBNAMES" ]] ; then
    search_si
    if [[ $latest_si_version -gt 0 && -z "$RAT_DB" ]] ; then
      RAT_DB=$latest_si_version
    fi
  fi
  #if [ "$TYP" != "-r" ]; then TYP="-b";fi
  rdbms_counter=0
  #RAT_DB=112030
  crs_up=0
  crs_installed=0
  crs_installed[0]=0
  asm_installed[0]=0
  stack_crs_up[0]=0
  echo $localnode.CRS_INSTALLED = 0 >> $MASTERFIL
  echo SINGLE_INSTANCE_RUN = 1 >> $MASTERFIL

  stack_counter=0
  mb_running_host[0]=$localnode
}


#this function is to check that RDBMS is installed or not on all nodes in cluster
is_rdbms_installed()
{
 #search_invntr_platform
 rdbms_counter=0
 for rdbms_install in `cat $HOSTLIST`
 do
   unset invntr_OH
   if [ $rdbms_install = $localnode ] 
   then
      if [ -n "${invntr_location[$rdbms_counter]}" ]
      then
          for invntr_OH in `cat ${invntr_location[$rdbms_counter]}/ContentsXML/inventory.xml |grep LOC|grep -v "CRS=\"true\""|grep -iv ASM|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'`
          do
            if [[  -d $invntr_OH || -n "$RAT_ORACLE_HOME" ]] 
            then
                if [[ -f $invntr_OH/bin/oracle || -n "$RAT_ORACLE_HOME" ]]
                then
                    oratab_OH=$(cat $v_oratab|grep ":/" |grep -v "+"|grep -v "^#"|head -1 |cut -d: -f2)
                    if [[ -n "$oratab_OH" && $invntr_OH = $oratab_OH ]]
                    then
                        rdbms_installed[$rdbms_counter]=1
                        #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
                        local_invntr_OH=$invntr_OH
                        break
                    fi
                else
                   rdbms_installed[$rdbms_counter]=0
                   #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
                fi
            else
               rdbms_installed[$rdbms_counter]=0  
               #echo $rdbms.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
            fi
          done
          if [ ${rdbms_installed[$rdbms_counter]} -eq 1 ]
          then
              echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
          else
              echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
          fi
      else
         rdbms_installed[$rdbms_counter]=0
         echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
      fi
   else
      if [ -n "${invntr_location[$rdbms_counter]}" ]
      then
          for invntr_OH in `$SSHELL $rdbms_install cat ${invntr_location[$rdbms_counter]}/ContentsXML/inventory.xml |grep LOC|grep -v "CRS=\"true\""|grep -iv ASM|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'` 
          do
            $SSHELL $rdbms_install ls -l $invntr_OH >/dev/null 2>&1
            if [[ $? -eq 0  || -n "$RAT_ORACLE_HOME" ]] 
            then
                $SSHELL $rdbms_install ls -l $invntr_OH/bin/oracle >/dev/null 2>&1
                if [[ $? -eq 0 || -n "$RAT_ORACLE_HOME" ]]
                then
                    oratab_OH=$($SSHELL $rdbms_install cat $v_oratab|grep ":/" |grep -v "+"|grep -v "^#"|head -1 |cut -d: -f2)
                   if [[ -n "$oratab_OH" && $invntr_OH = $oratab_OH ]]
                    then
                        rdbms_installed[$rdbms_counter]=1
                        #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
                        break
                    fi
                else
                    rdbms_installed[$rdbms_counter]=0
                    #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
                fi
            else
                rdbms_installed[$rdbms_counter]=0  
                #echo $rdbms_install.RDBMS_INSTALLED = ${rdbms_installed[$rdbms_counter]}>>$MASTERFIL
            fi
          done
          if [ ${rdbms_installed[$rdbms_counter]} -eq 1 ]
          then
              echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
          else
              echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
          fi
      else
         rdbms_installed[$rdbms_counter]=0
         echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
      fi
   fi
   #read -p "crs installed on $rdbms_install=${crs_installed[$rdbms_counter]}"
   rdbms_counter=`expr $rdbms_counter + 1`
 done
 if [ -n "$oratab_OH" ]
 then
    export ORACLE_HOME=$oratab_OH
    what_db=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
    echo "$oratab_OH|$what_db" >>$OUTPUTDIR/mb_db_homes_distinct.out
 fi
 mb_set_oracle_home_version_distinct 
 rdbms_counter=0
}

is_asm_installed()
{
 #search_invntr_platform
 asm_counter=0
 for asm_install in `cat $HOSTLIST`
 do
   unset invntr_AH
   if [ $asm_install = $localnode ] 
   then
      if [ -n "${invntr_location[$asm_counter]}" ]
      then
          invntr_AH=`cat ${invntr_location[$asm_counter]}/ContentsXML/inventory.xml |grep LOC|grep -v "CRS=\"true\""|grep -v db|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'|head -1`
#	  if [[ -z "$invntr_AH" || ! -d $invntr_AH || ! -e $invntr_AH/bin/oracle ]] && [ -z "$RAT_ASM_HOME" ]
#	  then
#	      echo -e "${RED}Raccheck did not find the ASM binaries on $asm_install from environment.\n\nPlease set RAT_ASM_HOME to ASM_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ASM_HOME=/u01/app/oracle/product/11.1.0/asm_1"
#	      exit 1;
#	  fi
      fi
      if [[  -d $invntr_AH || -n "$RAT_ASM_HOME" ]] 
      then
          if [[ -f $invntr_AH/bin/oracle || -n "$RAT_ASM_HOME" ]]
          then
              asm_installed[$asm_counter]=1
              echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
          else
             asm_installed[$asm_counter]=0
             echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
          fi
      else
          asm_installed[$asm_counter]=0  
          echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
      fi
   else
      if [ -n "${invntr_location[$asm_counter]}" ]
      then
          invntr_AH=`$SSHELL $asm_install cat ${invntr_location[$asm_counter]}/ContentsXML/inventory.xml |grep LOC|grep -v "CRS=\"true\""|grep -vi db|grep -vi agent|grep -v "REMOVED=\"T\""|awk '{print $3}'|cut -d= -f2|sed 's/\"//g'|head -1` 
	  $SSHELL $asm_install ls -l $invntr_AH >/dev/null 2>&1
	  remote_asm_home_status=$(echo $?)
#	  if [[ $remote_asm_home_status -ne 0 &&  -z "$RAT_ASM_HOME" ]]
#	  then
#	      echo -e "${RED}Raccheck did not find the ASM binaries on $asm_install from environment.\n\nPlease set RAT_ASM_HOME to ASM_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ASM_HOME=/u01/app/oracle/product/11.1.0/asm_1"
#	      exit 1;
#	  fi
      fi
      if [[ $remote_asm_home_status -eq 0  || -n "$RAT_ASM_HOME" ]] 
      then
          $SSHELL $asm_install ls -l $invntr_AH/bin/oracle >/dev/null 2>&1
          remote_asmd_file_status=$(echo $?)
#	  if [[ $remote_asmd_file_status -ne 0 &&  -z "$RAT_ASM_HOME" ]]
#	  then
#	      echo -e "${RED}Raccheck did not find the ASM binaries on $asm_install from environment.\n\nPlease set RAT_ASM_HOME to ASM_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ASM_HOME=/u01/app/oracle/product/11.1.0/asm_1"
#	      exit 1;
#	  fi
          if [[ $remote_asmd_file_status -eq 0 || -n "$RAT_ASM_HOME" ]]
          then
              asm_installed[$asm_counter]=1
              echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
          else
             asm_installed[$asm_counter]=0
             echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
          fi
      else
          asm_installed[$asm_counter]=0  
          echo $asm_install.ASM_INSTALLED = ${asm_installed[$asm_counter]}>>$MASTERFIL
      fi
   fi
   #read -p "crs installed on $rdbms_install=${crs_installed[$rdbms_counter]}"
   asm_counter=`expr $asm_counter + 1`
 done
 asm_counter=0
}
is_rdbms_installed_crs ()
{
#search_invntr_platform
rdbms_counter=0
db_list_from_env=0
db_list_fil=$INPUTDIR/db_list.out 
db_config_fil=$INPUTDIR/db_config.out
running_db_list=$INPUTDIR/running_db_list.out
running_db_host_list=$INPUTDIR/running_db_host_list.out
touch $running_db_list
touch $running_db_host_list
running_group=$(id|awk '{print $2}'|cut -d'(' -f2|cut -d')' -f1)
db_counter=1
#if [ -z "$RAT_DBNAMES" ];then RAT_DBHOMES=$RAT_DBNAMES;fi
if [[ ${crs_up} = 1 && $check_crs_stat -eq 0 ]] || [[ $single_instance_run -eq "1" ]]
then
   if [[ -z "$RAT_DBNAMES" &&  -z "$RAT_DBHOMES" && $single_instance_run -eq "0" ]]
   then
     if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] ; then
       touch $db_list_fil
       db_list_from_env=1
     else
       $CRS/bin/srvctl config database > $db_list_fil
       db_list_from_env=1
     fi
   else 
       db_list_from_env=0
       if [[ -z "$RAT_DBHOMES" &&  -n "$RAT_DBNAMES" ]]
       then
	   for db_list in $RAT_DBNAMES
	   do
	      echo $db_list >> $running_db_list
	      echo ":$db_list:$localnode" >> $running_db_host_list
	      echo $db_list >> $db_list_fil
	      db_counter=$(expr ${db_counter} + 1)
	   done
       elif [[ -n "$RAT_DBHOMES" &&  -n "$RAT_DBNAMES" ]]
       then
           for db_list in $RAT_DBNAMES
           do
              echo $db_list >> $running_db_list
	      echo ":$db_list:$localnode" >> $running_db_host_list
              echo $db_list >> $db_list_fil
              db_counter=$(expr ${db_counter} + 1)
           done
           #for db_list in $RAT_DBHOMES
           #do
           #  echo $db_list >> $db_list_fil
           #done
       elif [[ -z "$RAT_DBNAMES" && -n "$RAT_DBHOMES" ]]
       then
           for db_list in $RAT_DBNAMES
           do
              #echo $db_list >> $running_db_list
              echo $db_list >> $db_list_fil
              db_counter=$(expr ${db_counter} + 1)
           done
       fi
   fi
   if [ $db_list_from_env -eq 1 ]
   then
       echo -e "\nSearching for running databases . . . . .\n"
       for db_list in `cat $db_list_fil`
       do 
	   #if [[ -n "$crs112" && $crs112 -ge 1 ]]
	   #then 
              printf ". "
               
               crs_db_hosts=$($CRS/bin/srvctl status database -d $db_list|grep -i "is running" | awk '{print $NF}')
               if [[ -n "$crs_db_hosts" && $crs_db_hosts = "running." ]]
               then
                 crs_db_hosts=$localnode
               fi
               crs_db_status=$($CRS/bin/srvctl status database -d $db_list|grep -ic "is running")  
               #echo "$? for $db_list and crs_db_status= $crs_db_status"
               if [[ -n "$crs_db_status" && $crs_db_status -ge 1  ]]
               then 
                   crs_db_status=$(echo $crs_db_hosts| grep -ic $localnode)
                   if [ $crs_db_status -eq 1 ]
                   then
                     echo $db_list >>$running_db_list;
                     echo ":$db_list:$localnode" >>$running_db_host_list;
                   else # Not running local node. get remote node
                    if [[ -n $localonly && $localonly -eq "0" ]] ; then
                      #crs_db_running_host=$(echo $crs_db_hosts| head -1 | awk '{print $1}')
                      for crs_db_running_host in $(echo $crs_db_hosts)
                      do
                        if [[ -n "$crs_db_running_host" && `grep -ic "$crs_db_running_host" $HOSTLIST` -gt "0" ]]
                        then
                          echo $db_list >>$running_db_list;
                          echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
                          break;
                        #else
                        #  echo "$db_list: $crs_db_running_host is not selected"
                        fi;
                      done 
                    fi
                   fi;
               else
                   crs_db_home=$($CRS/bin/srvctl status database -d $db_list|grep PRKR-1078|awk '{ print $NF }')
                   if [ -z "$crs_db_home" ];then crs_db_home=$($CRS/bin/srvctl status database -d $db_list|grep PRCD-1229|awk '{ printf "%s",substr($NF,1,length($NF)-1) }');fi
                   #read -p "$db_list and $crs_db_home"
                   if [ -n "$crs_db_home" ]; then export ORACLE_HOME=$crs_db_home;crs_db_status=$($ORACLE_HOME/bin/srvctl status database -d $db_list|grep -i $localnode | grep -ic "is running");fi;
                   if [ $crs_db_status -ge 1 ]
                   then #database instance running in localhost
                     echo $db_list >>$running_db_list;
                     echo ":$db_list:$localnode" >>$running_db_host_list;
                   elif [ -n "$ORACLE_HOME" ] # Not running local node. get remote node
                   then 
                    if [[ -n $localonly && $localonly -eq "0" ]] ; then
                     #crs_db_running_host=$($ORACLE_HOME/bin/srvctl status database -d $db_list|grep -i "is running"| head -1 | awk '{print $NF}')
                     crs_db_hosts=$($ORACLE_HOME/bin/srvctl status database -d $db_list|grep -i "is running" | awk '{print $NF}')
                      for crs_db_running_host in $(echo $crs_db_hosts)
                      do
                        if [[ -n "$crs_db_running_host" && `grep -ic "$crs_db_running_host" $HOSTLIST` -gt "0" ]]
                        then
                          echo $db_list >>$running_db_list;
                          echo ":$db_list:$crs_db_running_host" >>$running_db_host_list;
                          break;
                        #else
                        #  echo "$db_list: $crs_db_running_host is not selected"
                        fi;
                     done
                    fi
                   fi;
                   printf ". "
               fi
	       #db_list_lower=$(echo $db_list|tr '[:upper:]' '[:lower:]') 
    #           echo "localnode=$localnode"
	       #db_status=$($CRS/bin/crsctl status resource ora.${db_list_lower}.db |grep -i state|grep $localnode|grep -ic online)
	       #if [[ -z "$db_status" || $db_status -lt 1 ]]; then db_status=$($CRS/bin/crsctl status resource ora.${db_list}.db |grep -i state|grep $localnode|grep -ic online); fi;
	   #else
	       #db_status=$($CRS/bin/crs_stat ora.${db_list}.db |grep -i state|grep $localnode|grep -ic online)
	       #db_status=$($CRS/bin/crs_stat ora.${db_list}.db |grep -i state|grep -ic online)
	   #fi 
	   #if [[ -n "$db_status" && $db_status -ge 1 ]]; then echo $db_list >>$running_db_list; fi
       done
       no_of_databases=$(cat $running_db_list|wc -l)
       if [[ `cat $db_list_fil|sed '/^$/d'|wc -l` -ge 1 && $no_of_databases -lt 1 && `ps -ef |grep ora_pmon|grep -v grep|wc -l` -gt 0 ]]
       then
           echo -e "\n\n${RED}$program_name could not determine status of databases registered in clusterware to check best practices.Set environment variable RAT_DBNAMES to name of the database and re-run.${NORM}\n\nlike export RAT_DBNAMES=\"TESTDB,PRODDB\"\n" 
           exit 0
       elif [[ `cat $db_list_fil|sed '/^$/d'|wc -l` -lt 1 && `ps -ef |grep ora_pmon|grep -v grep|wc -l` -gt 0 ]]
       then
         if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] ; then
           echo
         else
           echo -e "\n\n${RED}Databases are not registered in Clusteware to check best practices.Set environment variable RAT_DBNAMES to name of the database and re-run.${NORM}\n\nlike export RAT_DBNAMES=\"TESTDB,PRODDB\"\n" 
           exit 0
         fi
       fi

   #else
   #    if [ -z "$RAT_DBHOMES" ];then cat $db_list_fil >$running_db_list;fi
   fi

 #cat $db_list_fil
 #cat $running_db_list
#read -p "running db list"
   #if [[ -f $running_db_list && `cat $running_db_list|wc -l` -ge 1 ]]; then cp $running_db_list $db_list_fil;fi;
   no_of_databases=$(cat $running_db_list|wc -l)
   #read -p "stop"
   if [[ $single_instance_run -eq "1" ]] ; then
     db_list_from_env=1
     db_counter=1
   fi
   if [[ $no_of_databases -ge 1 && `cat $running_db_list|wc -l` -ge 1 && $db_list_from_env -eq 1 ]]
   then
       if [[ $single_instance_run -eq "0" ]] ; then
         echo -e "\nList of running databases registered in OCR"
       else
         echo -e "\nList of running databases"
       fi
       for db_list in `cat $running_db_list`
       do 
	  echo "${db_counter}. $db_list"
          db_counter=$(expr ${db_counter} + 1)
       done
       if [ $no_of_databases -gt 1 ]; then echo -e "${db_counter}. All of above";db_counter_none=$(expr $db_counter + 1 );else db_counter_none=$db_counter;db_counter=$(expr ${db_counter} - 1);fi
       #db_counter_none=$(expr $db_counter + 1 )
       echo -e "$db_counter_none. None of above\n"  
       if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]
       then
         ask_question2user=1
         if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] ; then
           ask_question2user=0; #No need toask user for db if no db checks
           db_to_check=${db_counter_none}
         fi
         if [[ $ask_question2user -eq "1" ]] ; then
           read -p "Select databases from list for checking best practices. For multiple databases, select ${db_counter} for All or comma separated number like 1,2 etc [1-${db_counter_none}][${db_counter}]." db_to_check
         fi
       else
           db_to_check=$db_counter
       fi
       db_to_check=$(echo $db_to_check|sed 's/[a-zA-Z]//g')
       comma_ent=`echo $db_to_check |grep "," | wc -l`
       if [  $comma_ent -ge 1 ];then
          case_check=comma_or_single_db
       else
          if [ -z $db_to_check ];then
             case_check=all
          else
             if [ $db_to_check -eq ${db_counter_none} ];then
                case_check=none
             elif [ $db_to_check -eq ${db_counter} ];then
                case_check=all
             elif [ $db_to_check -lt ${db_counter} ];then
                case_check=comma_or_single_db
             else
                case_check=other
             fi
          fi
       fi
       case  $case_check in
             none)
               for db_list in `cat $running_db_list`
               do
                   mb_db_names[$rdbms_counter]=$db_list
                   #echo "${mb_db_names[$rdbms_counter]}"
                   rdbms_counter=$(expr ${rdbms_counter} + 1 )
               done
               db_name_to_check=${mb_db_names[0]}
               multiple_db=1  
               db_name_to_check_none=1
               rdbms_counter=0
               mb_set_oracle_homes
             ;;
             all)
               for db_list in `cat $running_db_list`
               do
                   mb_db_names[$rdbms_counter]=$db_list
                   rdbms_counter=$(expr ${rdbms_counter} + 1 )
               done
               db_name_to_check=${mb_db_names[0]}
               if [ $rdbms_counter -gt 1 ]
               then
                   multiple_db=1
               else
                   multiple_db=0
               fi
               rdbms_counter=0
               mb_set_oracle_homes  
               db_name_to_check_all=1
             ;;
             comma_or_single_db)
               if [ `echo $db_to_check|wc -c` -gt 2 ]
               then
                  if [ -n "$IFS" ]; then old_ifs=$IFS;IFS=$',';fi;
                  for db_to_check_ifs in $db_to_check 
                  do
                      db_to_check_ifs=$(echo $db_to_check_ifs|sed 's/[a-zA-Z,\*\.;|?/]//g')
                      if [[ -n "$db_to_check_ifs" && $db_to_check_ifs -lt $db_counter ]]
                      then
			  db_name_to_check=$(cat $running_db_list|sed -n ''${db_to_check_ifs}'p')  
			  mb_db_names[$rdbms_counter]=$db_name_to_check
			  #read -p "db_name_to_check=$db_name_to_check"
			  rdbms_counter=$(expr ${rdbms_counter} + 1 )
                      fi
                  done
                  if [ -n "$old_ifs" ]; then IFS=$old_ifs;else IFS=$'\n';fi;
                  db_name_to_check=${mb_db_names[0]}
                  multiple_db=1
                  rdbms_counter=0
                  mb_set_oracle_homes 
                  #echo "${mb_db_names[@]}"
               else
		  db_name_to_check=$(cat $running_db_list|sed -n ''${db_to_check}'p')  
		  mb_db_names[$rdbms_counter]=$db_name_to_check
		  mb_set_oracle_homes 
		  multiple_db=0
               fi
             ;;
             
           *)
               for db_list in `cat $running_db_list`
               do
                   mb_db_names[$rdbms_counter]=$db_list
                   #echo "${mb_db_names[$rdbms_counter]}"
                   rdbms_counter=$(expr ${rdbms_counter} + 1 )
               done
               db_name_to_check=${mb_db_names[0]}
               multiple_db=1
               rdbms_counter=0
               db_name_to_check_all=1
               mb_set_oracle_homes 
            ;;      
       esac
   
   elif [[ $no_of_databases -gt 1 && `cat $running_db_list|wc -l` -ge 1 && $db_list_from_env -eq 0 ]]
   then
       for db_list in `cat $running_db_list`
       do
          mb_db_names[$rdbms_counter]=$db_list
          #echo "${mb_db_names[$rdbms_counter]}"
           rdbms_counter=$(expr ${rdbms_counter} + 1 )
           done
       db_name_to_check=${mb_db_names[0]}
       multiple_db=1
       rdbms_counter=0
       mb_set_oracle_homes 
   else
       rdbms_counter=0
       if [[ -n "$no_of_databases" && $no_of_databases -gt 0 ]]
       then
	   db_name_to_check=$(cat $running_db_list|sed -n '1p')
	   mb_db_names[$rdbms_counter]=$db_name_to_check
       fi
       mb_set_oracle_homes 
       multiple_db=0
   fi

#commented for time being because have plan to support multiple version in upgrade

   #read -p "DB Name selected =$db_name_to_check"  
   #if [[ $upgrade_mode -gt 1 && -e $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out && `cat $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out|wc -l ` -gt 1 ]]
   #then
   #    echo -e "${RED}you selected multiple version of database which is not supported for upgrade best practice checking. Please select same version databases from list${NORM}\n\n"
   #    echo -e "you selected:-\n\n"
   #    cat $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out
   #    echo -e "\n\n"
   #    #exit 1
   #fi


   if [ -n "$db_name_to_check" ]
   then
      #db_name_to_check=$(echo $db_name_to_check|tr '[:upper:]' '[:lower:]')
        
      if [[ -n "$crs112" && $crs112 -ge 1 ]] 
      then
          db_name_to_check_lower=$(echo $db_name_to_check|tr "[A-Z]" "[a-z]")
          $CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p > $db_config_fil
          if [[ -e $db_config_fil && `cat $db_config_fil|grep -ci "Could not find resource"` -ge 1 ]]; then  $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p > $db_config_fil;fi;
      else
        if [[ $single_instance_run -eq "0" ]] ; then
          $CRS/bin/srvctl config database -d $db_name_to_check -a > $db_config_fil 
         else
           l_oh="";
           get_ohome_si_oh $db_name_to_check
           echo "ORACLE_HOME=$l_oh" > $db_config_fil
         fi
      fi
   fi
   for rdbms_install in `cat $HOSTLIST`
   do
     unset invntr_OH
     if [ $rdbms_install = $localnode ]
     then
         if [ -e $db_config_fil ]; then  crs_OH=$(cat $db_config_fil|grep -w ORACLE_HOME|cut -d: -f2|sed 's/ //g');fi
         crs_OH=$(echo $crs_OH|cut -d= -f2|sed 's/ //g')
         if [ -z "$crs_OH" ]; then crs_OH=$ORACLE_HOME; fi;
         if [ -n "${invntr_location[$rdbms_counter]}" ]
         then
                if [[ -z "$crs_OH" || ! -d $crs_OH ||  ! -e $crs_OH/bin/oracle ]] && [ -z "$RAT_ORACLE_HOME" ] 
                then
                  if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] ; then
                    echo
                  else
	            echo -e "${RED}${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\n\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
                    exit 1;
                  fi
                fi
             if [[ -d $crs_OH || -n "$RAT_ORACLE_HOME" ]]
             then
                if [[ -f $crs_OH/bin/oracle || -n "$RAT_ORACLE_HOME" ]]
                then
                    rdbms_installed[$rdbms_counter]=1
                    local_invntr_OH=$crs_OH
                else
                    rdbms_installed[$rdbms_counter]=0
                fi
             else
                 rdbms_installed[$rdbms_counter]=0
             fi
             if [ ${rdbms_installed[$rdbms_counter]} -eq 1 ]
             then
                 echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
                 rbdmsSoftwareOwner=$(ls -l ${local_invntr_OH}/bin/oracle 2>/dev/null|awk '{print $3}')
                 #read -p "rbdmsSoftwareOwner=$rbdmsSoftwareOwner usern=$usern crsSoftwareOwner=$crsSoftwareOwner" 
                 if [[ -n "$crsSoftwareOwner" && -n "$rbdmsSoftwareOwner" && "$crsSoftwareOwner" != "$rbdmsSoftwareOwner" && "$usern" = "$crsSoftwareOwner" ]]
                 then
                     echo -e "${RED}You have run ${program_name} as the clusterware software owner. ${program_name} is intended to be run as an RDBMS software owner (eg., oracle with ownership and group eg., oracle:oinstall)."
                     echo -e "\nPlease run ${program_name} as an RDBMS software owner and with ownership as described above.\n${NORM}"
                     exit 1
                 fi
             else
                 echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
             fi
         else
             rdbms_installed[$rdbms_counter]=0
             echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
         fi
     else
         if [ -n "${invntr_location[$rdbms_counter]}" ]
         then
             $SSHELL $rdbms_install ls -l $crs_OH >/dev/null 2>&1
             remote_rdbms_home_status=$(echo $?)
             if [[ $remote_rdbms_home_status -ne 0 && -z "$RAT_ORACLE_HOME" ]] 
             then
               if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] ; then
                 echo
               else
	         echo -e "${RED}${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\n\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
                 exit 1;
               fi
             fi
             if [[ $remote_rdbms_home_status -eq 0 || -n "$RAT_ORACLE_HOME" ]]
             then 
                 $SSHELL $rdbms_install ls -l $crs_OH/bin/oracle >/dev/null 2>&1
                 remote_oracle_file_status=$(echo $?)
                 if [[ $remote_oracle_file_status -ne 0  && -z "$RAT_ORACLE_HOME" ]] 
                 then
                   if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_db_checks -eq "0" ]] ; then
                     echo
                   else
	             echo -e "${RED}${program_name} did not find the RDBMS binaries on $rdbms_install from environment.\n\nPlease set RAT_ORACLE_HOME to ORACLE_HOME in current shell to override and re-run it.${NORM}\n\neg export RAT_ORACLE_HOME=/u01/app/oracle/product/11.2.0/db_1"
                     exit 1;
                   fi
                 fi
                 if [[ $remote_oracle_file_status -eq 0  || -n "$RAT_ORACLE_HOME" ]]
                 then
                     rdbms_installed[$rdbms_counter]=1
                 else
                     rdbms_installed[$rdbms_counter]=0
                 fi
             else
                 rdbms_installed[$rdbms_counter]=0
             fi
             if [ ${rdbms_installed[$rdbms_counter]} -eq 1 ]
             then
                 echo "$rdbms_install.RDBMS_INSTALLED = 1" >>$MASTERFIL
             else
                  echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL
             fi
         else
            rdbms_installed[$rdbms_counter]=0
            echo "$rdbms_install.RDBMS_INSTALLED = 0" >>$MASTERFIL   
         fi
     fi # localnode if ends here
     rdbms_counter=`expr $rdbms_counter + 1`
   done 
   rdbms_counter=0  
else
    is_rdbms_installed
    echo "is_rdbms_installed was called because CRS was down on local node">>$LOGFIL
    multiple_db=0
fi
#read -p "stop did not find the RDBMS binaries on"
}

# Added to capture the host name where database is running
#remote_database_code
mb_set_running_hosts ()
{
  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do 
    mb_host_name=$(grep ":$db_name_to_check:" $running_db_host_list | awk -F":" '{print $3}');
    if [ -z "$mb_host_name" ]
    then 
      mb_host_name=$localnode
    fi
    mb_running_host[$mb_db_counter]="$mb_host_name"
    if [[ -n $RAT_DEBUG_V ]]
    then
      echo "Running host for $db_name_to_check:*** $mb_host_name";
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
}
check_pdb_password()
{
 pdb_check_password_count=3
 pdb_check_password_status=0

 while [[ $pdb_check_password_count -gt 0  && $pdb_check_password_status -eq 0 ]]
 do
   echo ""
   printf "Enter ${RAT_PDB_USER} user password for $pdb_name pluggable database.${pdb_check_password_count} tries remaining:-"
   stty -echo
   read -r pdb_sys_password
   stty echo
   echo ""
   pdb_check_password_message=$(echo "select 'LoginSuccessFull' from dual;"|$ORACLE_HOME/bin/sqlplus  ${RAT_PDB_USER}/$pdb_sys_password@"${mb_pdb_connect_string[$mb_pdb_counter]}" as sysdba) 
   if [ $(echo "$pdb_check_password_message"|grep -wc "LoginSuccessFull") -ge 1 ]
   then
        pdb_check_password_status=1
   else 
       pdb_check_password_status=0
       if [ $pdb_check_password_count -gt 1 ]
       then   
           echo ""
           echo ""
           echo -e "${RED}${RAT_PDB_USER} password is wrong for $pdb_name pluggable database${NORM}" 
       fi
   fi
   pdb_check_password_count=$( expr $pdb_check_password_count - 1)
 done
 if [ $pdb_check_password_status -eq 0 ]
 then
     echo ""
     echo -e "${RED}sys password validation failed for $pdb_name pluggable database. removing from list of databases to check best practices${NORM}"   
 fi
}
mb_set_oracle_homes ()
{
if [ $no_of_databases -gt 1 ]; then  echo -e "\nSearching out ORACLE_HOME for selected databases.\n";fi
  mb_set_running_hosts; #remote_database_code
 mb_db_counter=0
 mb_db_counter_upgraded=0
 mb_db_counter_need_upgrade=0
 validate_oracle_home_tries=0
 mb_pdb_counter=0
 for db_name_to_check in "${mb_db_names[@]}"
 do 
    printf ". "
    if [[ -n "$crs112" && $crs112 -ge 1 ]]
    then
         db_name_to_check_lower=$(echo $db_name_to_check|tr "[A-Z]" "[a-z]")
         $CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db -p > $db_config_fil
         if [[ -e $db_config_fil && `cat $db_config_fil|grep -ci "Could not find resource"` -ge 1 ]]; then  $CRS/bin/crsctl status resource ora.${db_name_to_check}.db -p > $db_config_fil;fi;
    else
      if [[ $single_instance_run -eq "0" ]] ; then
         $CRS/bin/srvctl config database -d $db_name_to_check -a > $db_config_fil 
      else 
        l_oh="";
        get_ohome_si_oh $db_name_to_check
        echo "ORACLE_HOME=$l_oh" > $db_config_fil
      fi
    fi
    #following code to fix the issue raised by DHS
    if [[ -n "$RAT_ORACLE_HOME" && $no_of_databases -eq 1 ]]
    then
         mb_oracle_homes[$mb_db_counter]=$RAT_ORACLE_HOME
    else
        mb_oracle_homes[$mb_db_counter]=$(cat $db_config_fil|grep ORACLE_HOME|grep -vw "ORACLE_HOME_OLD"|cut -d: -f2|cut -d= -f2|sed 's/ //g')
    fi
    ####
    if [ -z "${mb_oracle_homes[$mb_db_counter]}" ]
    then
         mb_oracle_homes[$mb_db_counter]=$($CRS/bin/srvctl status database -d ${db_name_to_check}|grep PRKR-1078|awk '{ print $NF }')   
    fi
    mb_read_oracle_home "${mb_oracle_homes[$mb_db_counter]}" "$db_name_to_check"
    if [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 0 ]] 
    then
        mb_oracle_homes[$mb_db_counter]=${mb_oracle_homes[$mb_db_counter]}
    else
        mb_validate_oracle_home "$mb_ask_oracle_home"
        mb_oracle_homes[$mb_db_counter]=$mb_ask_oracle_home
    fi
    #echo " ${mb_oracle_homes[$mb_db_counter]}  and mb_db_counter=$mb_db_counter"
    while [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 1 ]] && [ $validate_oracle_home_tries -lt 3 ] && [ $validate_oracle_home_status -eq 0 ]
    do
        validate_oracle_home_tries=$(expr $validate_oracle_home_tries + 1 )
        mb_oracle_homes[$mb_db_counter]=""
        mb_read_oracle_home "${mb_oracle_homes[$mb_db_counter]}" "$db_name_to_check"
        mb_validate_oracle_home "$mb_ask_oracle_home"
        mb_oracle_homes[$mb_db_counter]=$mb_ask_oracle_home
        printf ". "
       #read -p "validate_oracle_home_tries=$validate_oracle_home_tries"
    done
    export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
    what_db=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
    #if [ -n "$RAT_DB" ]; then what_db=$RAT_DB;fi
    check_oh_last_character=$ORACLE_HOME
    if [ -n "$check_oh_last_character" ]
    then 
        if [ `uname -s` = "Linux" ]
        then
            oh_last_character=$(expr substr $check_oh_last_character ${#check_oh_last_character} 1) 
        else
            oh_last_character=""
        fi
        if [[ -n "$oh_last_character" && "$oh_last_character" = "/" && $what_db -lt 111070 ]]; then  mb_oracle_homes[$mb_db_counter]=$(echo ${mb_oracle_homes[$mb_db_counter]}|sed 's/.$//');fi;
    fi
    #ports_find_sid
    #read -p "ORACLE_HOME=$ORACLE_HOME"
    mb_database_type[$mb_db_counter]="NORMAL"
    if [ $single_instance_run -eq "1" ] ; then
       mb_oracle_sids[$mb_db_counter]=${mb_db_names[$mb_db_counter]}
    else
      mb_oracle_sids[$mb_db_counter]=$(${ORACLE_HOME}/bin/srvctl status database -d $db_name_to_check|grep -i "${mb_running_host[$mb_db_counter]}"|head -1|awk '{print $2}') #remote_database_code
    fi
    export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
    if [[ $what_db -gt 121000 ]]
    then
        checksysdba     
        mb_checksysdba[$mb_db_counter]=$IS_SYSDBA
        if [[ ${mb_checksysdba[$mb_db_counter]} -eq 1 ]]
        then  
	    multipleSqlValue "select value from v\$parameter where name='local_listener'"
            local_listener=$(echo $sqlValue|awk 'BEGIN { FS = "=" }{ print $NF }'|sed 's/[^0-9]*//g'|tr "\013" " ")
	    #local_listener=$(echo $sqlValue|awk -F "PORT=" '{print $2}'|sed 's/)//g'|tr "\013" " ")
	    #To remove new line and blank space charactor  
	    local_listener=$(echo $local_listener|sed 's/ //g')
	    multipleSqlValue "select cdb from v\$database"  
		  
	    if [ "$sqlValue" = "YES" ]
	    then
		mb_database_type[$mb_db_counter]="CDB"
		multipleSqlValue "select name from v\$pdbs where open_mode='READ WRITE'"  
		sqlValue=$(echo $sqlValue|tr "\013" " ")
                if [[ -n "$RAT_PDBNAMES" && "$RAT_PDBNAMES" = "none" ]]
                then
                    sqlValue="" 
                elif  [ -n "$RAT_PDBNAMES" ]
                then 
                    sqlValue=$RAT_PDBNAMES
                fi
		if [ -z "$RAT_PDB_USER" ]; then RAT_PDB_USER=sys;fi     
		for pdb_name in $sqlValue
		do  
		   if [ "$NOQUESTION" -eq 0 ]
		   then    
		       if [ -z "$db_name_to_check_none" ]
		       then 
			   l_service_name=$($ORACLE_HOME/bin/lsnrctl services |grep -iw ${pdb_name}|cut -d'"' -f2)
			   if [ -z "$l_service_name" ] ; then l_service_name=${pdb_name}; fi
			   mb_pdb_connect_string[$mb_pdb_counter]="(DESCRIPTION = (ADDRESS = (PROTOCOL = TCP)(HOST = ${mb_running_host[$mb_db_counter]})(PORT = ${local_listener})) (CONNECT_DATA = (SERVER = DEDICATED) (SERVICE_NAME = ${l_service_name})))"
			   check_pdb_password
			   if [ $pdb_check_password_status -eq 1 ]
			   then 
			       mb_pdb_names[$mb_pdb_counter]=$pdb_name 
			       mb_pdb_homes[$mb_pdb_counter]=${mb_oracle_homes[$mb_db_counter]}
			       mb_pdb_running_host[$mb_pdb_counter]=${mb_running_host[$mb_db_counter]}
			       mb_pdb_sys_password[$mb_pdb_counter]=$pdb_sys_password 
			       mb_pdb_counter=$(expr $mb_pdb_counter + 1)
			   fi
		       fi
		   else 
		       echo -e "\n${RED}Pluggable database $pdb_name can not checked in silent mode because user needs to key in database password${NORM}\n\n"|tee -a $LOGFIL
		   fi
		done 
		#If there are PDBS for a CDB then set multiple_db=1  
		if [[ $multiple_db -eq 0 && $mb_pdb_counter -gt 0 ]]; then multiple_db=1;fi 
		#echo "$db_name_to_check.pluggable_databases = $sqlValue" >>$MASTERFIL
	    fi
        else
            echo -e "\n${RED} OS authentication to login as sysdba is not enabled so skipping $db_name_to_check for pdb discovery${NORM}\n\n"|tee -a $LOGFIL 
        fi    
    fi  
    #func_what_db
    if [[ $upgrade_mode -eq 2 ]]
    then
      if [[ -n "$what_db" &&  $what_db -eq $targetversion ]]
      then 
        mb_db_names_upgraded[$mb_db_counter_upgraded]=$db_name_to_check
        mb_db_counter_upgraded=$(expr $mb_db_counter_upgraded + 1)
      else
        mb_db_names_need_upgrade[$mb_db_counter_need_upgrade]=$db_name_to_check
        mb_db_counter_need_upgrade=$(expr $mb_db_counter_need_upgrade + 1)
      fi
    elif [ $upgrade_mode -eq 3 ]
    then
       if [[ -n "$what_db" &&  `echo $supportedTargetVersion|grep -icw $what_db` -ge 1 ]]
       then 
         mb_db_names_upgraded[$mb_db_counter_upgraded]=$db_name_to_check
         mb_db_counter_upgraded=$(expr $mb_db_counter_upgraded + 1)
       else
         mb_db_names_need_upgrade[$mb_db_counter_need_upgrade]=$db_name_to_check
         mb_db_counter_need_upgrade=$(expr $mb_db_counter_need_upgrade + 1)
       fi
    fi

    if [  -e $OUTPUTDIR/mb_db_homes_versions_distinct.out ]
    then 
        if [ `grep -c "$what_db" $OUTPUTDIR/mb_db_homes_versions_distinct.out` -lt 1 ]
        then  
            echo "$ORACLE_HOME|$what_db">>$OUTPUTDIR/mb_db_homes_versions_distinct.out
        fi
    else
        echo "$ORACLE_HOME|$what_db">>$OUTPUTDIR/mb_db_homes_versions_distinct.out
    fi
    if [ -z "$db_name_to_check_none"  ]
    then
	if [  -e $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out ]
	then 
	    if [ `grep -c "$what_db" $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out` -lt 1 ]
	    then  
		echo "$ORACLE_HOME|$what_db|$db_name_to_check">>$OUTPUTDIR/mb_db_homes_versions_distinct_selected.out
	    fi
	else
	    echo "$ORACLE_HOME|$what_db|$db_name_to_check">>$OUTPUTDIR/mb_db_homes_versions_distinct_selected.out
	fi
    fi
    #read -p " ${mb_oracle_homes[$mb_db_counter]} ${mb_oracle_sids[$mb_db_counter]}"
    mb_db_counter=$(expr $mb_db_counter + 1)
 done
 #read -p  "${mb_oracle_sids[@]} ${mb_oracle_homes[@]} ${mb_db_names[@]}"
#code to add PDBs to to the end of the list of databases
 mb_pdb_counter=0
 for pdb_name in "${mb_pdb_names[@]}" 
 do
   mb_db_names[$mb_db_counter]=$pdb_name
   mb_oracle_homes[$mb_db_counter]=${mb_pdb_homes[$mb_pdb_counter]}
   mb_database_type[$mb_db_counter]="PDB"
   mb_running_host[$mb_db_counter]=${mb_pdb_running_host[$mb_pdb_counter]}
   mb_db_sys_password[$mb_db_counter]=${mb_pdb_sys_password[$mb_pdb_counter]}
   mb_db_connect_string[$mb_db_counter]=${mb_pdb_connect_string[$mb_pdb_counter]}
   mb_database_role[$mb_db_counter]="PRIMARY"
   mb_checksysdba[$mb_db_counter]=0
   mb_db_counter=$(expr $mb_db_counter + 1)
   mb_pdb_counter=$(expr $mb_pdb_counter + 1)
 done
 mb_db_counter=0
 mb_db_counter_upgraded=0
 mb_db_counter_need_upgrade=0
 mb_pdb_counter=0
#read -p "${mb_db_names[@]} ${mb_oracle_homes[@]} ${mb_database_type[@]} ${mb_running_host[$mb_db_counter]} ${mb_database_role[@]}"
#read -p "${mb_database_type[@]}"
 for db_name_to_check_oh in `cat $db_list_fil`
 do
    if [[ $upgrade_mode -gt 0 && ` echo ${mb_db_names[@]}|grep -icw $db_name_to_check_oh` -lt 1 ]]
    then
	echo "skipping $db_name_to_check_oh database for checking patches because not selected from list">>$LOGFIL
    else
	printf ". "
	if [[ -n "$crs112" && $crs112 -ge 1 ]]
	then
	     db_name_to_check_lower_oh=$(echo $db_name_to_check_oh|tr "[A-Z]" "[a-z]")
	     $CRS/bin/crsctl status resource ora.${db_name_to_check_lower_oh}.db -p > $db_config_fil
	     if [[ -e $db_config_fil && `cat $db_config_fil|grep -ci "Could not find resource"` -ge 1 ]]; then  $CRS/bin/crsctl status resource ora.${db_name_to_check_oh}.db -p > $db_config_fil;fi;
	else
          if [[ $single_instance_run -eq "0" ]] ; then 
	     $CRS/bin/srvctl config database -d $db_name_to_check_oh -a > $db_config_fil 
          else
            l_oh="";
            get_ohome_si_oh $db_name_to_check_oh
            echo "ORACLE_HOME=$l_oh" > $db_config_fil
          fi
	fi
	#mb_oracle_homes[$mb_db_counter]=$(cat $db_config_fil|grep ORACLE_HOME|cut -d: -f2|cut -d= -f2|sed 's/ //g')
	#following code to fix the issue raised by DHS
	if [[ -n "$RAT_ORACLE_HOME" && `cat $db_list_fil|wc -l` -eq 1 ]]
	then
	    export ORACLE_HOME=$RAT_ORACLE_HOME
	else
	    export ORACLE_HOME=$(cat $db_config_fil|grep ORACLE_HOME|grep -vw "ORACLE_HOME_OLD"|cut -d: -f2|cut -d= -f2|sed 's/ //g')
	fi
	#####
	if [ -z "${ORACLE_HOME}" ]
	then
	     export ORACLE_HOME=$($CRS/bin/srvctl status database -d ${db_name_to_check_oh}|grep PRKR-1078|awk '{ print $NF }')   
	fi
	mb_read_oracle_home "$ORACLE_HOME" "$db_name_to_check_oh"
	if [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 0 ]] 
	then
	    echo "Do nothing" >/dev/null 2>&1
	else
	    mb_validate_oracle_home "$mb_ask_oracle_home"
	    export ORACLE_HOME=$mb_ask_oracle_home
	fi
	while [[ -n "$mb_read_oracle_home_called" && $mb_read_oracle_home_called -eq 1 ]] && [ $validate_oracle_home_tries -lt 3 ] && [ $validate_oracle_home_status -eq 0 ]
	do
	   validate_oracle_home_tries=$(expr $validate_oracle_home_tries + 1 )
	   ORACLE_HOME=""
	   mb_read_oracle_home "$ORACLE_HOME" "$db_name_to_check_oh"
	   mb_validate_oracle_home "$mb_ask_oracle_home"
	   export ORACLE_HOME=$mb_ask_oracle_home
	   printf ". "
	done
	validate_oracle_home_tries=0
	what_db=$($ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
	if [ -n "$what_db" ]; then echo "$ORACLE_HOME|$what_db">>$OUTPUTDIR/mb_db_homes_distinct.out;fi
	echo "$what_db">>$OUTPUTDIR/mb_db_versions_distinct.out
	mb_db_counter=$(expr $mb_db_counter + 1)
    fi
 done
 mb_db_counter=0
 echo -e "\n"
 #cat $OUTPUTDIR/mb_db_homes_distinct.out
 #read -p "stop"
 #cat $OUTPUTDIR/mb_db_homes_distinct.out
 mb_set_oracle_home_version_distinct 
 #read -p  "${mb_oracle_homes_distinct[@]} ${mb_oracle_versions_distinct[@]} ${mb_oracle_homes_version_distinct[@]}"
}
mb_set_oracle_home_version_distinct ()
{
 mb_db_counter=0
 for mb_db_version in `if [ -e $OUTPUTDIR/mb_db_versions_distinct.out ]; then cat $OUTPUTDIR/mb_db_versions_distinct.out|sort -u;fi;`
 do
    mb_oracle_versions_distinct[$mb_db_counter]=$mb_db_version
    mb_db_counter=$(expr $mb_db_counter + 1)
 done
 mb_db_counter=0
 for mb_db_home in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|cut -d'|' -f1|sort -u;fi;`
 do
    mb_oracle_homes_distinct[$mb_db_counter]=$mb_db_home
    if [ $OFFLINE -eq 0 ]
    then
	export ORACLE_HOME=$mb_db_home
	what_db=$($ORACLE_HOME/bin/sqlplus -v 2>/dev/null|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
	if [ `uname -s` = "Linux" ]
	then
	    oracle_home_owner[$mb_db_counter]=$(stat -L -c "%U" $ORACLE_HOME/bin/oracle 2>/dev/null >&1)
	else
	    oracle_home_owner[$mb_db_counter]=$(ls -l $ORACLE_HOME/bin/oracle 2>/dev/null >&1|awk '{print $3}')
	fi
	echo "RDBMS_ORACLE_HOME = $mb_db_home|${what_db}|${oracle_home_owner[$mb_db_counter]}">>$MASTERFIL
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
 done
 multiple_oracle_homes=$mb_db_counter
 mb_db_counter=0
 for mb_db_version in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|cut -d'|' -f2;fi`
 do
    mb_db_versions_all[$mb_db_counter]=$mb_db_version
    mb_db_counter=$(expr $mb_db_counter + 1)
 done
 mb_db_counter=0 
 for mb_db_home_version in `if [ -e $OUTPUTDIR/mb_db_homes_versions_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f1|sort -u;fi;`
 do
    mb_oracle_homes_version_distinct[$mb_db_counter]=$(grep $mb_db_home_version "$OUTPUTDIR/mb_db_homes_versions_distinct.out"|cut -d'|' -f2)
    mb_db_counter=$(expr $mb_db_counter + 1)
 done
 mb_db_counter=0
}
mb_rdbms_stack_status ()
{
 mb_db_counter=0
 for db_name_to_check in "${mb_db_names[@]}"
 do
    printf ". "
   #reinitializing database password check counter for each database
    WRNDBPWD=0
    mb_skip[$mb_db_counter]=0;
    stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
    if [ $upgrade_mode -eq 2 ]
    then
       if [[ -n "${mb_db_names_upgraded[@]}" && ` echo ${mb_db_names_upgraded[@]}|grep -icw $db_name_to_check` -ge 1 ]]
       then
           its_upgraded=0
           mb_skip[$mb_db_counter]=1;
       else
           its_upgraded=0
       fi
    elif [ $upgrade_mode -eq 3 ]
    then 
        if [[ -n "${mb_db_names_upgraded[@]}" && ` echo ${mb_db_names_upgraded[@]}|grep -icw $db_name_to_check` -ge 1 ]]
       then
           its_upgraded=0
       else
           its_upgraded=0
           mb_skip[$mb_db_counter]=1;
       fi
    else
       its_upgraded=0
    fi
    #read -p "IS_SYSDBA=$IS_SYSDBA $its_upgraded" 
    #if [[ -n "$crs112" && $crs112 -ge 1 ]]
    #then
    #    db_name_to_check_lower=$(echo $db_name_to_check|tr '[:upper:]' '[:lower:]')
    #    mb_rdbms_inst_stat=$($CRS/bin/crsctl status resource ora.${db_name_to_check_lower}.db |grep -i state|grep $localnode|grep -ic online)
    #    if [[ -z "$mb_rdbms_inst_stat" || $mb_rdbms_inst_stat -lt 1 ]]; then mb_rdbms_inst_stat=$($CRS/bin/crsctl status resource ora.${db_name_to_check}.db |grep -i state|grep $localnode|grep -ic online); fi;
    #else
    #    mb_rdbms_inst_stat=$($CRS/bin/crs_stat ora.${db_name_to_check}.db |grep -i state|grep $localnode|grep -ic online)
    #fi
    #if [[ -n "$mb_rdbms_inst_stat" &&  $mb_rdbms_inst_stat -ge 1 ]] 
    #then
        if [[ -z "$db_name_to_check_none" && $its_upgraded -eq 0 ]]
        then
	    if [ -z "$RAT_ORACLE_HOME" ]
	    then  
		export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
	    else
		export ORACLE_HOME=$RAT_ORACLE_HOME
	    fi
            #Following if block is to set ORACLE_SID even database is not registered in OCR.
            if [ -n "${mb_oracle_sids[$mb_db_counter]}" ]
            then
                 export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
            else
                 mb_oracle_sids[$mb_db_counter]=$ORACLE_SID
                 export ORACLE_SID
            fi
            export PATH=$PATH:$ORACLE_HOME/bin
	    checksysdba
	    mb_checksysdba[$mb_db_counter]=$IS_SYSDBA 
            #read -p "IS_SYSDBA=${mb_checksysdba[$mb_db_counter]}"
	    if [[ ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
	    then 
              if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]
              then
	      nosysdba
              mb_sysdba_user[$mb_db_counter]=$DBUSR
              mb_sysdba_pswd[$mb_db_counter]=$DBPWD
              if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
              then
		$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
		set head off
		set lines 80
		set feedback off
		set serveroutput on
		spool $stack_status
		select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
		spool off
		exit
EOF
              else #remote_database_code
                $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
                  export ORACLE_HOME=$ORACLE_HOME
                  export ORACLE_SID=$ORACLE_SID; \
		  $ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
		  set head off
		  set lines 80
		  set feedback off
		  set serveroutput on
		  spool $RTEMPDIR/stack_status_${db_name_to_check}.log
		  select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
		  spool off
		  exit
EOF
EOF2
                $SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/stack_status_${db_name_to_check}.log $stack_status >/dev/null 2>&1
              fi #end of localnode if
		printf ". . . . "
              else
                 unset mb_db_names[$mb_db_counter]
                 echo -e "\nOS authentication not enabled and asking database password not possible in silent mode so dropping $db_name_to_check from list to check best practices\n">>$LOGFIL  
              fi #end of NOQUESTION if
	    else
              mb_sysdba_user[$mb_db_counter]=1
              mb_sysdba_pswd[$mb_db_counter]=1
              if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
              then
		$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		set head off
		set lines 80
		set feedback off
		set serveroutput on
		spool $stack_status
		select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
		spool off
		exit
EOF
              else #remote_database_code
                $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
                  export ORACLE_HOME=$ORACLE_HOME
                  export ORACLE_SID=$ORACLE_SID; \
		$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		set head off
		set lines 80
		set feedback off
		set serveroutput on
		spool $RTEMPDIR/stack_status_${db_name_to_check}.log
		select instance_name||'|'||decode(status,'OPEN',3,'MOUNTED',2,'NOMOUNT',1,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
		spool off
		exit
EOF
EOF2
                $SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/stack_status_${db_name_to_check}.log $stack_status >/dev/null 2>&1
	      fi
	      printf ". . . . "
	    fi
        elif [[ -n "$db_name_to_check_none" && $db_name_to_check_none -eq 1 ]] || [ $its_upgraded -eq 1 ]
        then
            if [ -z "$RAT_ORACLE_HOME" ]
	    then  
		export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
	    else
		export ORACLE_HOME=$RAT_ORACLE_HOME
	    fi
	    export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
	    checksysdba
	    mb_checksysdba[$mb_db_counter]=$IS_SYSDBA 
	    if [[ ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
	    then 
             if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]
             then     
	      nosysdba
              mb_sysdba_user[$mb_db_counter]=$DBUSR
              mb_sysdba_pswd[$mb_db_counter]=$DBPWD
              if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
              then
		$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
		set head off
		set lines 80
		set feedback off
		set serveroutput on
		spool $stack_status
		select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
		spool off
		exit
EOF
              else #remote_database_code
                $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
                  export ORACLE_HOME=$ORACLE_HOME
                  export ORACLE_SID=$ORACLE_SID; \
		$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba >/dev/null 2>&1 <<EOF
		set head off
		set lines 80
		set feedback off
		set serveroutput on
		spool $RTEMPDIR/stack_status_${db_name_to_check}.log
		select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
		spool off
		exit
EOF
EOF2
                $SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/stack_status_${db_name_to_check}.log $stack_status >/dev/null 2>&1
              fi #end of localnode if
              printf ". . . . "
             else
                 unset mb_db_names[$mb_db_counter]
                 echo -e "\nOS authentication not enabled and asking database password not possible in silent mode so dropping $db_name_to_check from list to check best practices\n">>$LOGFIL  
             fi  #end of NOQUESTION if 
	    else
              mb_sysdba_user[$mb_db_counter]=1
              mb_sysdba_pswd[$mb_db_counter]=1
              if [[ ${mb_running_host[$mb_db_counter]} = $localnode ]]
              then
		$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		set head off
		set lines 80
		set feedback off
		set serveroutput on
		spool $stack_status
		select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\$instance;
		spool off
		exit
EOF
              else #remote_database_code
                $SSHELL ${mb_running_host[$mb_db_counter]} $bash_scr <<EOF2
                  export ORACLE_HOME=$ORACLE_HOME
                  export ORACLE_SID=$ORACLE_SID; \
		$ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
		set head off
		set lines 80
		set feedback off
		set serveroutput on
		spool $RTEMPDIR/stack_status_${db_name_to_check}.log
		select instance_name||'|'||decode(status,'OPEN',0,'MOUNTED',0,'NOMOUNT',0,0)||'|'||replace(version,'.','')||'|'||lower(HOST_NAME) from gv\\\$instance;
		spool off
		exit
EOF
EOF2
                $SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/stack_status_${db_name_to_check}.log $stack_status >/dev/null 2>&1
              fi
	       printf ". . . . "
	    fi #end os IS_SYSDBA if
        fi #end of first if in this for loop
    #fi
    #echo "stack_status: ${mb_running_host[$mb_db_counter]}"
    #cat $stack_status
    mb_db_counter=$(expr $mb_db_counter + 1)
    #read -p "stop here"
 done
 mb_db_counter=0
}
       #db_name_to_check=$(echo $db_name_to_check|tr '[:upper:]' '[:lower:]')
is_asm_installed_crs ()
{
#search_invntr_platform
asm_counter=0
asm_config_fil=$INPUTDIR/asm_config.out
if [[ ${crs_up} = 1 && $check_crs_stat -eq 0 ]]
then
   if [[ -n "$crs112" && $crs112 -ge 1 ]]
   then
       crs_AH=$($CRS/bin/srvctl config asm |grep -i home |awk '{print $3}')
   fi
   for asm_install in `cat $HOSTLIST`
   do
     unset invntr_AH
     if [ $asm_install = $localnode ]
     then
	 if [[ -n "$crs112" && $crs112 -eq 0 ]]; then crs_AH=$($CRS/bin/srvctl config asm -n $asm_install|awk '{print $2}');fi
	 #if [[ -n "${invntr_location[$asm_counter]}" && -n "$crs_AH" ]]
	# then
	#     invntr_AH=$(cat ${invntr_location[$asm_counter]}/ContentsXML/inventory.xml |grep $crs_AH|awk '{print $3}'|cut -d= -f2|sed 's/\"//g' )
	     #if [[ $invntr_AH = $crs_AH  && $crs112 -eq 0 ]] 
	     #then
		if [[ -d $crs_AH || -n "$RAT_ASM_HOME" ]]
		then
		   if [[ -f $crs_AH/bin/oracle || -n "$RAT_ASM_HOME" ]]
		   then
		       asm_installed[$asm_counter]=1
		       local_invntr_AH=$crs_AH
		   else
		       asm_installed[$asm_counter]=0
		   fi
		else
		    asm_installed[$asm_counter]=0
		fi
	    # else
	    #     asm_installed[$asm_counter]=0
	    # fi
	     if [ ${asm_installed[$asm_counter]} -eq 1 ]
	     then
		 echo "$asm_install.ASM_INSTALLED = 1" >>$MASTERFIL
	     else
		 echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL
	     fi
	 #else
	 #    asm_installed[$asm_counter]=0
	 #    echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL
	 #fi
     else
	 if [[ -n "$crs112" &&  $crs112 -eq 0 ]]; then crs_AH=$($CRS/bin/srvctl config asm -n $asm_install|awk '{print $2}');fi
	 #if [[ -n "${invntr_location[$asm_counter]}" && -n "$crs_AH" ]]
	# then
	 #    invntr_AH=$(ssh $asm_install cat ${invntr_location[$asm_counter]}/ContentsXML/inventory.xml |grep $crs_AH|awk '{print $3}'|cut -d= -f2|sed 's/\"//g' )
	 #    if [[ $invntr_AH = $crs_AH && $crs112 -eq  0 ]]
	 #    then
		 $SSHELL $asm_install ls -l $crs_AH >/dev/null 2>&1
		 if [[ $? -eq 0  || -n "$RAT_ASM_HOME" ]]
		 then 
		     $SSHELL $asm_install ls -l $crs_AH/bin/oracle >/dev/null 2>&1
		     if [[ $? -eq 0 || -n "$RAT_ASM_HOME" ]]
		     then
			 asm_installed[$asm_counter]=1
		     else
			 asm_installed[$asm_counter]=0
		     fi
		 else
		     asm_installed[$asm_counter]=0
		 fi
	    # else
	    #     asm_installed[$asm_counter]=0
	    # fi
	     if [ ${asm_installed[$asm_counter]} -eq 1 ]
	     then
		 echo "$asm_install.ASM_INSTALLED = 1" >>$MASTERFIL
	     else
		  echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL
	     fi
	 #else
	 #   asm_installed[$asm_counter]=0
	 #   echo "$asm_install.ASM_INSTALLED = 0" >>$MASTERFIL   
	 #fi
     fi # localnode if ends here
     asm_counter=`expr $asm_counter + 1`
   done 
   asm_counter=0  
else
    is_asm_installed
    echo "is_asm_installed was called because CRS was down on local node">>$LOGFIL
fi
}

#is_exalogic_machine
# In exalogic we dont check statck status. This function initializes all varia bles
func_init_arrays ()
{
  if [ $OFFLINE -eq "0" ] ; then touch $ORCLENVFIL; fi;
  crs_installed=0
  stack_counter=0 
  for stack in `cat $HOSTLIST`
  do
    stack_crs_up[$stack_counter]=0
    stack_dbinst_up[$stack_counter]=0
    stack_asm_up[$stack_counter]=0
    if [[ -n "$is_exalytics_machine" &&  "$is_exalytics_machine" -eq 0 ]];then rdbms_installed[$stack_counter]=0;fi
    crs_installed[$stack_counter]=0
    stack_counter=$(expr $stack_counter + 1)
  done
  stack_counter=0
}

#this function is to check the CRS and RDBMS instance status in entire cluster.
#CRS check swill executed if CRS is and Database checks will be executed if 
#rDBMS instance is up and that too on individual node
func_stack_status ()
{
 echo -e "\nChecking Status of Oracle Software Stack - Clusterware, ASM, RDBMS\n"
 printf ". "
 mb_rdbms_stack_status
 #read -p "IS_SYSDBA=$IS_SYSDBA" 
 echo "MULTIPLE_DATABASE = $multiple_db" >>$MASTERFIL
 stack_counter=0 
 for stack in `cat $HOSTLIST`
 do
   printf ". "
   if [ $stack = $localnode ]
   then
      stack_check_crs=`ps -ef|grep -ic "d.bin"`
      stack_check_crs_run=`$CRS/bin/crs_stat -t  >/dev/null 2>&1;echo $?`
      #read -p "$stack_check_crs $stack_check_crs_run $CRS"
      printf ". "
      if [[ ${stack_check_crs} -ge 3 && $stack_check_crs_run -eq 0 ]]
      then
	 if [[ -n "$crs112" && $crs112 -ge 1 ]]
	 then
	     if [[ `uname -s` = "AIX"  || `uname -s` = "SunOS" ||  `uname -s` = "HP-UX" ]] 
	     then
		asm_inst_name_single=$($CRS/bin/crs_stat|grep -i asm|grep $stack|cut -d. -f3)
		stack_asm_sid[$stack_counter]=$(echo "+${asm_inst_name_single}")
	     else
		 stack_asm_sid[$stack_counter]="+"`$CRS/bin/crs_stat|grep -i -A 2 asm|grep $stack|cut -d. -f3|grep -v $stack`
		 stack_acfs_modules=$(/sbin/lsmod|grep -i -E 'oracleacfs|oracleoks|oracleadvm'|wc -l)
	     fi
             if [ "${stack_asm_sid[$stack_counter]}" != "$(ps -ef |grep asm_pmon|grep -v grep|cut -d_ -f3)" ]; then stack_asm_sid[$stack_counter]=$(ps -ef |grep asm_pmon|grep -v grep|$AWK -F "_" '{print $NF}');fi      
	     printf ". . . . "
	 else
	     stack_asm_sid[$stack_counter]=`$CRS/bin/srvctl config asm -n $stack |awk '{print $1}'`
	     stack_asm_home[$stack_counter]=`$CRS/bin/srvctl config asm -n $stack |awk '{print $2}'`
	     printf ". . . . "
	 fi
	 stack_crs_version[$stack_counter]=`$CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'`
	 stack_asm=`$CRS/bin/srvctl status asm -n $stack|grep -ic "is running"`
         #stack_asm=0
	 if [ $stack_asm -ge 1 ]
	 then
	     stack_asm_up[$stack_counter]=1
	     printf ". "
	     stack_acfs_drivers=$($CRS/bin/crsctl  stat res ora.registry.acfs -t|grep $stack)
	     if [ $? -eq 0 ]; then stack_acfs_drivers_status=1;else stack_acfs_drivers_status=0;fi;
	     printf ". "
	     stack_acfs_registry=$($CRS/bin/crsctl  stat res ora.drivers.acfs -init -t|grep $stack)
	     if [  $? -eq 0 ]; then stack_acfs_registry_status=1;else stack_registry_drivers_status=0;fi;
	     if [[ $stack_acfs_modules -ge 3 && $stack_acfs_drivers_status -eq 1 && $stack_acfs_registry_status -eq 1 ]]
	     then 
		 stack_acfs_up[$stack_counter]=1
	     else 
		 stack_acfs_up[$stack_counter]=0
	     fi
	     printf ". "
	 else
	     stack_asm_up[$stack_counter]=0
	     printf ". "
	 fi 
	 stack_crs_up[$stack_counter]=1
	 #if [ ${crs_installed[$stack_counter]} -eq 0 ]; then crs_installed[$stack_counter]=1;fi;
	 printf ". "
	 crs_up=1
	 cluster_name=`$CRS/bin/cemutlo -n`
      else
	 stack_crs_up[$stack_counter]=0
	 stack_asm_up[$stack_counter]=0
	 printf ". "
	 crs_up=0
      fi
      echo "${stack}.CRS_STATUS = ${stack_crs_up[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.CRS_ACTIVE_VERSION = ${stack_crs_version[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_STATUS = ${stack_asm_up[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_INSTANCE = ${stack_asm_sid[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_HOME = ${stack_asm_home[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ACFS_STATUS = ${stack_acfs_up[$stack_counter]}" >>$MASTERFIL
      if [ $multiple_db -eq 1 ]
      then
	  for db_name_to_check in "${mb_db_names[@]}"
	  do
             stack_dbinst_up[$stack_counter]=""
             stack_dbinst_name[$stack_counter]=""
             stack_dbinst_version[$stack_counter]="" 
	     stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
	     if [ -f $stack_status ]
	     then  
		  stack_dbinst_up[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f2`
		  stack_dbinst_name[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f1`
		  stack_dbinst_version[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f3`
		  db_version=stack_dbinst_version[$stack_counter]
		  printf ". "
	     fi
	     if [ -z ${stack_dbinst_up[$stack_counter]} ]
	     then
		 stack_dbinst_up[$stack_counter]=0
		 db_up=0 
		 printf ". "
	     else
		 db_up=1
		 printf ". "
	     fi
	     stack_host[stack_counter]=$stack
	     printf ". "
	     echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
	     echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
	     echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
	     printf ". "
	  done
      else
	  for db_name_to_check in "${mb_db_names[@]}"
	  do
	     stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
	     if [ -f $stack_status ]
	     then
		  stack_dbinst_up[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f2`
		  stack_dbinst_name[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f1`
		  stack_dbinst_version[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f3`
		  db_version=stack_dbinst_version[$stack_counter]
		  printf ". "
	     fi  
	  done 
	  if [ -z ${stack_dbinst_up[$stack_counter]} ]
	  then
	      stack_dbinst_up[$stack_counter]=0
	      db_up=0
	      printf ". "
	  else
	      db_up=1
	      printf ". "
	  fi 
	  stack_host[stack_counter]=$stack
	  printf ". "
	  echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
	  echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
	  echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
	  printf ". "
      fi
   else
      stack_check_crs=`$SSHELL $stack ps -ef|grep -ic "d.bin"`
      stack_check_crs_run=`$SSHELL $stack $CRS/bin/crs_stat -t  >/dev/null 2>&1;echo $?` 
      #read -p "stack_check_crs_run=$stack_check_crs_run and stack_check_crs=$stack_check_crs"
      printf ". "
      if [[ ${stack_check_crs} -ge 3 && $stack_check_crs_run -eq 0 ]]
      then
	 if [[ -n "$crs112" && $crs112 -ge 1 ]]
	 then
	     if [[ `uname -s` = "AIX"  || `uname -s` = "SunOS" || `uname -s` = "HP-UX" ]] 
	     then
		asm_inst_name_single=$($CRS/bin/crs_stat|grep -i asm|grep $stack|cut -d. -f3)
		stack_asm_sid[$stack_counter]=$(echo "+${asm_inst_name_single}")
	     else
		 stack_asm_sid[$stack_counter]="+"`$CRS/bin/crs_stat|grep -i -A 2 asm|grep $stack|cut -d. -f3|tail -1`
		 stack_acfs_modules=$($SSHELL $stack /sbin/lsmod|grep -i -E 'oracleacfs|oracleoks|oracleadvm'|wc -l)
	     fi
             ps_asm_sid=$($SSHELL $stack ps -ef |grep asm_pmon|grep -v grep|$AWK -F "_" '{print $NF}')    
             if [ "${stack_asm_sid[$stack_counter]}" != "$ps_asm_sid" ]; then stack_asm_sid[$stack_counter]=$($SSHELL $stack ps -ef |grep asm_pmon|grep -v grep|$AWK -F "_" '{print $NF}');fi              
	     printf ". . . "
	 else
	     stack_asm_sid[$stack_counter]=`$CRS/bin/srvctl config asm -n $stack |awk '{print $1}'`
	     stack_asm_home[$stack_counter]=`$CRS/bin/srvctl config asm -n $stack |awk '{print $2}'`
	     printf ". . . . "
	 fi
	 stack_crs_version[$stack_counter]=`$SSHELL $stack $CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'`
	 stack_asm=`$CRS/bin/srvctl status asm -n $stack|grep -ic "is running"`
	 printf ". "
	 if [ $stack_asm -ge 1 ]
	 then
	     stack_asm_up[$stack_counter]=1
	     printf ". "
	     stack_acfs_drivers=$($SSHELL $stack $CRS/bin/crsctl  stat res ora.registry.acfs -t|grep $stack)
	     if [ `echo $?` -eq 0 ]; then stack_acfs_drivers_status=1;else stack_acfs_drivers_status=0;fi;
	     printf ". "
	     stack_acfs_registry=$($CRS/bin/crsctl  stat res ora.drivers.acfs -init -t|grep $stack)
	     if [ `echo $?` -eq 0 ]; then stack_acfs_registry_status=1;else stack_registry_drivers_status=0;fi;
	     if [[ $stack_acfs_modules -ge 3 && $stack_acfs_drivers_status -eq 1 && $stack_acfs_registry_status -eq 1 ]]
	     then 
		  stack_acfs_up[$stack_counter]=1
	     else 
		  stack_acfs_up[$stack_counter]=0
	     fi
	     printf ". "
	 else
	     stack_asm_up[$stack_counter]=0
	     printf ". "
	 fi
	 stack_crs_up[$stack_counter]=1
	 #if [ ${crs_installed[$stack_counter]} -eq 0 ]; then crs_installed[$stack_counter]=1;fi;
	 printf ". "
      else
	 stack_crs_up[$stack_counter]=0
	 stack_asm_up[$stack_counter]=0
	 printf ". "
      fi
      echo "${stack}.CRS_STATUS = ${stack_crs_up[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.CRS_ACTIVE_VERSION = ${stack_crs_version[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_STATUS = ${stack_asm_up[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_INSTANCE = ${stack_asm_sid[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ASM_HOME = ${stack_asm_home[$stack_counter]}" >>$MASTERFIL
      echo "${stack}.ACFS_STATUS = ${stack_acfs_up[$stack_counter]}" >>$MASTERFIL
      if [ $multiple_db -eq 1 ]
      then
	  for db_name_to_check in "${mb_db_names[@]}"
	  do
	     stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
             stack_dbinst_up[$stack_counter]=""
             stack_dbinst_name[$stack_counter]=""
             stack_dbinst_version[$stack_counter]="" 
	     if [  -f $stack_status ]
	     then
		 stack_dbinst_up[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f2`
		 local_db_inst=`grep $stack $stack_status|cut -d. -f2`
		 stack_dbinst_name[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f1`
		 stack_dbinst_version[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f3`
		 db_version=stack_dbinst_version[$stack_counter]
		 printf ". "
	     fi
	     if [ -z ${stack_dbinst_up[$stack_counter]} ]
	     then
		 stack_dbinst_up[$stack_counter]=0
		 printf ". "
		 db_up=0
	     else
		 db_up=1
	     fi
	     printf ". "
	     stack_host[stack_counter]=$stack
	     echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
	     echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
	     echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
	     printf ". "
	  done
      else
	  for db_name_to_check in "${mb_db_names[@]}"
	  do
	     stack_status=$INPUTDIR/stack_status_${db_name_to_check}.out
	     if [ -f $stack_status ]
	     then
		  stack_dbinst_up[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f2`
		  stack_dbinst_name[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f1`
		  stack_dbinst_version[$stack_counter]=`grep $stack $stack_status|cut -d'|' -f3`
		  db_version=stack_dbinst_version[$stack_counter]
		  printf ". "
	     fi
	  done
	  if [ -z ${stack_dbinst_up[$stack_counter]} ]
	  then
	      stack_dbinst_up[$stack_counter]=0
	      db_up=0
	      printf ". "
	  else
	      db_up=1
	      printf ". "
	  fi
	  printf ". "
	  stack_host[stack_counter]=$stack
	  echo "${stack}.${db_name_to_check}.INSTANCE_NAME = ${stack_dbinst_name[$stack_counter]}" >>$MASTERFIL
	  echo "${stack}.${db_name_to_check}.INSTANCE_MODE = ${stack_dbinst_up[$stack_counter]}" >>$MASTERFIL
	  echo "${stack}.${db_name_to_check}.INSTANCE_VERSION = ${stack_dbinst_version[$stack_counter]}" >>$MASTERFIL
	  printf ". "
      fi
   fi 
   stack_counter=`expr $stack_counter + 1 `
   printf ". "
 done
 
 mb_db_counter_local=0
 for db_name_to_check in "${mb_db_names[@]}"
 do 
  echo "$db_name_to_check.CHECKED_NODE = ${mb_running_host[$mb_db_counter_local]}" >>$MASTERFIL
  mb_db_counter_local=$(expr $mb_db_counter_local + 1)
 done

 printf ". \n"
 #when this fuction is over, reinitialize stack_counter to use in Main for loop to trace each host.
 stack_counter=0
 #following function will add asm version to master file

 is_this_db_machine "$localnode" "0"
# if [ $db_machine_compute -eq 1 ];then func_cells_stack_status;fi;
 GetMachineRole
 is_this_oda
 check_maa_scorecard
 check_hacheck
 
#Following code is to override components found from environment and use passed from command line option"
 if [ -n "$options_components" ]
 then
     components=$options_components
 fi
#this condition not to execute old code
if [ 1 -eq 2 ]
then
 #To execute only hacheck depending upon type of the database either RAC or SI
     if [[ "$components" = "HACHECK" || "$components" = "MAA" || "$components" = "MAA:HACHECK" || "$components" = "HACHECK:MAA" ]]; then only_hacheck_run=1;else only_hacheck_run=0;fi
     if [ `echo $options_components|grep -icw hacheck` -ge 1 ] 
     then
	 if [ $single_instance_run -eq 0 ]
	 then
	     components=$(echo ${components}|sed 's/HACHECK//')
	     components=$(echo ${components}:HACHECK)
	 else
	     components=$(echo ${components}|sed 's/HACHECK//')
	     components=$(echo ${components}|sed 's/SIDBHACHECK//')
	     components=$(echo ${components}:SIDBHACHECK)    
	 fi
     fi
     if [ `echo $options_components|grep -icw hacheck` -ge 0 ]
     then
	 if [[ "$TYP" = "-r" && $db_machine_compute -eq 0 ]]
	 then 
	     if [ $single_instance_run -eq 0 ]
	     then
		 components=$(echo ${components}:HACHECK)
	     elif [[ $single_instance_run -eq 1 ]]
	     then
		 components=$(echo ${components}:SIDBHACHECK)
	     else
		 components=$(echo ${components}|sed 's/:HACHECK//')
		 components=$(echo ${components}|sed 's/:SIDBHACHECK//')
	     fi
	 fi
	 if [ $upgrade_mode -eq 0 ]; then TYP=-a;fi
     fi

     if [ $only_hacheck_run -eq 1 ]; then TYP=-b;fi

     if [[ -n "$include_hacheck" && $include_hacheck -eq 0 ]]
     then
	     components=$(echo ${components}|sed 's/:HACHECK//')
	     components=$(echo ${components}|sed 's/:SIDBHACHECK//')
     fi
fi
#this is to change HACHECK to SIDBHACHECK for single instance run
 if [[ `echo $options_components|grep -icw hacheck` -ge 1 && $single_instance_run -eq 1 ]]
 then
    components=$(echo ${components}|sed 's/HACHECK//')
    components=$(echo ${components}|sed 's/SIDBHACHECK//')
    components=$(echo ${components}:SIDBHACHECK)
 fi             
 if [ -z "$components" ]
 then
     echo -e "\n\n${RED}Component is empty.\n\n${program_name} is exiting...${NORM}"
     exit 1
 fi
 final_components=$components
#read -p "final_components=$final_components"
 #if [ -n "$options_components" ]; then echo "${localnode}.COMPONENTS = $components" >>$MASTERFIL;fi
 #commented following function here and will call after asking root password because is_this_db_machine will be called once again
 #write_db_machine_info_to_envfile $localnode
 if [ $upgrade_mode -gt 0 ]; then echo "UPGRADE_MODE = $upgrade_mode" >>$MASTERFIL;fi
 #read -p "COMPONENTS = $components TYPE=$TYP"
}

# Format value in $l_version from 112030 to 11.2.0.3.0
format_l_version()
{
  if [ -z "$1" ]
  then
    l_version=$(echo $l_version | sed 's/[0-9]/&./g' | sed 's/\.//' | sed 's/.$//')
  else # For exalogic version is like 1.0.0.2
    l_version=$(echo $l_version | sed 's/[0-9]/&./g' | sed 's/.$//')
  fi
}

func_print_homes()
{
  stk_line_header_h="${stk_line_header}--------------------------"
  echo -e "\n\n${stk_line_header_h}" | tee -a $OUTPUTDIR/installed_components.out
  echo -e "                                       Installed components summary   $NORM                          "| tee -a $OUTPUTDIR/installed_components.out
  echo $stk_line_header_h | tee -a $OUTPUTDIR/installed_components.out
  #printf "%-11s " "$stk_host_header" | tee -a $OUTPUTDIR/installed_components.out
  printf "%-40s " "GI_HOME" | tee -a $OUTPUTDIR/installed_components.out
  printf "%-60s " "ORACLE_HOME" | tee -a $OUTPUTDIR/installed_components.out
  printf "%-30s\n" "Database Names" | tee -a $OUTPUTDIR/installed_components.out
  echo $stk_line_header_h | tee -a $OUTPUTDIR/installed_components.out
  #for node in `cat $HOSTLIST`
  #do
    node=$localnode
    crs_active_version=`grep "$node.CRS_ACTIVE_VERSION" $MASTERFIL |awk '{print $3}'`
    rm -f $OUTPUTDIR/mb_db_tmp.out
    mb_db_counter=0
    for db_name_to_check in "${mb_db_names[@]}"
    do
      #l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f2)
      l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_distinct.out|cut -d'|' -f2 |sort -u | head -1)
      format_l_version
      oh_version=$l_version
      running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL |awk '{print $3}'`
      echo "${mb_oracle_homes[$mb_db_counter]}|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
      mb_db_counter=$(expr $mb_db_counter + 1)
    done

    #printf "%-11s " $node;
    #printf "%-40s " "$CRS - $crs_active_version";
    first_time_print=0
    mb_db_counter=0
    if  [ -e $OUTPUTDIR/mb_db_tmp.out ]
    then
	for mb_oh_name in `cut -d'|' -f1  $OUTPUTDIR/mb_db_tmp.out |sort -u`
	do
	  oh_version=$(grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f2|sort -u)
          if [ $first_time_print -eq 0 ]
          then
            #printf "%-11s " $node| tee -a $OUTPUTDIR/installed_components.out
            printf "%-40s " "$CRS - $crs_active_version" | tee -a $OUTPUTDIR/installed_components.out
            #printf "%-11s " "";
            #printf "%-40s " "";
          else
            first_time_print=0
          fi
          printf "%-60s " "${mb_oh_name} - ${oh_version}" | tee -a $OUTPUTDIR/installed_components.out
	  running_db_line=""
	  for running_db in `grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f3|sort -u`
	  do
	    running_db_line="$running_db $running_db_line"
	  done # Finished printing db info for a OH
	  mb_db_counter=$(expr $mb_db_counter + 1)
          printf "%-30s\n" "$running_db_line" | tee -a $OUTPUTDIR/installed_components.out
	done # Finished printing all homes
        echo $stk_line_header_h | tee -a $OUTPUTDIR/installed_components.out
    fi
  mb_db_counter=0
}

func_print_homes_tree()
{
  echo -e "\n\n${stk_line_header}"
  echo -e "                                       Installed components summary   $NORM                          "
  echo $stk_line_header
  for node in `cat $HOSTLIST`
  do
    crs_active_version=`grep "$node.CRS_ACTIVE_VERSION" $MASTERFIL |awk '{print $3}'`
    echo -e "Host : $node\n" | tee -a $OUTPUTDIR/installed_components.out
    echo -e "  |-- GI_HOME - Version : $CRS - $crs_active_version\n" | tee -a $OUTPUTDIR/installed_components.out
    rm -f $OUTPUTDIR/mb_db_tmp.out
    mb_db_counter=0
    for db_name_to_check in "${mb_db_names[@]}"
    do
      l_version=$(grep "${mb_oracle_homes[$mb_db_counter]}" $OUTPUTDIR/mb_db_homes_versions_distinct.out|cut -d'|' -f2)
      format_l_version
      oh_version=$l_version
      running_instance=`grep "$node.$db_name_to_check.INSTANCE_NAME" $MASTERFIL |awk '{print $3}'`
      echo "${mb_oracle_homes[$mb_db_counter]}|${oh_version}|$db_name_to_check|$running_instance" >> $OUTPUTDIR/mb_db_tmp.out
      mb_db_counter=$(expr $mb_db_counter + 1)
    done

    mb_db_counter=0
    if  [ -e $OUTPUTDIR/mb_db_tmp.out ]
    then
	for mb_oh_name in `cut -d'|' -f1  $OUTPUTDIR/mb_db_tmp.out |sort -u`
	do
	  oh_version=$(grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f2|sort -u)
	  echo -e "    |-- ORACLE_HOME - Version : ${mb_oh_name} - ${oh_version}\n" | tee -a $OUTPUTDIR/installed_components.out 
	  for running_db in `grep "$mb_oh_name" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f3|sort -u`
	  do
	    echo -e "      |-- Database Name : $running_db" | tee -a $OUTPUTDIR/installed_components.out
	    running_instance=$(grep "$mb_oh_name|$oh_version|$running_db|" $OUTPUTDIR/mb_db_tmp.out |cut -d'|' -f4)
	    if [ -n "$running_instance" ]
	    then
	      echo "        |-- Instance Name: $running_instance" | tee -a $OUTPUTDIR/installed_components.out
	    fi
	    echo -e ""| tee -a $OUTPUTDIR/installed_components.out
	  done # Finished printing db info for a OH
	  mb_db_counter=$(expr $mb_db_counter + 1)
	done # Finished printing all homes
    fi
    echo -e "\n"| tee -a $OUTPUTDIR/installed_components.out
  done # Finished all nodes
  echo $stk_line_header
  mb_db_counter=0
}

func_stack_print ()
{
  offline_counter=0
  for node in `cat $HOSTLIST`
  do
    crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $MASTERFIL |awk '{print $3}'`
    stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $MASTERFIL|awk '{print $3}'`
    stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $MASTERFIL|awk '{print $3}'`
    stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $MASTERFIL|awk '{print $3}'`
    if [ $multiple_db -eq 1 ] 
    then
	db_status_counter=0
        mb_db_counter_local=0
        #added uniq not to display same instance names of container instance in case of pdbs are found 
	stack_db_instances[$offline_counter]=`grep -i "$node" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}'|uniq`
	#echo "instances on $node ${stack_db_instances[$offline_counter]}"
	for db_name_to_check in "${mb_db_names[@]}"
	do
	    if [[ $node = ${mb_running_host[$mb_db_counter_local]} ]] # && ! -z "`grep -i $node.${db_name_to_check}.INSTANCE_MODE  $MASTERFIL |awk '{print $3}'`" ]] 
	    then #remote_database_code
		stack_db_status[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
		stack_local_db_inst[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'` 
		#stack_db_name[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
#		echo "$db_name_to_check instance is  ${stack_local_db_inst[$db_status_counter]}"
		db_status_counter=$(expr $db_status_counter + 1)
	   fi 
          mb_db_counter_local=$(expr $mb_db_counter_local + 1)
	done
	db_status_counter=0
        mb_db_counter_local=0
    else
	stack_dbinst_name[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
	#if [ $node = $localnode ]
	#if [ ! -z "${stack_dbinst_name[$offline_counter]}" && `grep -ic "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL` -gt 0 ]]
	if [[ -n "${mb_running_host[0]}" && $node = ${mb_running_host[0]} ]]
	then 
	    stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
        else
            #added this else part to avoid below error when no database is running on local node and asm is up
            #./exachk: line 13666: [: too many arguments
	    stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
	#read -p " stack_db_status=${stack_db_status[$db_status_counter]}"
	fi;
	stack_dbinst_up[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
    fi
    offline_counter=`expr $offline_counter + 1`  
  done
  offline_counter=0
stk_line_header="-------------------------------------------------------------------------------------------------------"
	     r="-----------------------------------------------------------------------------------"
stk_host_header="Host Name"
stk_crs_installed_header="CRS Installed"
stk_asm_installed_header="ASM HOME"
stk_rdbms_installed_header="RDBMS Installed"
stk_crs_header="CRS UP"
stk_asm_header="ASM UP"
stk_rdbms_header="RDBMS UP"
stck_dbinst_name="DB Instance Name"
stk_status_no="No"
stk_status_yes="Yes"
stk_status_na="N/A"
echo $stk_line_header
#echo -e "                                   $BLINK $BOLD Oracle Stack Status  $NORM                          "
echo -e "                                                 Oracle Stack Status  $NORM                          "
echo $stk_line_header
echo $stk_host_header|awk '{printf "%-11s",$stk_host_header}'
echo $stk_crs_installed_header|awk '{printf "%-15s",$stk_crs_installed_header}'
echo $stk_asm_installed_header|awk '{printf "%-15s",$stk_asm_installed_header}'
echo $stk_rdbms_installed_header|awk '{printf "%-17s",$stk_rdbms_installed_header}'
echo $stk_crs_header|awk '{printf "%-10s",$stk_crs_header}'
echo $stk_asm_header|awk '{printf "%-10s",$stk_asm_header}'
echo $stk_rdbms_header|awk '{printf "%-10s",$stk_rdbms_header}'
echo $stck_dbinst_name|awk '{printf "%-15s\n",$stk_rdbms_header}'
echo $stk_line_header
for stk in `cat $HOSTLIST`
do
 echo $stk|awk '{printf "%-11s",$stk}'
 if [[ -n "${crs_installed[$offline_counter]}" && ${crs_installed[$offline_counter]} -eq 1 ]]
 then
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-30s",$stk_status_yes}'
 else
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-30s",$stk_status_no}'
 fi

 if [[ -n "${asm_installed[$offline_counter]}" && ${asm_installed[$offline_counter]} -eq 1 ]]
 then
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-30s",$stk_status_yes}'
 else
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-30s",$stk_status_no}'
 fi
 if [ ${rdbms_installed[$offline_counter]} -eq 0 ]
 then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-30s",$stk_status_no}'
 else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-30s",$stk_status_yes}'
 fi
 if [ ${stack_crs_up[$offline_counter]} -eq 0 ]
 then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-25s",$stk_status_no}'
 else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-25s",$stk_status_yes}'
 fi
 if [ ${stack_asm_up[$offline_counter]} -eq 0 ]
 then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-23s",$stk_status_no}'
 else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-23s",$stk_status_yes}'
 fi
 if [[ ${stack_dbinst_up[$offline_counter]} -eq 0 && $multiple_db -eq 0 ]]
 then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-23s",$stk_status_no}'
 else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-23s",$stk_status_yes}'
 fi
 if [ $multiple_db -eq 0 ]
 then
     if [ ${stack_dbinst_up[$offline_counter]} -eq 1 ]
     then
	 stk_inst_name=${stack_dbinst_name[$offline_counter]}
	 echo -e $GREEN ${stack_dbinst_name[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
     else
	 stk_inst_name=${stack_dbinst_name[$offline_counter]}
	 echo -e $GREEN ${stack_dbinst_name[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
	   
     fi
 else
     #if [ ${stack_db_status[$offline_counter]} -ne 0 ]
     if [[ -n "${stack_db_status[$offline_counter]}" && ${stack_db_status[$offline_counter]} -ne -1 ]]
     then
	 stk_inst_name=${stack_db_instances[$offline_counter]}
	 echo -e $GREEN ${stack_db_instances[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
     else
	 stk_inst_name=${stack_db_instances[$offline_counter]}
	 echo -e $GREEN ${stack_db_instances[$offline_counter]} $NORM|awk '{printf "%-25s\n",$stk_inst_name}'
	   
     fi
#      echo -e "\n"
 fi
offline_counter=`expr $offline_counter + 1`
done
offline_counter=0
echo $stk_line_header
}
func_stack_print_aix ()
{
  offline_counter=0
  for node in `cat $HOSTLIST`
  do
    crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $MASTERFIL |awk '{print $3}'`
    asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $MASTERFIL |awk '{print $3}'`
    stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $MASTERFIL|awk '{print $3}'`
    stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $MASTERFIL|awk '{print $3}'`
    stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $MASTERFIL|awk '{print $3}'`
    stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $MASTERFIL|awk '{print $3}'`
    if [ $multiple_db -eq 1 ]
    then
        db_status_counter=0
        mb_db_counter_local=0
        #added uniq not to display same instance names of container instance in case of pdbs are found 
        stack_db_instances[$offline_counter]=`grep -i "$node" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}'|uniq`
        #echo "instances on $node ${stack_db_instances[$offline_counter]}"
        for db_name_to_check in "${mb_db_names[@]}"
        do
            if [ $node = ${mb_running_host[$mb_db_counter_local]} ]
            then
                stack_db_status[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
                stack_local_db_inst[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
                #stack_db_name[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
#               echo "$db_name_to_check instance is  ${stack_local_db_inst[$db_status_counter]}"
                db_status_counter=$(expr $db_status_counter + 1)
           fi
           mb_db_counter_local=$(expr $mb_db_counter_local + 1)
        done
        db_status_counter=0
        mb_db_counter_local=0
    else
        stack_dbinst_name[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
        if [ "$node" = "${mb_running_host[0]}" ]
        then
            stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
        #read -p " stack_db_status=${stack_db_status[$db_status_counter]}"
        fi;
        stack_dbinst_up[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
    fi
    #stack_dbinst_up[$offline_counter]=`grep -i "$node.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
    #stack_dbinst_name[$offline_counter]=`grep -i "$node.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
    offline_counter=`expr $offline_counter + 1`
  done
  offline_counter=0
stk_line_header="-------------------------------------------------------------------------------------------------------"
	     r="-----------------------------------------------------------------------------------"
stk_host_header="Host Name"
stk_crs_installed_header="CRS Installed"
stk_asm_installed_header="ASM HOME"
stk_rdbms_installed_header="RDBMS Installed"
stk_crs_header="CRS UP"
stk_asm_header="ASM UP"
stk_rdbms_header="RDBMS UP"
stck_dbinst_name="DB Instance Name"
stk_status_no="No"
stk_status_yes="Yes"
stk_status_na="N/A"
echo $stk_line_header
#echo -e "                                   $BLINK $BOLD Oracle Stack Status  $NORM                          "
echo -e "                                                 Oracle Stack Status  $NORM                          "
echo $stk_line_header
echo $stk_host_header|awk 'BEGIN { FS = "," } ;{printf "%-11s",$1}'
echo $stk_crs_installed_header|awk 'BEGIN { FS = "," } ;{printf "%-15s",$1}'
echo $stk_asm_installed_header|awk 'BEGIN { FS = "," } ;{printf "%-15s",$1}'
echo $stk_rdbms_installed_header|awk 'BEGIN { FS = "," } ;{printf "%-17s",$1}'
echo $stk_crs_header|awk 'BEGIN { FS = "," } ;{printf "%-10s",$1}'
echo $stk_asm_header|awk 'BEGIN { FS = "," } ;{printf "%-10s",$1}'
echo $stk_rdbms_header|awk 'BEGIN { FS = "," } ;{printf "%-10s",$1}'
echo $stck_dbinst_name|awk 'BEGIN { FS = "," } ;{printf "%-15s\n",$1}'
echo $stk_line_header
for stk in `cat $HOSTLIST`
do
 echo $stk|awk 'BEGIN { FS = "," } ;{printf "%-11s",$1}'
 if [ ${crs_installed[$offline_counter]} -eq 0 ]
 then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-15s",$2}'
 else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-15s",$2}'
 fi
 if [ ${asm_installed[$offline_counter]} -eq 0 ]
 then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-15s",$2}'
 else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-15s",$2}'
 fi
 if [ ${rdbms_installed[$offline_counter]} -eq 0 ]
 then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-17s",$2}'
 else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-17s",$2}'
 fi
 if [ ${stack_crs_up[$offline_counter]} -eq 0 ]
 then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-10s",$2}'
 else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-10s",$2}'
 fi
 if [ ${stack_asm_up[$offline_counter]} -eq 0 ]
 then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-10s",$2}'
 else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-10s",$2}'
 fi
 if [[ ${stack_dbinst_up[$offline_counter]} -eq 0 && $multiple_db -eq 0 ]]
 then
      echo -e $RED $stk_status_no $NORM|awk '{printf "%-10s",$2}'
 else
      echo -e $GREEN $stk_status_yes $NORM|awk '{printf "%-10s",$2}'
 fi
 if [ $multiple_db -eq 0 ]
 then
     if [ ${stack_dbinst_up[$offline_counter]} -eq 1 ]
     then
         stk_inst_name=${stack_dbinst_name[$offline_counter]}
         echo -e  ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
     else
         stk_inst_name=${stack_dbinst_name[$offline_counter]}
         echo -e ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
     fi
 else
     if [[ -n "$${stack_db_status[$offline_counter]}" && ${stack_db_status[$offline_counter]} -ne 0 ]]
     then
         stk_inst_name=${stack_db_instances[$offline_counter]}
         echo -e ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
     else
         stk_inst_name=${stack_db_instances[$offline_counter]}
         echo -e ${stk_inst_name}|awk 'BEGIN { FS = "\n" } ;{printf "%-25s\n",$1}'
     fi
 fi
offline_counter=`expr $offline_counter + 1`
done
offline_counter=0
echo $stk_line_header
}

func_cells_stack_status ()
{
  cell_counter=0
  for cell_ip in `cat /etc/oracle/cell/network-config/cellip.ora |cut -d\" -f2`
  do
    
    cell_host[$cell_counter]=$(ssh $cell_ip hostname -s)
    cell_cellsrv[$cell_counter]=$(ssh $cellip su - celladmin "cellcli -e \"list cell attributes cellsrvStatus\"|grep -wc \"running\"")
    cell_msstatus[$cell_counter]=$(ssh $cellip su - celladmin "cellcli -e \"list cell attributes msStatus\"|grep -wc \"running\"")
    cell_rsstatus[$cell_counter]=$(ssh $cellip su - celladmin "cellcli -e \"list cell attributes rsStatus\"|grep -wc \"running\"")
    echo $cell_host $cell_cellsrv $cell_msstatus $cell_rsstatus
  done  
}

#this function will check space for two locations
#1.Current location from where tool will run
#2. $TMPDIR because this tool uses tmp to for temporary files movement among cluster nodes
func_check_space()
{
 min_curr_space=10240
 #min_curr_space=137758049
 min_tmp_space=5120
# min_tmp_space=1377678890000
 curr_location=$CHECKHOME
 tmp_location=/tmp
 space_status=0
 space_pass_msg=""
 space_fail_msg=""
 for space in `cat $HOSTLIST`
 do
   if [ $space = $localnode ]
   then
     if [ `uname -s` = "HP-UX" ] ; then
       space_curr_location=`df -k $curr_location| grep free |awk '{print $1}'`
       space_tmp_location=`df -k $tmp_location| grep free |awk '{print $1}'`
     else
       awk_col=`df -k  $curr_location|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`
       awk_col_tmp=`df -k  $tmp_location|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`
       if [ $awk_col  -gt 0 ]
       then
	   space_curr_location=`df -k $curr_location| grep -iv "avail" | awk '{ print $3}'|tail -1`  
       else
	   space_curr_location=`df -k $curr_location| grep -iv "avail" | awk '{ print $4}'`
       fi 
       if [ $awk_col_tmp  -gt 0 ]
       then
	   space_tmp_location=`df -k $tmp_location |grep -iv "avail" | awk '{ print $3}'|tail -1 `  
       else
	   space_tmp_location=`df -k $tmp_location |grep -iv "avail" | awk '{ print $4}'`
       fi 
     fi
       if [ $min_curr_space -lt $space_curr_location ]
       then
	    space_pass_msg="Space available on $space at $curr_location is $space_curr_location KB"
	    curr_loc_space_status=0
       else
	    space_fail_msg="${RED}Space available on $space at $curr_location is $space_curr_location KB and required space is $min_curr_space KB $NORM"
	    curr_loc_space_status=1
       fi
       #read -p "space_pass_msg =$space_pass_msg and space_fail_msg =$space_fail_msg"
       if [ $min_tmp_space -lt $space_tmp_location ]
       then
	    space_pass_msg="$space_pass_msg \nSpace available on $space at $tmp_location is $space_tmp_location KB"
	    local_tmp_space_status=0
       else
	   space_fail_msg="$space_fail_msg $RED \nSpace available on $space at $tmp_location is $space_tmp_location KB and required space is $min_tmp_space KB $NORM "
	    local_tmp_space_status=1
       fi
	 #read -p "space_curr_location=$space_curr_location space_tmp_location=$space_tmp_location min_curr_space=$min_curr_space and min_tmp_space=$min_tmp_space"
   else
     if [ `uname -s` = "HP-UX" ] ; then
       space_tmp_location=`$SSHELL $space df -k $tmp_location| grep free |awk '{print $1}'`
     else
       awk_col_tmp=`$SSHELL $space df -k  $tmp_location|grep -iv "avail" | awk '{ print $4}'|grep -c "%"`
       if [ $awk_col_tmp  -gt 0 ]
       then
	   space_tmp_location=`$SSHELL $space df -k $tmp_location |grep -iv "avail" | awk '{ print $3}'|tail -1`  
       else
	   space_tmp_location=`$SSHELL $space df -k $tmp_location |grep -iv "avail" | awk '{ print $4}'`
       fi 
     fi 
       if  [ $min_tmp_space -lt $space_tmp_location ]
       then
	   space_pass_msg="$space_pass_msg \nSpace available on $space at $tmp_location is $space_tmp_location KB"
	   remote_tmp_space_status=0
       else
	   space_fail_msg="$space_fail_msg $RED \nSpace available on $space at $tmp_location is $space_tmp_location KB and required space is $min_tmp_space KB $NORM"
	   remote_tmp_space_status=1
       fi
   fi
 done
 if [[ $curr_loc_space_status -eq 1 || $local_tmp_space_status -eq 1 || $remote_tmp_space_status -eq 1 ]]; then space_status=1;else space_status=0;fi;
}
#Function to compare rpm versions
function compare_rpmversion()
{
  unset rpm_dot1
  unset rpm_dot2
  local IFS=$'.'
  vd_counter1=0
  digits1=0
  for vd in $1
  do
    if [ `echo $vd|grep -c "_" ` -ge 1 ]
    then
	vd=$(echo $vd|cut -d_ -f1)
    fi  
    rpm_dot1[$vd_counter1]=$vd
    vd_counter1=$(expr $vd_counter1 + 1)
  done
  vd_counter2=0
  digits2=0
  for vd in $2
  do
    if [ `echo $vd|grep -c "_" ` -ge 1 ]
    then
	vd=$(echo $vd|cut -d_ -f1)
    fi  
    rpm_dot2[$vd_counter2]=$vd
    vd_counter2=$(expr $vd_counter2 + 1)
  done
  loop_digits=0
  while [ "$loop_digits" -lt "$vd_counter1" ]
  do
     isdigit=$(echo ${rpm_dot1[$loop_digits]}|grep -E '^[0-9]+$')
     if [ -n "$isdigit" ]
     then
	 #echo "went to numeric comparision"
	 if [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" -eq "${rpm_dot1[$loop_digits]}" ]]
	 then
	     func_rpm_status=0
	     #read -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
	 elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" -gt "${rpm_dot1[$loop_digits]}" ]]
	 then
	    func_rpm_status=1
	    #read -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
	    return
	 elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" -lt "${rpm_dot1[$loop_digits]}" ]]
	 then
	    func_rpm_status=2
	    #read -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
	    return
	fi
     else
	 #echo "went to string comparision"
	if [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" = "${rpm_dot1[$loop_digits]}" ]]
	then
	    func_rpm_status=0
	    #read -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
	elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" > "${rpm_dot1[$loop_digits]}" ]]
	then
	    func_rpm_status=1
	    #read -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
	    return
	elif [[ -n "${rpm_dot1[$loop_digits]}" && "${rpm_dot2[$loop_digits]}" < "${rpm_dot1[$loop_digits]}" ]]
	then
	    func_rpm_status=2
	   # read -p "reco=${rpm_dot1[$loop_digits]} actual=${rpm_dot2[$loop_digits]} and func_rpm_status=$func_rpm_status"
	    return
	fi
     fi
     loop_digits=$(expr $loop_digits + 1)
  done
}
function nodelist_without_olsnodes ()
{

 printf  $RED"Unable to determine nodes in cluster.  Do you want to enter manually.[y/n][y]"$NORM
 read readNodeNames
 case $readNodeNames in
     y|Y|yes|YES|Yes)
     echo `hostname|cut -d. -f1`>$HOSTLIST
     echo "Enter cluster node names delimited by comma.by defalut localhost will be printed. (eg. node2,node3,node4)"
     printf "`hostname|cut -d. -f1`,"
     read nodeList
     echo $nodeList|awk 'BEGIN {RS=","} {print}'|sed '/^$/d'>>$HOSTLIST   
     ;;
     n|N|No|NO) 
     echo ""
     echo `hostname|cut -d. -f1`>$HOSTLIST
     echo -e $RED"Since you did not enter any node names, this script will execute only on the local node.\n"$NORM
     echo "Since you did not enter any node names, this script will execute only on the local node\n" >>$LOGFIL
     echo "">>$LOGFIL
     ;;
     *)
       echo `hostname|cut -d. -f1`>$HOSTLIST
       echo "Enter cluster node names delimited by comma.by default localhost will be printed (eg. node2,node3,node4)"
       printf "`hostname|cut -d. -f1`,"
      read nodeList
      echo $nodeList|sed 's/,/\n/g'>>$HOSTLIST   
      ;;
 esac
}
function func_what_platform ()
{
 os_name=$(uname -s)
 case  ${os_name} in
 Linux)
    #os_bit=$( file $(/sbin/modinfo $(/sbin/lsmod|grep ext|head -1|awk '{print $1}')|grep filename|awk '{print $2}')|awk '{print $3}'|cut -d- -f1)      
    os_bit=$( file /sbin/modinfo |awk '{print $3}'|cut -d- -f1 )
    if [ $os_bit -eq 64 ]
    then
	os_arch="X8664"
	os_arch_env_file="X86-64"
    elif [ $os_bit -eq 32 ]
    then
       os_arch="X86"
       os_arch_env_file="X86"
    fi
    if [ -f /etc/redhat-release ] 
    then
	os_type_full="OELRHEL"
	os_version=$(cat /etc/redhat-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
        if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 && `grep -icw "vm server" /etc/redhat-release` -ge 1 && $os_version -eq 3 ]];then os_version=5;fi
    elif [ -f /etc/SuSE-release ] 
    then
	 os_type_full="Suse" 
	 os_version=$(cat /etc/SuSE-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
         if [ -z "$os_version" ]; then os_version=$(cat /etc/SuSE-release|grep -i version|awk '{print $3}');fi 
    else
	 os_type_full="Unsupported OS"
    fi
   what_os=$(echo ${os_name}${os_arch}${os_type_full}${os_version}|tr "[a-z]" "[A-Z]")
 ;;
 SunOS)
    os_bit=$(/usr/bin/isainfo -b)     
    os_version=$(uname -r |cut -d. -f2)
    os_arch=$(uname -p|tr "[a-z]" "[A-Z]")
    if [ "$os_arch" = "I386" ]; then os_arch="X86";os_arch_env_file="X86";fi
    os_arch_env_file=$(echo "(${os_arch}${os_bit}-BIT)")
    os_name="SOLARIS"
    #read -p "${os_name}${os_arch_env_file}"
    what_os=$(echo ${os_name}${os_arch}${os_bit}${os_version})
    #read -p "what os $what_os"
 ;;
 AIX)
     os_bit=$(getconf -a | grep KERN|cut -d: -f2|awk '{print $1}')
     os_version=$(oslevel|awk 'BEGIN { FS = "." } ;{print $1$2}')
     os_name=$(uname -s)
     os_arch=$(uname -p)
     if [ $os_arch = "powerpc" ]; then os_arch="PPC"; fi
     what_os=$(echo ${os_name}${os_arch}${os_bit}${os_version}|sed 's/ //g')
     os_version_env_file=$(oslevel|cut -d. -f1)
     os_name=$(echo ${os_name}${os_version_env_file})
     if [ $os_version_env_file -eq 5 ]; then os_name=$(echo "${os_name}L");fi
     os_arch_env_file=$(echo "(${os_bit}-BIT)")
  ;;
 HP-UX)
     os_name="HPUX"
     os_arch=$(uname -m)
     if [ $os_arch = "ia64" ]; then os_arch="Itanium" ; else os_arch="PARISC"; fi;
     os_version=$(uname -r |  sed 's/[^0-9]*\([0-9][0-9]*\)[^0-9]*/\1/g')
     what_os=$(echo ${os_name}${os_arch}${os_version})
     os_bit=$(getconf KERNEL_BITS);
     if [ "$(uname -m)" = "ia64" ]
     then
         os_arch_env_file=$(echo $(uname -s) $os_arch|tr "[a-z]" "[A-Z]")
     else
         os_bit=$(getconf KERNEL_BITS);
         os_arch_env_file=$(echo $(uname -s) PA-RISC "(${os_bit}-BIT)")
     fi
 ;;
 *)
     os_arch="Not supported OS"
     exit 1;
 ;;
 esac
}

function func_what_db()
{
 if [ ${rdbms_installed[0]} -eq 1 ]
 then
     what_db=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed 's/\.//g'|sed '/^$/d')
     DBVERSION=$($ORACLE_HOME/bin/sqlplus -v|awk '{print $3}'|sed '/^$/d')
 else
    what_db="NODATABASE"
    DBVERSION="NODATABASE"  
 fi
}

# Create small file with only checks from profile
function select_collections4profile
{
  #echo Started selecting profile checks : `date`
  bs_reffil=$INPUTDIR/collections.dat.beforeselect
  targetVesionCheckFil=$INPUTDIR/collections.dat.tvc
  cp -f $INPUTDIR/collections.dat $bs_reffil
  grep ".-CHECK_ID" $INPUTDIR/collections.dat > $INPUTDIR/cm.dat
  echo > $INPUTDIR/collections.dat
  #create checks with targetversion values from collections.dat
  if [ $upgrade_mode -eq 2 ]
  then
      grep -w "TARGET_VERSION" $bs_reffil|sed 's/\.//g'|grep $targetversion|cut -d- -f1|sed 's/_//g'>$targetVesionCheckFil
  elif [ $upgrade_mode -eq 3 ]
  then
      grep -w "COMPONENTS" $bs_reffil|grep POSTUPGR|cut -d- -f1|sed 's/_//g'>$targetVesionCheckFil
  fi
  #####################
  cur_check_index=1
  selected_collect_count=0
  selected_root_count=0
  
  cindex_collect=$(grep "OS_COLLECT_COUNT" $bs_reffil|cut -d. -f1|sed 's/_//g')
  cindex_root=$(grep "REQUIRES_ROOT_COUNT" $bs_reffil|cut -d. -f1|sed 's/_//g')

  if [[ $OFFLINE -eq "0" && -n "$run_profile" && $run_profile -eq "1" ]] ; then
    echo "PROFILE_RUN = 1">>$MASTERFIL
    echo "PROFILES = $profileids2run">>$MASTERFIL
    echo "PROFILE_NAMES = $profiles2run">>$MASTERFIL
  fi

  previous_index="";

  while read cline
  do
    CHECK_ID=$(echo "$cline" | awk '{print $3}');
    cindex=$(echo "$cline" | sed 's/\..*//' |sed 's/_//')

    in_profile=0
    if [[ -n "$run_profile" && $run_profile -eq "1" ]]
    then
        check_in_profiles
    elif [ $upgrade_mode -ge 2 ]
    then
        check_in_targetversion
    fi
    if [[ $in_profile -eq "1" ]]
    then
      if [[ `grep -c ".-CHECK_ID $CHECK_ID" $INPUTDIR/collections.dat` -eq 0 ]]
      then # Add only if it does not exists already
        #if [ -z "$previous_index" ] ; then previous_index=$cindex; fi
        #if [ $cindex -ne $previous_index ] ; then
        #  index_to_print=$(expr $cur_check_index + 1)
        #  increment_index=1
        #  previous_index=$cindex
        #else
        #  index_to_print=$cur_check_index
        #  increment_index=0
        #fi
        grep "_$cindex\." $bs_reffil | grep -v "OS_COLLECT_COUNT" | grep -v "REQUIRES_ROOT_COUNT" | sed 's/_'$cindex'\./_'${cur_check_index}'./' >> $INPUTDIR/collections.dat
        #echo $cline | grep -v "OS_COLLECT_COUNT" | grep -v "REQUIRES_ROOT_COUNT" | sed 's/_'$cindex'\./_'${index_to_print}'./' >> $INPUTDIR/collections.dat
        check_type=$(grep "_${CHECK_ID}-TYPE" $bs_reffil | awk '{print $2}');
        require_root=$(grep "_${CHECK_ID}-REQUIRES_ROOT" $bs_reffil | awk '{print $2}');
        if [[ -n "$check_type" && $check_type = "OS_COLLECT" ]] ; then
          selected_collect_count=$(expr $selected_collect_count + 1)
        fi
        if [[ -n "$require_root" && $require_root -eq "1" ]] ; then
          selected_root_count=$(expr $selected_root_count + 1)
        fi
        #if [[ $increment_index -eq "1" ]] ; then
        cur_check_index=$(expr $cur_check_index + 1)
        #fi
      fi
    fi
    if [[ $cindex_collect -eq $cindex ]] ; then
      echo "_$cur_check_index.0.0.0.0.0.0.0.0.0-OS_COLLECT_COUNT $selected_collect_count" >> $INPUTDIR/collections.dat
      osCheckIndexNo=$cur_check_index
      cindex_collect=0
    fi
    if [[ $cindex_root -eq $cindex ]] ; then
      echo "_$cur_check_index.0.0.0.0.0.0.0.0.0-REQUIRES_ROOT_COUNT $selected_root_count" >> $INPUTDIR/collections.dat
      cindex_root=0
    fi

  done < $INPUTDIR/cm.dat 
  rm -f $INPUTDIR/cm.dat
  sed -n /COLLECTIONS_START/,/COLLECTIONS_END/p $bs_reffil >> $INPUTDIR/collections.dat
  #echo Done selecting profile checks : `date`
  #cp $bs_reffil $OUTPUTDIR/collections_org.dat
  rm -f $bs_reffil $targetVesionCheckFil >/dev/null 2>&1
  #cp $INPUTDIR/collections.dat $OUTPUTDIR/collections_saved.dat
  ##read -p "stop"
}
#multiple version support
# create collection.dat file for clusterware. it will be base version. 
# say we have 11202 clusterware & 11107 and 10204 databases
# we loop through check-ids. if for any checkid needs_running=RDBMS or 
# PARAM_PATH=RDBMS then we write the database next to same checkid if 
# its there in basefile
# if not then we add at the end

function append_version_checks ()
{
  #if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; return; fi;
   
  cur_check_index=$(grep ".-CHECK_ID" $INPUTDIR/collections.dat |tail -1 | sed 's/\..*//' |sed 's/_//')
  rm -f $INPUTDIR/insert.dat
  cp -f $INPUTDIR/collections.dat $INPUTDIR/collections.dat.beforemerge
  if [ -z "$stk_line_header" ]; then stk_line_header=$fmt_line_header;fi
  echo -e "\n$stk_line_header" 
  printf "Found multiple combinations of Clusterware and RDBMS versions. Preparing necessary checks.This will take some time.  Be Patient\n"
  echo -e "$stk_line_header\n"
  # If there is no database with $CRSVERSION, then we need to add it
  crs_version_in_loop="";
  if [[ -n "${mb_oracle_versions_distinct[@]}" && ` echo ${mb_oracle_versions_distinct[@]}|grep -icw $CRSVERSION` -eq 0 ]]
  then
    crs_version_in_loop="$CRSVERSION";
  fi

  for mb_db_version in ${mb_oracle_versions_distinct[@]} $crs_version_in_loop
  do
    #if [ "xxx${CRSVERSION}" != "${mb_db_version}" ]
    #then # Already exists in collection.dat.. commented as we need to update 
      if [ $OFFLINE -eq 0 ]
      then
        grp_str=$(echo ${what_os}"_"${mb_db_version})
      else
        what_os_offline=$(grep "grp_str" $DUMPDIR/$CHKFIL |awk '{print $3}'|cut -d_ -f1)
        grp_str=$(echo ${what_os_offline}"_"${mb_db_version})
      fi
      grp_str=$(echo ${grp_str}"-")
      $GREP $grp_str $reffil_old >$INPUTDIR/collections_new_${mb_db_version}.dat
      sed 's/'$grp_str'//g' $INPUTDIR/collections_new_${mb_db_version}.dat > $INPUTDIR/collections_${mb_db_version}.dat
      sed 's///g' $INPUTDIR/collections_${mb_db_version}.dat >$INPUTDIR/collections_new_${mb_db_version}.dat
      cp $INPUTDIR/collections_new_${mb_db_version}.dat $INPUTDIR/collections_${mb_db_version}.dat
      rm $INPUTDIR/collections_new_${mb_db_version}.dat
  
      # Go through all collections_new_${mb_db_version}.dat and update collections.dat
      merge_version_dat;
      if [ -f "$INPUTDIR/insert_${mb_db_version}.dat" ]
      then
        cat $INPUTDIR/insert_${mb_db_version}.dat >> $INPUTDIR/insert.dat #fordebug
        cp -f $INPUTDIR/collections.dat $INPUTDIR/collections.dat.saved
        sed -n /_1.0.0.0.0.0.0.0.0.0-LEVEL.1-/,/COLLECTIONS_START/p $INPUTDIR/collections.dat.saved |grep -v COLLECTIONS_START > $INPUTDIR/collections.dat
        cat $INPUTDIR/insert_${mb_db_version}.dat >> $INPUTDIR/collections.dat
        sed -n /COLLECTIONS_START/,/COLLECTIONS_END/p $INPUTDIR/collections.dat.saved >> $INPUTDIR/collections.dat
        rm -f $INPUTDIR/insert_${mb_db_version}.dat
        rm -f $INPUTDIR/insert_${mb_db_version}.log
      fi
      rm -f $INPUTDIR/update_${mb_db_version}.dat
      rm -f $INPUTDIR/collections_${mb_db_version}.dat
    #fi
  done
  echo ""
  rm -f $INPUTDIR/insert.dat 
  rm -f $INPUTDIR/collections.dat.beforemerge
  rm -f $INPUTDIR/collections.dat.saved
  
}

function merge_version_dat ()
{
  #printf "\nSearching for new checks to run for version ${mb_db_version}..."
  #read -p "merging $INPUTDIR/collections_${mb_db_version}.dat to $INPUTDIR/collections.dat"
  grep ".-CHECK_ID" $INPUTDIR/collections_${mb_db_version}.dat > $INPUTDIR/cm.dat
  if [[ -n $RAT_DEBUG_V ]] ; then date; fi;
  while read cline
  do
    check_id=$(echo "$cline" | awk '{print $3}');
    merge_this_check=0

    if [[ `grep -c "$check_id-PARAM_PATH RDBMS" $INPUTDIR/collections.dat` -gt 0 || `grep -c "$check_id-NEEDS_RUNNING RDBMS" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-HOME_PATH RDBMS" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-TYPE SQL" $INPUTDIR/collections.dat` -gt 0 ]]
    then  # check need tobe merged
      merge_this_check=1
    fi;

    if [[ `grep -c "$check_id-PARAM_PATH ASM" $INPUTDIR/collections.dat` -gt 0 || `grep -c "$check_id-NEEDS_RUNNING ASM" $INPUTDIR/collections.dat` -gt 0  || `grep -c "$check_id-HOME_PATH ASM" $INPUTDIR/collections.dat` -gt 0  ]]
    then  # ignore ASM
      merge_this_check=0
    fi;

    if [[ $merge_this_check -eq "1" ]]
    then
      if [[ `grep -c ".-CHECK_ID $check_id" $INPUTDIR/collections.dat` -gt 0 ]]
      then # Exists in base file, just update version
        echo "Update: $cline" >> $INPUTDIR/update_${mb_db_version}.dat #fordebug
        cp -f $INPUTDIR/collections.dat $INPUTDIR/collections.dat.saved
        sed 's/CHECK_ID '$check_id'/CHECK_ID '$check_id' '${mb_db_version}'/' $INPUTDIR/collections.dat.saved > $INPUTDIR/collections.dat
      else # add a new row
        printf ". "
        if [[ -f "$INPUTDIR/insert_${mb_db_version}.dat" && `grep -c ".-CHECK_ID $check_id" $INPUTDIR/insert_${mb_db_version}.dat` -gt 0 ]]
        then #inserted already
          echo "Already inserted : $cline" >> $INPUTDIR/insert_${mb_db_version}.log
        else
          echo "Insert: $cline" >> $INPUTDIR/insert_${mb_db_version}.log
          cur_check_index=$(expr $cur_check_index + 1)
          cindex=$(echo "$cline" | sed 's/\..*//' |sed 's/_//')
          echo "Old: " >> $INPUTDIR/insert_${mb_db_version}.log
          grep "_$cindex\." $INPUTDIR/collections_${mb_db_version}.dat >> $INPUTDIR/insert_${mb_db_version}.log
          echo "New: " >> $INPUTDIR/insert_${mb_db_version}.log
          grep "_$cindex\." $INPUTDIR/collections_${mb_db_version}.dat | sed 's/_'$cindex'\./_'${cur_check_index}'./' | awk '{print $0" "'${mb_db_version}' }'>> $INPUTDIR/insert_${mb_db_version}.log
          grep "_$cindex\." $INPUTDIR/collections_${mb_db_version}.dat | sed 's/_'$cindex'\./_'${cur_check_index}'./' | awk '{print $0" "'${mb_db_version}' }'>> $INPUTDIR/insert_${mb_db_version}.dat
        fi
      fi
    fi
  done < $INPUTDIR/cm.dat
  rm -f $INPUTDIR/cm.dat
}

function set_skip_this_version()
{
  l_mb_db_homes="$1"
  skip_this_version=0
  l_mb_db_home_dname="all"
  if [[ $l_mb_db_homes = "-" ]]
  then
    if [ $OFFLINE -eq 0  ]
    then
      l_mb_db_homes="${mb_oracle_homes[$mb_db_counter]}"
    else
      l_mb_db_homes=$(grep -w "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
    fi
    l_mb_db_home_dname="$db_name_to_check"
  fi

  if [[ $RAT_RUNMODE_INTERNAL = "slave" ]] && [[ $COMTYPE = "SQL_COLLECT" || $COMTYPE = "SQL" || $COMTYPE = "SQL_OUT_CHECK" ]] ; then
    skip_this_version=1
    call_get_log_result=0
  fi

  #if [[ $crsdb_mixed_version=1 && -z $versions_to_run && $COMTYPE = "ORACLE_PATCH"  ]]
  #then # We assumed that all checks with CRSVERSION should be run on all databases. But when crs version is 112 and db is 102, 112 patch checks are run on 10.2 db.
  #  versions_to_run=$CRSVERSION
  #  run_in_multiple_versions=1
  #  echo "Skipping patch check for $CRSVERSION"
  #fi

  if [[ $run_in_multiple_versions -eq 1 ]]
  then
    if [ $OFFLINE -eq 0  ]
    then
      current_version=$(grep "RDBMS_ORACLE_HOME = $l_mb_db_homes" $MASTERFIL|awk '{print $3}'|cut -d '|' -f2)
    else
      current_version=$(grep "RDBMS_ORACLE_HOME = $l_mb_db_homes" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f2)
    fi
    if [[ -n "$current_version" && `echo "$versions_to_run" | grep -ic "$current_version"` -eq 0 ]]
    then #dont run
      skip_this_version=1
      call_get_log_result=0
    else
      call_get_log_result=1
    fi
  fi

  # In upgrade mode, we need to skip checks on some versions which are not upgraded
  if [[ $upgrade_mode -gt 0 && ${mb_skip[$mb_db_counter]} -eq "1" ]]
  then
      skip_this_version=1
      call_get_log_result=0
  fi

  # Incase of a branch, a check needs to executed only if the branch succeded on the db
  if [[ $skip_this_version -eq "0" && $CUR_LEVEL -gt "1" ]]
  then
    prev_level=$(expr $CUR_LEVEL - 1)
    if [[ -n "${m_opstat[$prev_level]}" && `echo ${m_opstat[$prev_level]} | grep -ic $l_mb_db_homes-$l_mb_db_home_dname` -eq "0"  && `echo ${m_opstat[$prev_level]} | grep -ic $l_mb_db_homes-all` -eq "0" ]]
    then
      if [[ $l_mb_db_home_dname = "all" && `echo ${m_opstat[$prev_level]} | grep -ic $l_mb_db_homes-` -gt "0" ]] ; then
        # passed on some db. so should not skip.
        echo;
      else
#echo
#echo "Skipping below check "
#echo "ROW=$ROW"
#echo "COM=$COM"
#echo "Passed on ${m_opstat[$prev_level]}"
#echo "Current Home: $l_mb_db_homes"
#echo
        skip_this_version=1
        call_get_log_result=0
      fi
    elif [ -z "${m_opstat[$prev_level]}" ] ; then
     skip_this_version=1
     call_get_log_result=0
    fi
  fi
}

function set_skip_this_target ()
{
  targetname=$1
  # Incase of a branch, a check needs to executed only if the branch succeded on the db
#echo "$ROW $targetname - $skip_this_target - $CUR_LEVEL"
  if [[ $skip_this_target -eq "0" && $CUR_LEVEL -gt "1" ]]
  then
    prev_level=$(expr $CUR_LEVEL - 1)
    if [[ -n "${m_opstat[$prev_level]}" && `echo ${m_opstat[$prev_level]} | grep -ic $targetname` -eq "0"  ]]
    then
      if [[ `echo ${m_opstat[$prev_level]} | grep -ic passed_on_all_targets` -eq "0" ]] ; then
        skip_this_target=1
        call_get_log_result=0
      fi
    #elif [ -z "${m_opstat[$prev_level]}" ] ; then
    #  if [[ -n "$OPSTAT" && $OPSTAT -eq "0" ]] ; then
    #    skip_this_target=1
    #    call_get_log_result=0
    #  fi
    fi

  fi
}

function func_create_small_files ()
{
  #read -p "what os=$what_os and what db=$what_db and dbversion=$DBVERSION components=$components"
  reffil_old=$REFFIL
  reffil1_old=$REFFIL1 
  no_of_db_version=${#mb_oracle_versions_distinct[*]}
  if [ $OFFLINE -eq 0 ] 
  then
      #if [ "$TYP" = "-u" ]
      #then
      #   CRSVERSION=$(cat $OUTPUTDIR/mb_db_homes_versions_distinct_selected.out|head -1|cut -d '|' -f2)
      #   #CRSVERSION=112020
      #else
      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
      then
             CRSVERSION=$exalogic_version
      elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]]
      then 
             CRSVERSION=$exalytics_version
      else
	  local CRSVERSION=$(echo ${stack_crs_version[0]}|sed 's/\.//g') 
	  if [[ -z "$CRSVERSION" && -n "$CRS" && $is_exalogic_machine -eq "0"  && $is_exalytics_machine -eq "0" ]]
	  then
	      $CRS/bin/crsctl query $crs_version_switch>/dev/null 2>&1
	      if [ $? -eq 0 ]
	      then
		  CRSVERSION=$($CRS/bin/crsctl query $crs_version_switch|sed 's/[^0-9\.]//g'|sed 's/\.//g')
	      fi
	  fi
	  if [[ -n "$RAT_DB" ]]
          then 
              CRSVERSION="$RAT_DB"
          elif [[ -z "$CRSVERSION" && -z "$RAT_DB" ]]
          then 
              echo -e "${RED}${program_name} did not find the Clusterware vesion from environment.\n\nPlease set RAT_DB to cluster version in current shell to override and re- run it.${NORM}\n\n\neg export RAT_DB=112020"
              exit 1
          fi
	  if [ "$what_db" != "NODATABASE" ] && [[ "$what_db" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] &&  [[ "$TYP" != "-b" && $SILENT -eq 0 ]];then crsdb_mixed_version=1;else crsdb_mixed_version=0;fi
	  if [ "$what_db" != "NODATABASE" ] && [[ "$what_db" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] &&  [[ $SILENT -eq 0 ]];then crsdb_mixed_version4checks=1;else crsdb_mixed_version4checks=0;fi
      fi
#######code to remove database from list if its already upgraded
      if [ $upgrade_mode -eq 2 ]
      then
          for db_name_to_check in ${mb_db_names_upgraded[@]}
          do
                 echo -e "\n${GREEN}Database ${db_name_to_check} is already running at version $targetversion so no upgrade checks are required${NORM}"|tee -a $LOGFIL
          done
          if [[ $CRSVERSION -eq $targetversion && ${#mb_db_names[@]} -eq ${#mb_db_names_upgraded[@]} ]]
          then
               echo -e "\n${GREEN}grid infrastructure and all databases are already upgraded and no pre upgrade checks are required\nExiting....${NORM}"|tee -a $LOGFIL
               exit 0
          fi
          if [ "$CRSVERSION" -ge "$targetversion" ]
          then  
              echo -e "${RED}Source vesrsion ($CRSVERSION) is higher than Target version ($targetversion).\n\n${program_name} is existing...${NORM}\n\n"
              exit 1
          fi
      elif [ $upgrade_mode -eq 3 ]
      then
          targetversion=$CRSVERSION   
          if [[ `echo $supportedTargetVersion|grep -icw $CRSVERSION` -lt 1 ]]
          then
               echo -e "\n${GREEN}grid infrastructure is not running $supportedTargetVersionPrint version so can not run post upgrade checks.\nExiting....${NORM}"|tee -a $LOGFIL
               exit 0
          fi 
          for db_name_to_check in "${mb_db_names[@]}"
          do
            if [[ -n "${mb_db_names_need_upgrade[@]}" && ` echo ${mb_db_names_need_upgrade[@]}|grep -icw $db_name_to_check` -ge 1 ]]   
            then
                echo -e "\n${GREEN}Database version for ${db_name_to_check} is not $supportedTargetVersionPrint so no post upgrade checks are required${NORM}"|tee -a $LOGFIL
            fi
          #for db_name_to_check in ${mb_db_names_upgraded[@]}
          #       echo -e "\n${GREEN}Database ${db_name_to_check} is already running at version $what_db so no upgrade checks are required${NORM}"|tee -a $LOGFIL
          done
      fi
 
#read -p "stop for deleteing databases"
#####################
      grp_str=$(echo ${what_os}"_"${CRSVERSION})
      #if [ -n "$components" ];then grp_str=$(echo ${grp_str}-${components});fi
      #read -p "DBVERSION=$what_db and CRSVERSION=$CRSVERSION crsdb_mixed_version=$crsdb_mixed_version grp_str=$grp_str"
      echo "grp_str = $grp_str">>$MASTERFIL
  else
      local CRSVERSION=$(echo ${stack_crs_version[0]}|sed 's/\.//g') 
      local DBVERSION_OFFLINE=$(grep -i "DB_NAME"  $DUMPDIR/$CHKFIL|cut -d= -f2|cut -d'|' -f2|head -1|sed 's/\.//g')
      #DB=$(grep -i "DB_NAME" $DUMPDIR/$CHKFIL |cut -d= -f2)
      if [ -n "$DBVERSION_OFFLINE" ] && [[ "$DBVERSION_OFFLINE" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] && [[ "$RUNSWITCH" != "-b" ]];then crsdb_mixed_version=1;else crsdb_mixed_version=0;fi
      if [ -n "$DBVERSION_OFFLINE" ] && [[ "$DBVERSION_OFFLINE" != "$CRSVERSION" || $no_of_db_version -gt 1 ]] ;then crsdb_mixed_version4checks=1;else crsdb_mixed_version4checks=0;fi
      #read -p "DBVERSION=$DBVERSION_OFFLINE and CRSVERSION=$CRSVERSION crsdb_mixed_version=$crsdb_mixed_version"
     grp_str=$(grep "grp_str" $DUMPDIR/$CHKFIL |awk '{print $3}')
     INPUTDIR_OLD=$INPUTDIR
     INPUTDIR=$DUMPDIR   
     if [[ `grep -ic "PROFILE_RUN = 1" $DUMPDIR/$CHKFIL` -gt "0" ]] ; then 
       run_profile=1
       profileids2run=$(grep "PROFILES =" $DUMPDIR/$CHKFIL | cut -d= -f2)
       profiles2run=$(grep "PROFILE_NAMES =" $DUMPDIR/$CHKFIL | cut -d= -f2)
     fi
  fi
  #CRSVERSION was coming empty in insert statement so declared this new variable to use in insert statment because CRSVERSION is local to this function
  CRSVERSION_UPLOAD=$CRSVERSION
  if [[ -z "$RAT_RUNMODE_INTERNAL" ]] ; then
    $GREP $grp_str $REFFIL >$INPUTDIR/collections_new.dat
    grp_str=$(echo ${grp_str}"-")
    #read -p "grep string =$grp_str"
    sed 's/'$grp_str'//g' $INPUTDIR/collections_new.dat > $INPUTDIR/collections.dat
  # read -p "stop 1"
    if [[ -n "$GREP" && `echo $GREP|grep -ci cgrep` -eq 1 ]]
    then
        $GREP -s -n /COLLECTIONS_START/,/COLLECTIONS_END/p $REFFIL >> $INPUTDIR/collections.dat
    else
        sed -n /COLLECTIONS_START/,/COLLECTIONS_END/p $REFFIL >> $INPUTDIR/collections.dat  
    fi
   # to remove ^M after creating small files.
    sed  's///g' $INPUTDIR/collections.dat >$INPUTDIR/collections_new.dat
    cp $INPUTDIR/collections_new.dat $INPUTDIR/collections.dat
    osCheckIndexNo=$(grep "OS_COLLECT_COUNT" $INPUTDIR/collections.dat|cut -d. -f1|sed 's/_//g')
    #read -p "osCheckIndexNo=$osCheckIndexNo"
    rm  $INPUTDIR/collections_new.dat
    #read -p "stop 2"
    # Merge the collections from other db versions
    if [[ -n "$crsdb_mixed_version4checks" && $crsdb_mixed_version4checks -eq 1 && -n "$upgrade_mode" && $upgrade_mode -ne "3" && $TYP != "-p" ]]
    then #multiple_version_support. But for post upgrade we only check latest, no need to merge
      append_version_checks;
    fi
    if [[ -n "$run_profile" && $run_profile -eq "1" ]] || [ $upgrade_mode -eq 2 ] ; then
      select_collections4profile
    fi
  if [ $SILENT -eq 0 ]
  then
      $GREP $grp_str $REFFIL1 >$INPUTDIR/rules_new.dat
      sed 's/'$grp_str'//g' $INPUTDIR/rules_new.dat > $INPUTDIR/rules.dat
      if [[ -n "$GREP" && `echo $GREP|grep -ci cgrep` -eq 1 ]]
      then
	  $GREP -s -n /APPENDIX_START/,/APPENDIX_END/p $REFFIL1 >> $INPUTDIR/rules.dat
	  $GREP -s -n /RULES_START/,/RULES_END/p $REFFIL1 >> $INPUTDIR/rules.dat
      else
	  sed -n /APPENDIX_START/,/APPENDIX_END/p $REFFIL1 >> $INPUTDIR/rules.dat
	  sed -n /RULES_START/,/RULES_END/p $REFFIL1 >> $INPUTDIR/rules.dat
      fi
      REFFIL1=$INPUTDIR/rules.dat
      sed  's///g' $REFFIL1 > $INPUTDIR/rules_new.dat
      cp $INPUTDIR/rules_new.dat $REFFIL1
      rm $INPUTDIR/rules_new.dat
      if [[ -n "$crsdb_mixed_version" && $crsdb_mixed_version -eq 1 ]]
      then
	  for mb_db_version in ${mb_oracle_versions_distinct[@]}
	  do
	      if [ $OFFLINE -eq 0 ]
	      then
		  grp_str=$(echo ${what_os}"_"${mb_db_version})
	      else
		  what_os_offline=$(grep "grp_str" $DUMPDIR/$CHKFIL |awk '{print $3}'|cut -d_ -f1)
		  grp_str=$(echo ${what_os_offline}"_"${mb_db_version})
	#	  read -p "grp_str=$grp_str"
	      fi
	      grp_str=$(echo ${grp_str}"-")
	      $GREP $grp_str $reffil1_old >$INPUTDIR/rules_new_${mb_db_version}.dat
	      sed 's/'$grp_str'//g' $INPUTDIR/rules_new_${mb_db_version}.dat > $INPUTDIR/rules_${mb_db_version}.dat
              if [[ -n "$GREP" && `echo $GREP|grep -ci cgrep` -eq 1 ]]
	      then
		  $GREP -s -n /RULES_START/,/RULES_END/p $reffil1_old >> $INPUTDIR/rules_${mb_db_version}.dat
	      else
		  sed -n /RULES_START/,/RULES_END/p $reffil1_old >> $INPUTDIR/rules_${mb_db_version}.dat   
	      fi
	      #REFFIL2=$INPUTDIR/rules_crs.dat
	       sed  's///g' $INPUTDIR/rules_${mb_db_version}.dat >$INPUTDIR/rules_new_${mb_db_version}.dat
	       cp $INPUTDIR/rules_new_${mb_db_version}.dat $INPUTDIR/rules_${mb_db_version}.dat
	       rm $INPUTDIR/rules_new_${mb_db_version}.dat

	  done
      fi
  fi
  REFFIL=$INPUTDIR/collections.dat
  #APPENDIX=$INPUTDIR/appendix.dat
  if [ $OFFLINE -eq 1 ] 
  then
      INPUTDIR=$INPUTDIR_OLD
  else
     validate_data_file
  fi
  else
    REFFIL=$INPUTDIR/collections.dat
    INPUTDIR=$INPUTDIR_OLD
  fi
   #read -p "REFFIL=$REFFIL REFFIL1=$REFFIL1 REFFIL2=$REFFIL2"
}
validate_data_file ()
{
 no_of_checks=$(grep -ic "CHECK_ID" $REFFIL)
 if [[ -n "$no_of_checks" && $no_of_checks -le 0 ]]
 then
      if [[ -n "$db_machine_compute" && $db_machine_compute -eq 0 ]]
      then  
          echo -e "\n${RED}RC-003- Your platform/version is not currently supported.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n${program_name} exiting .....\n${NORM}" 
      else
          echo -e "\n${RED}RC-003 - Your platform/version is not currently supported but more platform/version support is being added regularly. Please check My Oracle Support (MOS) Note 1070954.1 for information about planned support for platforms/versions.\n\n${program_name} exiting .....\n${NORM}" 
      fi 
      exit 1;       
 fi
}

function validate_datafile_date ()
{
 #Check that data file are  not too old. if data file is more than 90 days
 #it will ask the confirmation and if customer wants, can abort and get new data files
     sysDateYear=$(date '+%Y')
    
     sysDateMonth=$(date '+%m'|sed 's/^0//')
     sysDateDay=$(date '+%d'|sed 's/^0//')
     dataFIleDay=$(echo $dataFIleDay|sed 's/^0//')
     dataFIleMonthNo=$(echo $dataFIleMonthNo|sed 's/^0//')
  
     file_epoch=$(perl -e 'use Time::Local;print timelocal(00,00,00,"'$dataFIleDay'",'$dataFIleMonthNo'-1,'$dataFIleYear');')
     sys_epoch=$(perl -e 'use Time::Local;print timelocal(00,00,00,"'$sysDateDay'",'$sysDateMonth'-1,'$sysDateYear');')
     diff_epoch=`expr $sys_epoch - $file_epoch`
     #read -p "stop here $dataFIleDay $dataFIleMonthNo $dataFIleYear $file_epoch1 $file_epoch"
     if [ $diff_epoch -gt 8640000  ]
     then
	 echo -e $RED"This version of ${program_name} was released on $dataFilesDate and its older than 90 days. It is highly recommended that you download the latest version of ${program_name} from my oracle support to ensure the highest level of accuracy of the data contained within the report.${NORM}\n\n"
         oldVersionWarningMessage="Ran older version of ${program_name} released on ${dataFilesDate}"
	 read -p  "Do you want to continue using older version of ${program_name}? [y/n][y]" cdfYesNo
	 case $cdfYesNo in
	    y|Y|yes|YES|Yes) 
             cdfYes=1
	     ;;
	    n|N|No|NO) echo ""
                cleanup
		exit 1
	    ;;
	   *)
             cdfYes=1
	   ;;
	 esac
     else
        validVersionDays=$(expr $diff_epoch / 60 / 60 / 24)
        validVersionDays=$(expr 90 - $validVersionDays)
     fi
}

function write_asm_version_master ()
{
  if [ ${stack_asm_up[0]} -eq 1 ]
  then
      OLD_ORACLE_HOME=$ORACLE_HOME
      OLD_ORACLE_SID=$ORACLE_SID
      if [[ -n "$crs112" && $crs112 -ge 1 ]]
      then
	  export ORACLE_SID=${stack_asm_sid[$stack_counter]}
	  export ORACLE_HOME=$CRS
      else
	  export ORACLE_HOME=${stack_asm_home[$stack_counter]}
	  export ORACLE_SID=${stack_asm_sid[$stack_counter]}
      fi
      #read -p "IS_SYSDBA=$IS_SYSDBA ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID"
      # added 1=2 in first part of if to always fail because we never ask asm sysdba password and always login as / as sysdba
      if [[ -n $IS_SYSDBA && $IS_SYSDBA -eq 0 && 1 -eq 2 ]]
      then 
	 #read -p "write asm version without asm sysdba"
	 if [ `hostname|grep -c "\."` -ge 1 ]
	 then
	     echo "set feedback  off heading off
	     select substr(lower(HOST_NAME),1,instr(lower(HOST_NAME),'.',1)-1)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$>>$MASTERFIL
	 else
	     echo "set feedback  off heading off
	     select lower(HOST_NAME)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$>>$MASTERFIL
	 fi
      else
	 if [ `hostname|grep -c "\."` -ge 1 ]
	 then
	     echo "set feedback  off heading off
	     select substr(lower(HOST_NAME),1,instr(lower(HOST_NAME),'.',1)-1)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$>>$MASTERFIL
	 else
	     echo "set feedback  off heading off
	     select lower(HOST_NAME)||'.'||INSTANCE_NAME||'.VERSION = '||VERSION from gv\$instance;"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$>>$MASTERFIL
	 fi
      fi
      export ORACLE_HOME=$OLD_ORACLE_HOME
      export ORACLE_SID=$OLD_ORACLE_SID
  fi
}
# this fucntion to check the environment is set for uplaoding raccehck result to database or not
# modified by kumar
function upload_result_env_check ()
{
if [[ -n "$1" && -n "$RAT_UPLOAD_USER"  && -n "$RAT_UPLOAD_PASSWORD" && -n "$RAT_UPLOAD_CONNECT_STRING" ]]
then
    raccheck_upload_env_set=1
else
    raccheck_upload_env_set=0
fi
}

# this function is to check the database connectvity before uploading raccheck result to database at the end of the run
function upload_result_conn_check () 
{
 #read -p "raccheck_upload_env_set=$raccheck_upload_env_set"
 if [[ -n $raccheck_upload_env_set && $raccheck_upload_env_set -eq 1  ]]
 then
     if [ -n "$RAT_UPLOAD_ORACLE_HOME" ]
     then
	 upload_result_conn=$(echo "set heading off
	select 1 from dual;"|$RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING" 2>>$ERRFIL|grep -v ^$)
     else
	 upload_result_conn=$(echo "set heading off
		  select 1 from dual;"|$ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING" 2>>$ERRFIL|grep -v ^$)
     fi
     if [ `echo $upload_result_conn | grep -c "ORA-"` -ge 1 ]
     then 
	 upload_result_conn_status=0
     else
	 upload_result_conn_status=1
     fi
 fi
}
#Added by kumar
function insert_data_into_table ()
{
 sql_spool_file=$3
 upload_result_env_check $1
 upload_result_conn_check
#read -p "RAT_UPLOAD_ORACLE_HOME=$RAT_UPLOAD_ORACLE_HOME and ORACLE_HOME=$ORACLE_HOME"
 if [ $raccheck_upload_env_set -eq 0 ] 
 then
    data_upload_status=1
 elif [ $upload_result_conn_status -eq 0 ]
 then
    data_upload_status=2
 else 
    if [ -n "$RAT_UPLOAD_ORACLE_HOME" ]
    then
       $RAT_UPLOAD_ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING"  >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set serveroutput on
		     spool $sql_spool_file
		     @@$2
		     spool off
		     exit
EOF
    else
       $ORACLE_HOME/bin/sqlplus -s $RAT_UPLOAD_USER/$RAT_UPLOAD_PASSWORD@"$RAT_UPLOAD_CONNECT_STRING"  >/dev/null 2>&1 <<EOF
		     set head off
		     set lines 80
		     set serveroutput on
		     spool $sql_spool_file
		     @@$2
		     spool off
		     exit
EOF
    fi
     upload_error=$(grep -c "ORA-" $sql_spool_file)
     if [[ -n "$upload_error" && $upload_error -gt 0 ]]
     then
	data_upload_status=3
     else
	data_upload_status=0      
	if [ -n "$upload_pass_msg" ]
	then
	   upload_pass_msg2="and `cat $sql_spool_file|grep -i "1 row created" |wc -l|sed 's/ //g'` rows were added to $1 table."
	else   
	   upload_pass_msg="Uploading ${program_name} result to database was successfull. `cat $sql_spool_file|grep -i "1 row created" |wc -l|sed 's/ //g'` rows were added to $1 table"
	fi
     fi            
 fi
}

#Added by Kumar
#following code is to get insert statements for installed patches into file
function insertStatementsForInstalledPatches ()
{
 for host in `cat $HOSTLIST`
 do
  if [ -f $OUTPUTDIR/o_${1}_patchlist_${host}.out ]
  then
   for patch_no in `cat $OUTPUTDIR/o_${1}_patchlist_${host}.out`
   do
    if [[ -f $OUTPUTDIR/o_patch_result_${host}.out && $(grep -c $patch_no $OUTPUTDIR/o_patch_result_${host}.out) -ge 1 ]]
    then 
       echo "Do nothing" > /dev/null
    else
	if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
	then
	    echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$host','$1','$2','$3','$patch_no','$cluster_name','null','null',1,0);">>$upload_raccheck_patch_result_fil
	fi
    fi
   done
  fi
 done
}

is_this_db_machine ()
{
if [ $OFFLINE -eq 0 ]
then
    #if [ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ]
    if [ -e "/opt/oracle.cellos" ]
    then
       db_machine_compute=1
       sunfire_x4270m2=0
       sunfire_x4270m3=0  
       is_avm_machine=0 
       if [ -e ${SYSTEM_DESC_FIL} ]
       then
           sunfire_x4270m2=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M2"|wc -l)
           sunfire_x4270m3=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M3"|wc -l) 
       fi 
       if [[ ! -e ${SYSTEM_DESC_FIL} && -e ${SerialNumberFil} && $# -lt 2 ]]
       then
           sed -e '/FRU Device Description[\t ]\+:[\t ]\+\/SYS/,/Product Name[\t ]\+:/!d;/Product Name[\t ]\+:/!d;s/Product Name[\t ]\+:[\t ]\+//g;' $SerialNumberFil | sort -u >$SYSTEM_DESC_FIL
           sunfire_x4270m2=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M2"|wc -l)
           sunfire_x4270m3=$(cat ${SYSTEM_DESC_FIL} 2>/dev/null|grep "SUN FIRE X4[1-2]70 M3"|wc -l) 
       fi  
       if [ -r $AVMIDFIL ]; then is_avm_machine=$(grep -iwc "<AVAILABILITY_MACHINE>true</AVAILABILITY_MACHINE>" $AVMIDFIL 2>/dev/null);fi
       print_compute_node=$(echo -e on ${BLINK}DATABASE SERVER${NORM})
       if [ -z "$platform" ]; then platform=$(uname -s);fi;

       if [ $platform = "Linux" ]
       then 
          dbm_status_v2=$(udevinfo -q all -p /sys/block/sda|grep -iq LSI;echo $?) 
          dbm_status_v1=$(ls /sys/block | grep -qi cciss;echo $?) 
          if [ "$1" = "$localnode" ]
          then  
              no_of_cores=$(cat /proc/cpuinfo | grep -w "processor"|wc -l)
              exadata_platform=$(uname -p) 
          else
              no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'cat /proc/cpuinfo | grep -w "processor"|wc -l')
              exadata_platform=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'uname -p')
          fi
       else
          dbm_status_v2=0
          dbm_status_v1=1
          if [ "$1" = "$localnode" ]
          then 
              no_of_cores=$(/sbin/psrinfo|wc -l|tr -d ' ')
              exadata_platform=$(uname -p) 
          else
              no_of_cores=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 '/sbin/psrinfo|wc -l|tr -d ' '')
              exadata_platform=$($SSHELL -o NumberOfPasswordPrompts=0 -l $usern $1 'uname -p')
          fi
       fi
          
       no_of_cells=$(cat /etc/oracle/cell/network-config/cellip.ora|grep "cell="|grep -v ^#|wc -l)
       
       it_is_rac=0
       if [ -n "$no_of_cells" ] && [[ $no_of_cells -eq 3 || $no_of_cells -eq 4 ]]
       then
          EXADATA_RACK=QUARTER
       elif [[ -n "$no_of_cells" && $no_of_cells -eq 7 ]]
       then
          EXADATA_RACK=HALF
       elif [[ -n "$no_of_cells" && $no_of_cells -ge 14 ]]
       then
           EXADATA_RACK=FULL
       fi
       if [[ $dbm_status_v2 -eq 0 && $dbm_status_v1 -eq 1 ]]
       then
           if [[ $no_of_cores -eq 16 && $sunfire_x4270m3 -ge 1 ]]
           then
	       dbm_v1=0
               dbm_x2_2=0
               dbm_x2_8=0
	       dbm_v2=0
               dbm_x3_2=1
               EXADATA_VERSION="EIGHTH RACK"
               EXADATA_RACK="EIGHTH RACK"
               if  [ $upgrade_mode -eq 0 ]
               then
                   components=$(echo ${user_components}:EIGHTH:MAA)
               elif [ $upgrade_mode -eq 2 ]
               then
                   components=$(echo ${components}|sed 's/PREUPGR://g')
                   components=$(echo ${components}:PREUPGREIGHTH)
               elif [ $upgrade_mode -eq 3 ]
               then
                   components=$(echo ${components}|sed 's/POSTUPGR://g')
                   components=$(echo ${components}:POSTUPGREIGHTH)
               fi
           elif [[ $no_of_cores -gt 16 && $no_of_cores -le 24 && $sunfire_x4270m3 -ge 1 ]]
           then
               #This branch is to cover IAAS where X3-2 will run in reduced capacity 
               dbm_v1=0
               dbm_v2=0
               dbm_x2_2=0
               dbm_x2_8=0
               dbm_x3_2=1
               EXADATA_VERSION="X3-2" 
               if  [ $upgrade_mode -eq 0 ]
               then
                   components=$(echo ${user_components}:X3-2:MAA)
               elif [ $upgrade_mode -eq 2 ]
               then
                   components=$(echo ${components}|sed 's/PREUPGR://g')
                   components=$(echo ${components}:PREUPGRX3-2)
               elif [ $upgrade_mode -eq 3 ]
               then
                   components=$(echo ${components}|sed 's/POSTUPGR://g')
                   components=$(echo ${components}:POSTUPGRX3-2)
               fi
           elif [[ $no_of_cores -gt 16 && $no_of_cores -le 24 && $sunfire_x4270m2 -ge 1 ]]
           then
               dbm_v1=0
               dbm_v2=0
               dbm_x2_2=1
               dbm_x2_8=0
               dbm_x3_2=0
               EXADATA_VERSION="X2-2" 
               if  [ $upgrade_mode -eq 0 ]
               then
                   components=$(echo ${user_components}:X2-2:MAA)
               elif [ $upgrade_mode -eq 2 ]
               then
                   components=$(echo ${components}|sed 's/PREUPGR://g')
                   components=$(echo ${components}:PREUPGRX2-2)
               elif [ $upgrade_mode -eq 3 ]
               then
                   components=$(echo ${components}|sed 's/POSTUPGR://g')
                   components=$(echo ${components}:POSTUPGRX2-2)
               fi
           elif [[ $no_of_cores -gt 24 && $no_of_cores -le 32 && "$is_avm_machine" &&  $is_avm_machine -eq 0 ]]
           then
               dbm_v1=0
               dbm_v2=0
               dbm_x2_2=0
               dbm_x2_8=0
               dbm_x3_2=1
               EXADATA_VERSION="X3-2" 
               if  [ $upgrade_mode -eq 0 ]
               then
                   components=$(echo ${user_components}:X3-2:MAA)
               elif [ $upgrade_mode -eq 2 ]
               then
                   components=$(echo ${components}|sed 's/PREUPGR://g')
                   components=$(echo ${components}:PREUPGRX3-2)
               elif [ $upgrade_mode -eq 3 ]
               then
                   components=$(echo ${components}|sed 's/POSTUPGR://g')
                   components=$(echo ${components}:POSTUPGRX3-2)
               fi  
           elif [ $no_of_cores -ge 64 ]
           then
               dbm_v1=0
               dbm_v2=0
               dbm_x2_2=0
               dbm_x2_8=1
               dbm_x3_2=0
               if [ "$exadata_platform" = "sparc" ]
               then
                   if  [ $upgrade_mode -eq 0 ]
                   then
                       EXADATA_VERSION="SUPERCLUSTER"
		       components=$(echo ${user_components}:SUPERCLUSTER:MAA)
                       is_ssc_machine=1 
		   elif [ $upgrade_mode -eq 2 ]
		   then
		       components=$(echo ${components}|sed 's/PREUPGR://g')
		       components=$(echo ${components}:PREUPGRSUPERCLUSTER)
		   elif [ $upgrade_mode -eq 3 ]
		   then
		       components=$(echo ${components}|sed 's/POSTUPGR://g')
		       components=$(echo ${components}:POSTUPGRSUPERCLUSTER)
		   fi
               else
                   if [ $sunfire_x4270m3 -ge 1 ]
                   then  
		       if  [ $upgrade_mode -eq 0 ]
		       then
			  EXADATA_VERSION="X3-8"
			  components=$(echo ${user_components}:X3-8:MAA)
		       elif [ $upgrade_mode -eq 2 ]
		       then
			   components=$(echo ${components}|sed 's/PREUPGR://g')
			   components=$(echo ${components}:PREUPGRX3-8)
		       elif [ $upgrade_mode -eq 3 ]
		       then
			   components=$(echo ${components}|sed 's/POSTUPGR://g')
			   components=$(echo ${components}:POSTUPGRX3-8)
		       fi
                   else 
		       if  [ $upgrade_mode -eq 0 ]
		       then
			  EXADATA_VERSION="X2-8"
			  components=$(echo ${user_components}:X2-8:MAA)
		       elif [ $upgrade_mode -eq 2 ]
		       then
			   components=$(echo ${components}|sed 's/PREUPGR://g')
			   components=$(echo ${components}:PREUPGRX2-8)
		       elif [ $upgrade_mode -eq 3 ]
		       then
			   components=$(echo ${components}|sed 's/POSTUPGR://g')
			   components=$(echo ${components}:POSTUPGRX2-8)
		       fi
                   fi
               fi
           elif [[ $no_of_cores -gt 16 && $no_of_cores -le 32 && $sunfire_x4270m2 -eq 0  && $sunfire_x4270m2 -eq 0 && "$platform" = "SunOS" ]]
           then
               #this branch is to cover when storage server are skipped and serial number file is not found on database server  
               dbm_v1=0
               dbm_v2=0
               dbm_x2_2=0
               dbm_x2_8=0
               dbm_x3_2=1
               EXADATA_VERSION="X3-2" 
               if  [ $upgrade_mode -eq 0 ]
               then
                   components=$(echo ${user_components}:X3-2:MAA)
               elif [ $upgrade_mode -eq 2 ]
               then
                   components=$(echo ${components}|sed 's/PREUPGR://g')
                   components=$(echo ${components}:PREUPGRX3-2)
               elif [ $upgrade_mode -eq 3 ]
               then
                   components=$(echo ${components}|sed 's/POSTUPGR://g')
                   components=$(echo ${components}:POSTUPGRX3-2)
               fi
           elif [[ "$is_avm_machine" &&  $is_avm_machine -eq 1 ]] 
           then
               dbm_v1=0
               dbm_x2_2=0
               dbm_x2_8=0
               dbm_v2=0
               AVM_VERSION=X3-2
               dbm_x3_2=1
               if [ $upgrade_mode -eq 0 ]
               then
                    components=$(echo ${user_components}:AVM:MAA)
               elif [ $upgrade_mode -eq 2 ]
               then
                   components=$(echo ${components}|sed 's/PREUPGR://g')
                   components=$(echo ${components}:PREUPGRAVM)

               elif [ $upgrade_mode -eq 3 ]
               then
                   components=$(echo ${components}|sed 's/POSTUPGR://g')
                   components=$(echo ${components}:POSTUPGRAVM)
               fi 
           else
               dbm_v1=0
               dbm_x2_2=0
               dbm_x2_8=0
               dbm_v2=1
               EXADATA_VERSION=V2
               dbm_x3_2=0
               if [ $upgrade_mode -eq 0 ]
	       then
		    components=$(echo ${user_components}:EXADATA:MAA)
	       elif [ $upgrade_mode -eq 2 ]
	       then
		   components=$(echo ${components}|sed 's/PREUPGR://g')
		   components=$(echo ${components}:PREUPGRDBM)

	       elif [ $upgrade_mode -eq 3 ]
	       then
		   components=$(echo ${components}|sed 's/POSTUPGR://g')
		   components=$(echo ${components}:POSTUPGRDBM)
	       fi
           fi
       elif [[ $dbm_status_v2 -eq 1 && $dbm_status_v1 -eq 0 ]]
       then
           dbm_x2_2=0
           dbm_x2_8=0
	   dbm_v1=1
	   dbm_v2=0
           EXADATA_VERSION=V1
       fi
    else 
       print_compute_node=""
       db_machine_compute=0
       dbm_v1=0
       dbm_v2=0
       dbm_x2_2=0
       dbm_x2_8=0
       if [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
       then 
           it_is_rac=0
       elif [[ -n "$single_instance_run" && $single_instance_run -eq 1 ]]
       then
           it_is_rac=0
       else 
           it_is_rac=1
       fi 
       dbm_x3_2=0
       if [[ $upgrade_mode -eq 0 && "$components" = "NONE" ]]; then components=$(echo ${components}:RACCHECK:MAA);fi
    fi
fi
if [ -n "$options_components" ]; then components=$final_components;fi
 #read -p "see values in $components"
}

#Function to write Exadata components in env file. This function was added because exadata discover function will be called for each node
write_db_machine_info_to_envfile ()
{
 if [ $OFFLINE -eq 0 ]
 then
    echo "${1}.EXADATA_COMPUTE = $db_machine_compute">>$MASTERFIL
    echo "${1}.EXADATA_DBMV1 = $dbm_v1">>$MASTERFIL
    echo "${1}.EXADATA_DBMV2 = $dbm_v2">>$MASTERFIL
    echo "${1}.EXADATA_DBM_X2_2 = $dbm_x2_2">>$MASTERFIL
    echo "${1}.EXADATA_DBM_X2_8 = $dbm_x2_8">>$MASTERFIL
    echo "${1}.EXADATA_DBM_X3_2 = $dbm_x3_2">>$MASTERFIL
    echo "${1}.EXADATA_RACK = $EXADATA_RACK">>$MASTERFIL
    echo "${1}.EXADATA_VERSION = $EXADATA_VERSION">>$MASTERFIL
    echo "${1}.IT_IS_RAC = $it_is_rac">>$MASTERFIL
    echo "${1}.COMPONENTS = $components" >>$MASTERFIL
    echo "${1}.IS_AVM_MACHINE = $is_avm_machine">>$MASTERFIL
    echo "db_machine_compute=$db_machine_compute dbm_status_v2=$dbm_status_v2 dbm_status_v1=$dbm_status_v1 dbm_v1=$dbm_v1 dbm_v2=$dbm_v2">> $LOGFIL
 else
    db_machine_compute=$(grep ${1}.EXADATA_COMPUTE $DUMPDIR/$CHKFIL|awk '{print $3}')
    dbm_v1=$(grep ${1}.EXADATA_DBMV1 $DUMPDIR/$CHKFIL|awk '{print $3}')
    dbm_v2=$(grep ${1}.EXADATA_DBMV2 $DUMPDIR/$CHKFIL|awk '{print $3}')
    dbm_x2_2=$(grep ${1}.EXADATA_DBM_X2_2 $DUMPDIR/$CHKFIL|awk '{print $3}')
    dbm_x2_8=$(grep ${1}.EXADATA_DBM_X2_8 $DUMPDIR/$CHKFIL|awk '{print $3}')
    it_is_rac=$(grep ${1}.IT_IS_RAC $DUMPDIR/$CHKFIL|awk '{print $3}')
    is_avm_machine=$(grep ${1}.IS_AVM_MACHINE $DUMPDIR/$CHKFIL|awk '{print $3}')
    dbm_x3_2=$(grep ${1}.EXADATA_DBM_X3_2 $DUMPDIR/$CHKFIL|awk '{print $3}')
    EXADATA_RACK=$(grep ${1}.EXADATA_RACK $DUMPDIR/$CHKFIL|awk '{print $3}')
    EXADATA_VERSION=$(grep ${1}.EXADATA_VERSION $DUMPDIR/$CHKFIL|head -1|awk '{print $3}')
    components=$(grep ${1}.COMPONENTS $DUMPDIR/$CHKFIL|head -1|awk '{print $3}')  
 fi
 #read -p "see values in $components"
}

ports_find_sid ()
{
    case `/bin/uname` in
	Linux)
	#read -p "db_name_to_check=$db_name_to_check"
	oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $8}'|cut -d_ -f3)
	bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
	;;
	SunOS)
	oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $9}'|cut -d_ -f3)
	bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
	if [ -z "$oSID" ]; then  oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $8}'|cut -d_ -f3);fi;
	if [ -z "$bgproc" ]; then  bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`;fi
	#read -p "oSID=$oSID and db_name_to_check=$db_name_to_check"
	;;
	HP-UX) 
	oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $9}'|cut -d_ -f3)
	bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
	if [ -z "$bgproc" ]; then  bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`;fi
	;;
	AIX)  
	oSID=$(ps -ef |grep pmon_${db_name_to_check}|grep -v grep|awk '{print $9}'|cut -d_ -f3)
	bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
	if [ -z "$bgproc" ]; then  bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`;fi
	;;
	*)     /bin/echo "ERROR: Unknown Operating System"
	exit -1
	;;
    esac
}
function GetMachineRole()
{
 if [ $OFFLINE -eq 0 ]
 then
     HOSTTYPE=BAREMETAL; ROLE="";VMTYPE="NONE";
     if [ -d /proc/xen ]
     then
	if grep -q "control_d" /proc/xen/capabilities > /dev/null 2>&1
	then
	    HOSTTYPE=XENDOM0
	else
	   HOSTTYPE=XENDOMU
	   #xblk=`/sbin/lsmod |grep -i xenblk`
	   #xnet=`/sbin/lsmod |grep -i xennet`
           xblk=`/sbin/lsmod |egrep -i 'xenblk|xen_blkfront'`
           xnet=`/sbin/lsmod |egrep -i 'xennet|xen_netfront'`   
	   if [[ -n $xblk && -n $xnet ]]
	   then
	       VMTYPE=PVM
	   else
	       VMTYPE=HVM_PVHVM
	   fi
	fi
     fi
      if grep "Oracle VM server release 2.2" /etc/ovs-release > /dev/null 2>&1
     then
	 OVMSERVER=`cat /etc/ovs-release`
	 ROLE="OVMSERVER" # will include 2.2.1
     elif rpm --quiet -q ovs-manager > /dev/null 2>&1
     then
	 ROLE="OVMMANAGER"
     elif [ -f /etc/enterprise-release ]
     then
	 GENERIC="`cat /etc/enterprise-release`"
	 ROLE="GENERIC"
     elif [ -f /etc/redhat-release ]
	 then GENERIC="`cat /etc/redhat-release`"
	 ROLE="GENERIC"
     else
	 ROLE="Not_Supported"
	  return 1 # not a RH, EL or Fedora based distro... maybe someday, but not today
     fi
     echo "HOST_ROLE = "$ROLE >>$MASTERFIL
     echo "HOST_TYPE = "$HOSTTYPE >>$MASTERFIL
     echo "VM_TYPE = "$VMTYPE >>$MASTERFIL
 else
    ROLE=$(grep HOST_ROLE $DUMPDIR/$CHKFIL|awk '{print $3}')
    HOSTTYPE=$(grep HOST_TYPE $DUMPDIR/$CHKFIL|awk '{print $3}')
    VMTYPE=$(grep VM_TYPE $DUMPDIR/$CHKFIL|awk '{print $3}')
 fi
 #echo "HOST_ROLE = $ROLE  HOST_TYPE = $HOSTTYPE VM_TYPE = $VMTYPE"
}

function killtree() {
    local _pid=$1
    local _sig=${2-TERM}
    kill -stop ${_pid}
    for _child in $(ps -ef |awk '$3 == '${_pid}' {print $2}'); do 
       killtree ${_child} ${_sig}
    done
    kill -${_sig} ${_pid}
}

cleanup () 
{
  old_IFS=$IFS
  unset IFS

  update_zip_files

  if [[ $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
    kill $watchdog_pid > /dev/null 2>&1
    return;
  fi
  stty echo
  if [[ -d $INPUTDIR && -z "$RAT_NOCLEAN_DIR" ]]
  then 
      # if it's run from NFS in Exalogic Machine, need to kill watchdog.sh first to delete .input dir
      if [ $is_exalogic_machine -eq 1 ]; then wrkdir_filesystem_type=$(stat -f -L -c %T $(echo $WRKDIR));fi
      #wrkdir_filesystem_type=$(stat -f -L -c %T $(echo $WRKDIR))
      if [[ $is_exalogic_machine -eq 1 && "$wrkdir_filesystem_type" = "nfs" ]]
      then
          kill $watchdog_pid > /dev/null 2>&1
      fi
      rm -rf $INPUTDIR >/dev/null 2>&1
  fi
  if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
    saved_errfil=$ERRFIL
    ERRFIL=/dev/null
    on_signal_cell_cleanup;
    ERRFIL=$saved_errfil
  fi
  if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
    saved_errfil=$ERRFIL
    ERRFIL=/dev/null
    on_signal_ib_cleanup;
    ERRFIL=$saved_errfil
  fi

  if [[ -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" ]]
  then
    saved_errfil=$ERRFIL
    ERRFIL=/dev/null
    on_signal_compute_cleanup;
    ERRFIL=$saved_errfil
  fi

  if [ -e "$HOSTLIST.org" ] ; then mv $HOSTLIST.org $HOSTLIST; fi

 if [[ -n "$delete_lock_file" && $delete_lock_file -eq 0 ]]
 then
     if [ -d $RTEMPDIR ]; then rm -rf $RTEMPDIR >/dev/null 2>&1; fi; 
     if [ -e $LOCKFIL ]; then rm $LOCKFIL >/dev/null 2>&1; fi;
     if [ -e  $HOSTLIST ]
     then
	 for hname in `cat $HOSTLIST`
	 do
	     if [ $hname = $localnode ]
	     then
		 rm -f ${RTEMPDIR}/o_*.out >/dev/null 2>&1 # gadiga - not needed as dir is already purged
		 if [ -e $EXADATA_CELL_COLLECTIONS ]; then rm -f $EXADATA_CELL_COLLECTIONS >/dev/null 2>&1; fi;
		 if [ -e /tmp/raccheck_env.out ]; then  rm -f /tmp/raccheck_env.out >/dev/null 2>&1; fi;
		 if [ -e /tmp/set_orcl_env.sh ]; then rm -f /tmp/set_orcl_env.sh >/dev/null 2>&1;fi;
		 if [ -e /tmp/root_${program_name}.sh ]; then rm -f /tmp/root_${program_name}.sh >/dev/null 2>&1;fi;
                 rm -f /tmp/o_root_clusterwide_check*.out >/dev/null 2>&1
                 if [ -e $RTEMPDIR/cells.out ]; then rm $RTEMPDIR/cells.out >/dev/null 2>&1;fi
              #delete utility script at the end of execution
                 for utlscrpt in "${a_utlscrpt[@]}"
                 do
                   if [ -e /tmp/${utlscrpt} ]; then rm -f /tmp/${utlscrpt} >/dev/null 2>&1;fi
                 done
                 
	     else
		 #$SSHELL $hname rm -f /tmp/o_*.out >/dev/null 2>&1
                 # Using $SHELL gives error /usr/bin/ssh -q: No such file or directory
                 # So hardcoded ssh
		 #ssh -q $hname 'if [ -d $RTEMPDIR ]; then rm -rf $RTEMPDIR >/dev/null 2>&1; fi'
		 $SSHELL $hname "$bash_scr -c \"if [ -d $RTEMPDIR ]; then rm -rf $RTEMPDIR >/dev/null 2>&1; fi\""
		 $SSHELL $hname " $bash_scr -c \"if [ -e $EXADATA_CELL_COLLECTIONS ]; then rm -f $EXADATA_CELL_COLLECTIONS >/dev/null 2>&1; fi;\""
		 $SSHELL $hname "$bash_scr -c \"rm -f /tmp/raccheck_env.out >/dev/null 2>&1\""
		 $SSHELL $hname "$bash_scr -c \"rm -f /tmp/set_orcl_env.sh >/dev/null 2>&1\""
		 $SSHELL $hname "$bash_scr -c \"rm -f /tmp/root_${program_name}.sh >/dev/null 2>&1\""
                 $SSHELL $hname "$bash_scr -c \"rm -f /tmp/o_root_clusterwide_check*.out >/dev/null 2>&1\""
              #delete utility script at the end of execution
                 for utlscrpt in "${a_utlscrpt[@]}"
                 do
                    $SSHELL $hname " $bash_scr -c \"if [ -e /tmp/${utlscrpt} ]; then rm -f /tmp/${utlscrpt} >/dev/null 2>&1;fi\""
                 done
	     fi
	 done
	 if [ $OFFLINE -eq 0 ]
	 then
	     if [[ -n $arr && $arr -ge 0 ]]; then arr=`expr $arr - 1`;fi
	     while [[ -n $arr && $arr -ge 0 ]]
	     do
	       if [ ${hnameArr[$arr]} = $localnode ]
	       then
		   #rm -rf ~/.ssh 2>/dev/null
		   mv -f ~/.ssh/authorized_keys.tmp ~/.ssh/authorized_keys 
		   mv -f ~/.ssh/known_hosts.tmp ~/.ssh/known_hosts 
	       else
		   #ssh ${hnameArr[$arr]} rm -rf ~/.ssh
                   $SSHELL -o StrictHostKeyChecking=no -x -l $usern ${hnameArr[$arr]} "/bin/sh -c \"mv -f ~/.ssh/known_hosts.tmp ~/.ssh/known_hosts; mv -f ~/.ssh/authorized_keys.tmp ~/.ssh/authorized_keys\""  
	       fi
	       arr=`expr $arr - 1`
	     done
	 fi
     fi
     if [ -e $WRKDIR/cgrep ]; then rm -f $WRKDIR/cgrep >/dev/null 2>&1;fi;
     if [ -e a_dbm_asm_diskgroup_attributes_dbmv2.out ]; then rm a_dbm_asm_diskgroup_attributes_dbmv2.out >/dev/null 2>&1;fi;
 fi
 kill $watchdog_pid > /dev/null 2>&1
 if [[ -d $OUTPUTDIR && -z "$RAT_NOCLEAN_DIR" ]]
 then
     ZIPFIL=${UPLOADFIL}.zip
     if [ ! -e $ZIPFIL ]; then ZIPFIL=${UPLOADFIL}.tar.gz;fi
     if [[ -n "$ZIPFIL" && ! -e $ZIPFIL ]] || [[ -n "$stack_counter" && $stack_counter -lt 1 ]]
     then
	 rm -rf $OUTPUTDIR >/dev/null 2>&1
     fi
 fi
}

reorg_output_dir ()
{
 if [ ! -e $OUTPUTDIR/outfiles ]; then mkdir $OUTPUTDIR/outfiles >/dev/null 2>&1;fi
 if [ ! -e $OUTPUTDIR/reports ]; then mkdir $OUTPUTDIR/reports >/dev/null 2>&1;fi
 if [ ! -e $OUTPUTDIR/upload ]; then mkdir $OUTPUTDIR/upload >/dev/null 2>&1;fi
 if [ ! -e $OUTPUTDIR/log ]; then mkdir $OUTPUTDIR/log >/dev/null 2>&1;fi

 if [  -e $OUTPUTDIR/outfiles ]; then mv -f $OUTPUTDIR/*.out $OUTPUTDIR/outfiles >/dev/null 2>&1;fi
 if [  -e $OUTPUTDIR/reports ]; then mv -f $OUTPUTDIR/*.rep $OUTPUTDIR/reports >/dev/null 2>&1;fi
 if [  -e $OUTPUTDIR/upload ]; then mv -f $OUTPUTDIR/*.sql $OUTPUTDIR/upload >/dev/null 2>&1;fi
 if [[ -z "$RAT_COPY_EM_XML_FILES" && -e $OUTPUTDIR/upload ]]; then mv -f $OUTPUTDIR/*.xml $OUTPUTDIR/upload >/dev/null 2>&1;fi
 if [[  -e $HTML_REPFILE && -e $OUTPUTDIR/reports ]]
 then
      cp -f $HTML_REPFILE ${HTML_REPFILE}_copy >/dev/null 2>&1
      mv -f $OUTPUTDIR/*.html $OUTPUTDIR/reports >/dev/null 2>&1
      cp -f ${HTML_REPFILE}_copy $HTML_REPFILE >/dev/null 2>&1
      cp -f $HTML_REPFILE $OUTPUTDIR/reports >/dev/null 2>&1
      rm -f ${HTML_REPFILE}_copy >/dev/null 2>&1
 fi
 if [  -e $OUTPUTDIR/log ]; then mv -f $OUTPUTDIR/*.log $OUTPUTDIR/log >/dev/null 2>&1;mv -f $OUTPUTDIR/*.txt $OUTPUTDIR/log >/dev/null 2>&1;fi
 ERRFIL=${OUTPUTDIR}/log/${program_name}_error.log
 HOSTLIST=${OUTPUTDIR}/outfiles/$(basename $HOSTLIST)
}

mb_validate_oracle_home ()
{
 oracle_home_to_check=$1
 if [[ -d $oracle_home_to_check && -f $oracle_home_to_check/bin/oracle ]];then validate_oracle_home_status=1;else validate_oracle_home_status=0;fi;
}
mb_read_oracle_home()
{
 mb_read_oracle_home_called=0
 mb_read_oracle_home_found=0
 if [ -z "$1" ] || [[ -n "$valideate_oracle_home_status" && $valideate_oracle_home_status -eq 0 ]]
 then
     mb_db_counter_read=0
     for db_name_to_check_to_read in "${mb_db_names[@]}"
     do
       if [[ "$db_name_to_check_to_read" = ${2} && -n "${mb_oracle_homes[$mb_db_counter_read]}" ]]
       then 
          mb_ask_oracle_home=${mb_oracle_homes[$mb_db_counter_read]}
          mb_read_oracle_home_found=1
          mb_read_oracle_home_called=1
          break
       fi
       mb_db_counter_read=$(expr $mb_db_counter_read + 1 )
     done
     if [[ -n "$validate_oracle_home_tries" && $validate_oracle_home_tries -lt 1 && $mb_read_oracle_home_found -eq 0 ]]
     then
         read -p "${program_name} did not find ORACLE_HOME for ${2} database.Please enter it here:- " mb_ask_oracle_home
         mb_read_oracle_home_called=1
     elif [[ $mb_read_oracle_home_found -eq 0 ]]
     then
         read -p "Invalid ORACLE_HOME for ${2} database.you can try `expr 4 - $validate_oracle_home_tries ` more times including this:- " mb_ask_oracle_home
         mb_read_oracle_home_called=1
     fi
     #mb_read_oracle_home_value=$mb_ask_oracle_home
 fi
 mb_db_counter_read=0
}
read_targetversion ()
{
  if [ $read_targetversion_count -eq 0 ]
  then
      read -p "Enter upgrade target version (valid versions are 11.2.0.3.0,11.2.0.4.0 and 12.1.0.1.0):- " targetversion
      targetversion=$(echo $targetversion|sed 's/[A-Za-z]//g')
      targetversion=$(echo $targetversion|sed 's/\.//g')
#      read -p "$targetversion"
      if [ `echo $targetversion|wc -c` -ne 7 ] || [ `echo $supportedTargetVersion|grep -icw $targetversion` -lt 1 ]
      then
          echo -e "${RED}\nInvalid upgrade target version format or upgrade version not yet supported.${NORM}\n"
          correct_target_version=0
      else
          correct_target_version=1
      fi
  else
      read -p "Enter upgrade target version (valid versions are 11.2.0.3.0 and 12.1.0.1.0) `expr 3 - $read_targetversion_count` tries left:- " targetversion
      targetversion=$(echo $targetversion|sed 's/[A-Za-z]//g')
      targetversion=$(echo $targetversion|sed 's/\.//g')
      if [ `echo $targetversion|wc -c` -ne 7 ] || [ `echo $supportedTargetVersion|grep -icw $targetversion` -lt 1 ]
      then
          echo -e "${RED}\nInvalid upgrade target version format or upgrade version not yet supported.${NORM}\n"
          correct_target_version=0
      else
          correct_target_version=1
      fi 
  fi
}

function update_zip_files ()
{
  is_update_needed

#echo "is_update_needed=$update_needed "
  if [[ $update_needed -eq "0" ]] ; then return; fi

  cd $WRKDIR
  for collection_dir in `find . -name "check_env.out" | sed 's/\/check_env.out//'`
  do
#echo "replacing $collection_dir" 
    fdir=$(dirname $collection_dir)
    cd $WRKDIR/$fdir
    collection_dir=$(basename $collection_dir)
    replace_string "$collection_dir/$collection_dir.html"
    replaced_files="$collection_dir/$collection_dir.html"

    for ofile in `find $collection_dir/ -name "9EC87FB8BF2E4ED8E040E50A1EC03015*"`
    do
      replace_string "$ofile"
      replaced_files="$replaced_files $ofile"
    done
    for ofile in `find $collection_dir/ -name "595A436B3A7172FDE0401490CACF5BA5*"`
    do
      replace_string "$ofile"
      replaced_files="$replaced_files $ofile"
    done
    for ofile in `find $collection_dir/ -name "A18401E2DDFF63D2E040E50A1EC077C4*"`
    do
      replace_string "$ofile"
      replaced_files="$replaced_files $ofile"
    done

    if [[ -e "$collection_dir.zip" && -n "$replaced_files" ]] ; then
      zip $collection_dir.zip $replaced_files >/dev/null 2>&1
    elif [  -e "$collection_dir.tar.gz" ] ; then
      rm -f $collection_dir.tar.gz
      tar -cf "$collection_dir.tar.gz"  $collection_dir/* >/dev/null 2>&1
    fi
  done
  mark_update_done
  #exit
}

function replace_string ()
{ 
  l_file=$1
  if [ -e "$l_file" ] ; then
    sed 's/RAT_COMPUTEPASSWORD_INTERNAL=.*//g' $l_file > /tmp/$$.2replace.txt
    cp -f /tmp/$$.2replace.txt $l_file
    rm -f /tmp/$$.2replace.txt
  fi

}

function is_readme_writable ()
{ 
  readme_writable=1
  if [[ -e "$SCRIPTPATH/readme.txt" && -w "$SCRIPTPATH/readme.txt" ]] ; then
    readme_writable=1
  else
    readme_writable=0
  fi
}

function is_update_needed ()
{ 
  is_readme_writable

#echo "$readme_writable $SCRIPTPATH/readme.txt"
  update_needed=1
  if [[ $readme_writable -eq "1" && `grep -ic "f20130501" $SCRIPTPATH/readme.txt` -eq "0"  ]] ; then
    update_needed=0
  else 
    if [ -e "$WRKDIR/.f20130501.txt" ] ; then update_needed=0; fi
  fi
}

function mark_update_done ()
{ 
  is_readme_writable 
  if [ $readme_writable -eq "1" ] ; then
    sed 's/f20130501//' $SCRIPTPATH/readme.txt > /tmp/$$.2replace.txt
    cp -f /tmp/$$.2replace.txt $SCRIPTPATH/readme.txt
    rm -f /tmp/$$.2replace.txt
  else
    touch $WRKDIR/.f20130501.txt
  fi
}

function check_wrkdir ()
{
  touch ${WRKDIR}/$$.touched >/dev/null 2>&1
  if [ $? -ne "0" ] ; then
    # $WRKDIR is not writable
    echo;
    echo -e "${RED}${WRKDIR} is not writable. Please set the RAT_OUTPUT and run again.";
    echo -e "${NORM}"
    echo "ex: export RAT_OUTPUT=/directory/writable"
    echo;
    echo;
    exit 1;
  fi
  rm -f ${WRKDIR}/$$.touched >/dev/null 2>&1
}

change_old_env_variables ()
{
 if [ -n "$RACCHECK_TIMEOUT" ]; then RAT_TIMEOUT=$RACCHECK_TIMEOUT;fi
 if [ -n "$RACCHECK_UPLOAD_CONNECT_STRING" ]; then RAT_UPLOAD_CONNECT_STRING=$RACCHECK_UPLOAD_CONNECT_STRING;fi
 if [ -n "$RACCHECK_UPLOAD_TABLE" ]; then RAT_UPLOAD_TABLE=$RACCHECK_UPLOAD_TABLE;fi
 if [ -n "$RACCHECK_PATCH_UPLOAD_TABLE" ]; then RAT_PATCH_UPLOAD_TABLE=$RACCHECK_PATCH_UPLOAD_TABLE;fi
 if [ -n "$RACCHECK_UPLOAD_USER" ]; then RAT_UPLOAD_USER=$RACCHECK_UPLOAD_USER;fi
 if [ -n "$RACCHECK_UPLOAD_PASSWORD" ]; then RAT_UPLOAD_PASSWORD=$RACCHECK_UPLOAD_PASSWORD;fi
 if [ -n "$RACCHECK_UPLOAD_ORACLE_HOME" ]; then RAT_UPLOAD_ORACLE_HOME=$RACCHECK_UPLOAD_ORACLE_HOME;fi
 if [ -n "$RACCHECK_INV_LOC" ]; then RAT_INV_LOC=$RACCHECK_INV_LOC;fi
 if [ -n "$RACCHECK_CRS_HOME" ]; then RAT_CRS_HOME=$RACCHECK_CRS_HOME;fi
 if [ -n "$RACCHECK_ORACLE_HOME" ]; then RAT_ORACLE_HOME=$RACCHECK_ORACLE_HOME;fi
 if [ -n "$RACCHECK_ASM_HOME" ]; then RAT_ASM_HOME=$RACCHECK_ASM_HOME;fi
 if [ -n "$RACCHECK_OS" ]; then RAT_OS=$RACCHECK_OS;fi
 if [ -n "$RACCHECK_DB" ]; then RAT_DB=$RACCHECK_DB;fi
 if [ -n "$RACCHECK_DBNAMES" ]; then RAT_DBNAMES=$RACCHECK_DBNAMES;fi
 if [ -n "$RACCHECK_DBHOMES" ]; then RAT_DBHOMES=$RACCHECK_DBHOMES;fi
 if [ -n "$RACCHECK_OUTPUT" ]; then RAT_OUTPUT=$RACCHECK_OUTPUT;fi
 if [ -n "$RACCHECK_DEBUG" ]; then RAT_DEBUG=$RACCHECK_DEBUG;fi
 if [ -n "$RACCHECK_INFOPASS" ]; then RAT_INFOPASS=$RACCHECK_INFOPASS;fi
}
generate_exadata_report ()
{
 if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
 then
     echo "<h2>Systemwide firmware and software versions</h2>">> $OUTPUTDIR/${program_name}_versions.html
     echo "<p>Please compare these versions against Database Machine and Exadata Storage Server 11g Release 2 (11.2) Supported Versions (<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=888828.1\">Doc ID 888828.1</a>) in MyOracle Support</p>" >> $OUTPUTDIR/${program_name}_versions.html
 fi

 if [[ `echo $components|grep -iwc SUPERCLUSTER` -le 0 && -e "$OUTPUTDIR/${program_name}_${ASREXACHK}.html" ]] 
 then
    echo "<h2>Systemwide Automatic Service Request (ASR) healthcheck</h2>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
 fi
 #echo "<p>Please check ASR Exadata Configuration Check via ASREXACHECK (<a href=\"https://support.oracle.com/CSP/main/article?cmd=show&type=NOT&id=1450112.1\">Doc ID 1450112.1</a>) in MyOracle Support</p>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html

 for xfilename in `find $OUTPUTDIR \( -name '*asrexachk*' -o -name '*exadata_versions*' \) -print|grep -v cbc`
 do
   if [[ -e $xfilename &&  `echo $xfilename|grep -c report` -lt 1 ]]
   then
       if [[ -e $xfilename &&  `echo $xfilename|grep -c asrexachk` -ge 1 ]]
       then
           node_name=$(basename $xfilename|awk -F_ '{print $NF}'|cut -d. -f1)
           if  [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
           then  
               echo "<h3>Database server $node_name</h3>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
           else
               echo "<h3>Compute Node $node_name</h3>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
           fi
           echo "<pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
           cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
           echo "</pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
       else
           node_name=$(basename $xfilename|awk -F_ '{print $NF}'|cut -d. -f1)
           if  [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
           then  
               echo "<h3>Database server $node_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
           else
               echo "<h3>Compute Node $node_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
           fi
           echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
           cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_versions.html
           echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
       fi
   fi 
 done
 for xfilename in `find $OUTPUTDIR \( -name '*asrexachk*' -o -name '*exadata_versions*' \) -print|grep cbc`
 do
   if [[ -e $xfilename &&  `echo $xfilename|grep -c report` -lt 1 ]]
   then 
       if [[ -e $xfilename &&  `echo $xfilename|grep -c asrexachk` -ge 1 ]]
       then
           node_name=$(basename $xfilename|awk -F_ '{print $NF}'|cut -d. -f1)
           echo "<h3>Storage server $node_name</h3>">> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
           echo "<pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
           cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
           echo "</pre>" >> $OUTPUTDIR/${program_name}_${ASREXACHK}.html
       else 
           node_name=$(basename $xfilename|awk -F_ '{print $NF}'|cut -d. -f1)
           echo "<h3>Storage server $node_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
           echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
           cat $xfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g'>> $OUTPUTDIR/${program_name}_versions.html
           echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
       fi
   fi
 done
 for sfilename in `find $OUTPUTDIR -name 's_nm2version*' -print`
 do
   if [[ -e $sfilename &&  `echo $sfilename|grep -c report` -lt 1 ]]
   then
       switch_name=$(basename $sfilename|cut -d_ -f3|cut -d. -f1)
       echo "<h3>Infinband switch $switch_name</h3>">> $OUTPUTDIR/${program_name}_versions.html
       echo "<pre>" >> $OUTPUTDIR/${program_name}_versions.html
       cat $sfilename | sed 's/<u>/<span style="text-decoration; underline;">/g' | sed 's/<\/u>/<\/span>/g' >> $OUTPUTDIR/${program_name}_versions.html
       echo "</pre>" >> $OUTPUTDIR/${program_name}_versions.html
   fi
 done
}
#Function to write entries of collection to log file if that requires root 
write_root_collections_log ()
{
  echo "OS DATA COLLECTION BY ROOT SENT TO $1" >>$LOGFIL
  echo "ROW = $ROW" >>$LOGFIL
  echo "PARAMETER OR PATH = $PARAM_PATH" >>$LOGFIL
  echo "COMMAND = $COM" >>$LOGFIL
  echo -e "CHECK ID = $CHECK_ID \nCOLLECTION_NAME = $COLLECTION_NAME\n">>$LOGFIL
  echo -e "---------------------------------------------\n\n" >>$LOGFIL
 }
#Function to write values of environment variables to log file if they are set before executing the tool

log_env_varaibles ()
{
 if [ -n "$2" ]; then echo "$1 = $2">>$LOGFIL;echo $fmt_line_header >>$LOGFIL;fi
 #To remove commas if user has used while setting envrionment variable
 if [[ $# -gt 2 && -n "$2"  && `echo $2|grep -ic ","` -gt 0 ]]
 then
     env_var_name=$1
     export $env_var_name="$(echo $2|tr '\054' " ")"  
 fi
}


function wait_for_compute_completion ()
{
  if [[ -n "${#cpids[@]}" && ${#cpids[@]} -eq "0" ]] ; then return ; fi;

  keep_looping=1
  first_time_in_loop=1
  while [ $keep_looping -eq "1" ]
  do
    if [[ -n "${#cpids[@]}" && ${#cpids[@]} -eq "0" ]] ; then return ; fi;
    for cell_pid in "${cpids[@]}"
    do
      # wait till we finish collection running on node
      if [ `ps -ef | grep _compute |grep -c $cell_pid` -gt 0 ]
      then
        if [[ $first_time_in_loop -eq "1" ]] ; then
          printf "\nWaiting for ${program_name} to finish on remote nodes \n\n"
          first_time_in_loop=0
        fi
        printf "."
      else
        cname=${cpid_names[$cell_pid]};
        #echo "Finished run on $cname `date`";
        copy_from_compute;
        unset cpids[$cell_pid]; # remove from array
        cls_check_host_list[$stack_counter]=$cname
        stack_counter=$(expr $stack_counter + 1)
        #echo "Finished report generation on $cname `date`";
        #return;
      fi
    done
    sleep 2
  done

}

function on_signal_compute_cleanup ()
{
  if [[ -n "${#cpids[@]}" && ${#cpids[@]} -eq "0" ]] ; then return ; fi;

  for ib_pid in "${cpids[@]}"
  do
    kill $ib_pid >/dev/null 2>&1
  done
}

function copy_from_compute ()
{
  printf "\n\nCopying results from $cname and generating report. This might take a while. Be patient.\n\n"
  mkdir $OUTPUTDIR/$cname
  $SCOPY -r $cname:$RTEMPDIR $OUTPUTDIR/$cname >/dev/null 2>&1
  rm -f $OUTPUTDIR/$cname/.${program_name}/*.sh 
  rm -f $OUTPUTDIR/$cname/.${program_name}/*.dat 
  rm -f $OUTPUTDIR/$cname/.${program_name}/${program_name}
  rm -f $OUTPUTDIR/$cname/.${program_name}/cgrep

  $SSHELL $cname rm -rf $RTEMPDIR
  cp $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*$cname* $OUTPUTDIR 2>/dev/null
  
  crs_cid_file=$(ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/crs_checkids.out 2>/dev/null)
  cross_node_cid_file=$(ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/cross_node_checkids.out 2>/dev/null)
  
  if [[ -n "$crs_cid_file" && -e "$crs_cid_file" ]] ; then
    if [[ -z "$clusterware_check_count" ]] ; then clusterware_check_count=0; fi
    while read crs_cid
    do
      if [[ $clusterware_check_count -gt "0" ]] ; then
        # Check if it exists in array else insert
        crs_cid_exists=0
        for cid_in_arr in "${crs_check_id[@]}"
        do
          if [[ $cid_in_arr = $crs_cid ]] ; then crs_cid_exists=1; fi
        done
        if [[ $crs_cid_exists -eq "0" ]] ; then
          crs_check_id[$clusterware_check_count]=$crs_cid
          clusterware_check_count=$(expr $clusterware_check_count + 1)
        fi
      else
        crs_check_id[$clusterware_check_count]=$crs_cid
        clusterware_check_count=$(expr $clusterware_check_count + 1)
      fi
    done < $crs_cid_file
  fi

  crs_stack_counter=$clusterware_check_count
  crs_check_file_counter=0
  while [[ $crs_stack_counter -gt 0 && $SILENT -eq 0 ]]
  do  # append cluster wide check o/p
    CLUSTERCHECK_FIL=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}.out
    caf=$(ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${crs_check_id[$crs_check_file_counter]}.out 2>/dev/null)
    if [[ -n "$caf" ]] ; then
      cat $caf >> $CLUSTERCHECK_FIL
      rm -f $caf
    fi
    crs_check_file_counter=$(expr $crs_check_file_counter + 1);
    crs_stack_counter=$(expr $crs_stack_counter - 1)
  done

  run_report;
  cat $OUTPUTDIR/$cname.slave.log
  rm -rf $OUTPUTDIR/$cname/ 
}

function run_report ()
{
  i=$cname
  cnt=0
  #echo "checkinmg and removing files from .${program_name}/${program_name}_${FDS}/"
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_results.xml |grep -v "Results modelVersion=" > $OUTPUTDIR/${cname}_results.xml 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_summary.html >> $OUTPUTDIR/patch_summary.html 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_detailed.html >> $OUTPUTDIR/patch_detailed.html 2>/dev/null
  rm -f $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_summary.html $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/patch_detailed.html 2>/dev/null
  for file in `ls $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_timings.out 2>/dev/null`
  do
    filen=$(basename $file)
    cat $file >> $OUTPUTDIR/$filen
  done

  #while read line
  #do
  #  if [[ `echo $line | grep -ic CheckID` -gt 0 ]] ; then
  #    CHECK_ID=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #    status_on_target="";
  #  fi
  #  if [[ `echo $line | grep -ic CheckType` -gt 0 ]] ; then
  #    COMTYPE=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #  fi
  #  if [[ `echo $line | grep -ic "<Status>"` -gt 0 ]] ; then
  #    l_chk_status=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #    if [[ $l_chk_status = "PASS" ]] ; then ALVL="PASS"; fi;
  #  fi
  #  if [[ `echo $line | grep -ic "<AlertType>"` -gt 0 ]] ; then
  #    ALVL=$(echo $line | cut -d">" -f2 | cut -d"<" -f1)
  #  fi
  #  if [[ `echo $line | grep -ic "<ColumnValue Name=.InstanceName."` -gt 0 ]] ; then
  #    status_on_target=$(echo $line | cut -d"\"" -f4)
  #  fi
  #  if [[ `echo $line | grep -ic "/[a-zA-Z]*Result>"` -gt 0 ]] ; then
  #    read_checkid_vars;
  #    create_report_files;
  #  fi
  #done  < $OUTPUTDIR/${cname}_results.xml
  if [ -e "$OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/slave_results.out" ]
  then 
    while read line
    do
      CHECK_ID=$(echo $line | cut -d"|" -f1)
      ALVL=$(echo $line | cut -d"|" -f2)
      COMTYPE=$(echo $line | cut -d"|" -f3)
      status_on_target=$(echo $line | cut -d"|" -f4)
      db_name_to_check=$(echo $line | cut -d"|" -f5)
      inst_name=$(echo $line | cut -d"|" -f6)
      mb_db_homes=$(echo $line | cut -d"|" -f7)
      message4Home=$(echo $line | cut -d"|" -f8)
      cch_cname=$(echo $line | cut -d"|" -f9)
      sl_hosts=$(echo $line | cut -d"|" -f10)
      read_checkid_vars;
      create_report_files;
    done < $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/slave_results.out
  fi

  cat $OUTPUTDIR/${cname}_results.xml >> $XMLREPFIL 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_exceptions.xml |grep -v "Exclusions modelVersion" >> $XMLSKIPFIL 2>/dev/null
  if [ -e "$OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${program_name}.rep" ]
  then
    for file in $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*.rep
    do
      fname=$(basename $file)
      cat $file >> $OUTPUTDIR/$fname
    done
  fi

  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_skipped_checks.log >> $OUTPUTDIR/${program_name}_skipped_checks.log 2>/dev/null
  echo "LOG FROM $i" >> $OUTPUTDIR/watchdog.log
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/watchdog.log >> $OUTPUTDIR/watchdog.log 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/*_env.out.diff | grep '^> ' | sed 's/^..//' >> $MASTERFIL 2>/dev/null
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${program_name}.log >> $LOGFIL 2>/dev/null
  echo "LOG FROM $i" >> $ERRFIL
  cat $OUTPUTDIR/$cname/.${program_name}/${program_name}_${FDS}/${program_name}_error.log >> $ERRFIL 2>/dev/null
}

function create_report_files ()
{
  #echo "creating report for  $ALVL $CHECK_ID";
  init_arrays_html "$ALVL"
  write_additional_info $ALVL
  # gadiga for SHS
  if [[ $ALVL != "PASS" ]] ; then
    case "$ALVL" in
      "FAIL")
            let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
            ;;
      "WARNING")
            let G_WARN_CHECKS=$G_WARN_CHECKS+1
            ;;
      "INFO")
            let G_INFO_CHECKS=$G_INFO_CHECKS+1
            ;;
      *)
            let G_FAIL_CHECKS=$G_FAIL_CHECKS+1
            ;;
    esac
  fi
  let G_TOTAL_CHECKS=$G_TOTAL_CHECKS+1
  # end code for SHS

}

function read_checkid_vars()
{
  PARAM_PATH=`grep _$CHECK_ID\-PARAM_PATH $REFFIL |awk {'print $2'}`
  HOME_PATH=`grep _$CHECK_ID\-HOME_PATH $REFFIL |awk {'print $2'}`
  ISBRANCH=`grep _$CHECK_ID\-IS_BRANCH $REFFIL |awk {'print $2'} `
  EPFILRES_ROOT_OS=`grep _$CHECK_ID\-REQUIRES_ROOT $REFFIL |awk {'print $2'}`
  PARAM=`grep "_"$CHECK_ID"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
  NEEDS_RUNNING=`grep "_"$CHECK_ID"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
  execute_once=`grep "_"$CHECK_ID"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
  check_exadata_version=$(grep "_"$CHECK_ID"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
  check_database_role=$(grep "_"$CHECK_ID"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
  SF=`grep "_"$CHECK_ID"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
  check_components=`grep "_"$CHECK_ID"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
  OP=`grep _$CHECK_ID\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
  if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$CHECK_ID\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'`
  if [[ -z "$COMP" && -e $REFFIL1 ]];then  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
  audit_check_name=`grep "_"${CHECK_ID}"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
  COM=`grep "_"$CHECK_ID"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`

  if [[ `echo $COM|grep -ic "limits.conf"` -ge 1 || `echo $COM|grep -ic "usrlimit"` -ge 1 ]]; then ulimit_cmd=1;else ulimit_cmd=0;fi

  htmlf=$(ls $OUTPUTDIR/$i/.${program_name}/${program_name}_${FDS}/$CHECK_ID.html |tail -1)
  FMSG="$cch_cname"
  PMSG="$cch_cname"
  SOURCEFIL_REPORT=""
  SOURCEFIL_REPORT_NEW=""
  if [ -n "$htmlf" ] ; then
    #grep_for="Status"
    #if [[ `grep -ic "Status on" $htmlf` -gt 1 && -n "$status_on_target" ]] ; then
    #  grep_for="$status_on_target"
    #fi

    #FMSG=$(grep "Status on" $htmlf |grep "$grep_for" |sed 's/.*=> //' | sed 's/<\/p.*//')
    #PMSG=$FMSG
    #ALVL=$(grep "Status on" $htmlf |grep "$grep_for" |tail -1 | sed 's/<\/span> =>.*//' |sed 's/.*span class="status_//' | cut -d">" -f2)
    SOURCEFIL_REPORT=$htmlf
    SOURCEFIL_REPORT_NEW=$htmlf
  else
    echo "#### Did not find html file for $CHECK_ID on $i"
  fi
}

function copy_env_files_to_tmp ()
{
  TRGTORCLENV=/tmp/`basename $ORCLENVFIL`
   if [ $OFFLINE -eq 0 ]
   then
        if [ $i = $localnode ]
        then
            if [ ! -e "$TRGTORCLENV" ]; then cp -r $ORCLENVFIL /tmp >/dev/null 2>&1;fi
            if [ ! -e "/tmp/raccheck_env.out" ]; then cp -r $MASTERFIL /tmp >/dev/null 2>&1;fi
        else
            remote_trgtenvfile=$($SSHELL $i  "ls -l $TRGTORCLENV 2>/dev/null|wc -l")
            if [ $remote_trgtenvfile -le 0 ]; then $SCOPY $ORCLENVFIL $i:/tmp/ >/dev/null 2>&1;fi
            remote_masterfile=$($SSHELL $i  "ls -l /tmp/raccheck_env.out 2>/dev/null|wc -l")
            if [ $remote_masterfile -le 0 ]; then $SCOPY $MASTERFIL $i:/tmp/ >/dev/null 2>&1;fi
        fi
  fi
  #if [[ $OFFLINE -eq 0 && ! -e "$TRGTORCLENV" ]] ; then
  #  if [ $i = $localnode ]; then cp $ORCLENVFIL /tmp; 
  #  else  $SCOPY $ORCLENVFIL $i:/tmp/ >/dev/null;fi;
  #fi
  #if [[ $OFFLINE -eq 0 && ! -e "/tmp/raccheck_env.out" ]] ; then
  #  if [ $i = $localnode ]; then cp $MASTERFIL /tmp; 
  #  else  $SCOPY $MASTERFIL $i:/tmp/ >/dev/null;fi;
  #fi
}

# watch all pids running in background and unset array element when not found  
# exit when there are no elements

function wait_for_cell_completion ()
{
  if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] ; then return ; fi;

  keep_looping=1
  while [ $keep_looping -eq "1" ]
  do
    if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] ; then return ; fi;
    for cell_pid in "${cell_pids[@]}"
    do
      # wait till we finish collection running on cell
      if [ `ps -ef | grep _cell |grep -c $cell_pid` -gt 0 ]
      then
        if [[ -n "$cell_type" && $cell_type  = "zfscell" ]] ; then 
	#if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] ; then
          printf "."
	fi
        #echo "runing $cell_pid on ${cell_pid_names[$cell_pid]}";
      else
        #echo "Finished run($cell_pid) on ${cell_pid_names[$cell_pid]}";
        cellname=${cell_pid_names[$cell_pid]};
        cell_rootpassword=${cell_root_password[$cell_pid]}
        copy_from_cell;
        cleanup_cell;
        unset cell_pids[$cell_pid]; # remove from array
      fi
    done
    sleep 2
  done

}

function on_signal_cell_cleanup ()
{
  if [[ -n "${#cell_pids[@]}" && ${#cell_pids[@]} -eq "0" ]] ; then return ; fi;
  for cell_pid in "${cell_pids[@]}"
  do
    kill -9 $cell_pid >/dev/null 2>&1
    cell_rootpassword=${cell_root_password[$cell_pid]}
    cellname=${cell_pid_names[$cell_pid]};
    cleanup_cell;
  done
}

function setup_cell ()
{
  fixRootPassword "$cell_rootpassword"
  /usr/bin/expect -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $CELLSSCRPT $SCRIPTPATH/.cgrep/$ASREXACHK $cell_ssh_user@$cellname:/tmp
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while copying on $cellname\n";
        exit
      }

    }
IBEOF
  /usr/bin/expect -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname mkdir ${RTEMPDIR}
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while running mkdir on $cellname\n";
        exit
      }

    }
IBEOF
  /usr/bin/expect -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname chmod 755 /tmp/${program_name}_cells.sh /tmp/$ASREXACHK
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while chmod on $cellname\n";
        exit
      }

    }
IBEOF

}

# TODOS
# Create this as a script so that different passwords are handled. This will work only when password is same on all cells.

function copy_from_cell ()
{
  fixRootPassword "$cell_rootpassword"
  /usr/bin/expect -f - 2>>$ERRFIL << IBEOF
    #set timeout 5
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $cell_ssh_user@$cellname:${RTEMPDIR}/c_*.out $CELLDIR
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while copying files from $cellname\n";
        exit
      }

    }
IBEOF
  if [[ -e $CELLDIR/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
  then
    cat $CELLDIR/c_root_collect_timing.out >> $COLLECT_TIMING
    rm -f $CELLDIR/c_root_collect_timing.out  >/dev/null 2>&1
  fi
}

function cleanup_cell ()
{
  fixRootPassword "$cell_rootpassword"
  /usr/bin/expect -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname rm -f ${RTEMPDIR}/c_*.out ${RTEMPDIR}/o_*.out /tmp/${program_name}_cells.sh /tmp/$ASREXACHK
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while removing files on $cellname\n";
        exit
      }

    }
IBEOF
  /usr/bin/expect -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_cell_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $cell_ssh_user@$cellname rmdir  ${RTEMPDIR}
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
        send -- "\$le_cell_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while removing temp dir on $cellname\n";
        exit
      }

    }
IBEOF
}

# Start the run in  background
# Put the current pid in cell_pids[pid]=pid

function start_run_on_cell_in_background ()
{
  cleanup_cell;
  setup_cell;
  t_flag="";
  sudo_flag="";
  if [[ -n "$DOROOT" && $DOROOT -eq 1 && -n "$RAT_CELL_SSH_USER" && $RAT_CELL_SSH_USER = "celladmin" ]] || [[ -n "$RAT_CELL_SSH_USER" && "$RAT_CELL_SSH_USER" = "cellmonitor" ]]
  then
    t_flag="-t";
    sudo_flag="sudo";
  fi
  rm -f $RTEMPDIR/cell.pid
  cr_file=$RTEMPDIR/${program_name}_cell_$cellname.sh
  #cp ${CELLSSCRPT} /tmp/${program_name}_cells_$cellname.sh
  echo "#!/bin/env bash" > $cr_file
  echo "echo \$\$ > $RTEMPDIR/cell.pid" >> $cr_file
  if [ $in_last_cell -eq 1 ] ; then
    echo "$SSHELL $t_flag $cell_ssh_user@$cellname  $sudo_flag /tmp/${program_name}_cells.sh 2>>$ERRFIL|tee ${RTEMPDIR}/${cellname}.out" >> $cr_file
  else
    echo "$SSHELL $t_flag $cell_ssh_user@$cellname  $sudo_flag /tmp/${program_name}_cells.sh > ${RTEMPDIR}/${cellname}.out 2>>$ERRFIL" >> $cr_file
  fi
  chmod +x $cr_file
  fixRootPassword "$cell_rootpassword"
  /usr/bin/expect -f - 2>>$WATCHLOG << IBEOF &
    set timeout $passwordcheck_timeout
    set timeout $watchdog_wakeup_root
    set le_cell_rootpassword "$fixedRootPassword"
    spawn -noecho $cr_file
    match_max 100000
    expect {
      "no)?" {
         send -- "yes\n"
       }
      "*?assword:*" {
	send -- "\$le_cell_rootpassword\n"
      }
      eof {
         exit
       }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
	send -- "\$le_cell_rootpassword\n"
      }
      eof {
        exit
      } timeout {
        send_error "Timed out while running collections on $cellname\n";
        exit
      }
    }
IBEOF
  #sleep 2;
  #cell_pid=$(cat $RTEMPDIR/cell.pid)
  cell_pid=$!
  cell_pids[$cell_pid]="$cell_pid";
  cell_pid_names[$cell_pid]="$cellname"
  cell_root_password[$cell_pid]="$cell_rootpassword"
}


# functions to run collection on ib switches in background
function start_run_on_ib_in_background ()
{
  cleanup_ib;
  setup_ib;
  rm -f $RTEMPDIR/ib.pid
  cr_file=$RTEMPDIR/${program_name}_run_ibswitch_$switchname.sh
  cp $IBSWITCHSCRPT /tmp/${program_name}_ibswitch_$switchname.sh
  echo "#!/bin/env bash" > $cr_file
  echo "echo \$\$ > $RTEMPDIR/ib.pid" >> $cr_file
  if [ $in_last_ib -eq 1 ] ; then
    echo "$SSHELL_EL $ibswitch_user@$switchname  < /tmp/${program_name}_ibswitch_$switchname.sh 2>>$ERRFIL |tee ${RTEMPDIR}/${switchname}.out" >> $cr_file
  else
    echo "$SSHELL_EL $ibswitch_user@$switchname  < /tmp/${program_name}_ibswitch_$switchname.sh > ${RTEMPDIR}/${switchname}.out 2>>$ERRFIL" >> $cr_file
  fi
  chmod +x $cr_file

  fixRootPassword "$switch_rootpassword"

  /usr/bin/expect -f - 2>>$WATCHLOG << IBEOF &
    set timeout $passwordcheck_timeout
    set timeout $watchdog_wakeup_root
    set le_switch_rootpassword "$fixedRootPassword"
    spawn -noecho $cr_file
    match_max 100000
    expect {
      "no)?" {
         send -- "yes\n"
       }
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      eof {
         exit
       }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      eof {
        exit
      } timeout {
        send_error "Timed out while running collections on $switchname\n";
        exit
      }
    }
IBEOF
  #sleep 2;
  #ib_pid=$(cat $RTEMPDIR/ib.pid)
  ib_pid=$!
  ib_pids[$ib_pid]="$ib_pid";
  ib_pid_names[$ib_pid]="$switchname"
  ib_root_password[$ib_pid]="$switch_rootpassword"
}

function wait_for_ib_completion ()
{
  if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]] ; then return ; fi;

  keep_looping=1
  while [ $keep_looping -eq "1" ]
  do
    if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]] ; then return ; fi;
    for ib_pid in "${ib_pids[@]}"
    do
      # wait till we finish collection running on ib switch
      if [ `ps -ef | grep _ibswitch_ |grep -c $ib_pid` -gt 0 ]
      then
        printf ""
      else
        #echo "Finished run on ${ib_pid_names[$ib_pid]}";
        switchname=${ib_pid_names[$ib_pid]};
        switch_rootpassword=${ib_root_password[$ib_pid]}
        copy_from_ib;
        cleanup_ib;
        unset ib_pids[$ib_pid]; # remove from array
      fi
    done
    sleep 2
  done
}

function on_signal_ib_cleanup ()
{
  if [[ -n "${#ib_pids[@]}" && ${#ib_pids[@]} -eq "0" ]] ; then return ; fi;

  for ib_pid in "${ib_pids[@]}"
  do
    kill -9 $ib_pid >/dev/null 2>&1
    switchname=${ib_pid_names[$ib_pid]};
    switch_rootpassword=${ib_root_password[$ib_pid]}
    cleanup_ib;
  done
}

function setup_ib ()
{
  fixRootPassword "$switch_rootpassword"
  $EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SSHELL $ibswitch_user@$switchname mkdir ${RTEMPDIR}
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while creating temp dir on $switchname\n";
        exit
      }

    }
IBEOF
$EXPECT -f - 2>>$ERRFIL << IBEOF
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $SWITCH_TYPE_FIL $ibswitch_user@$switchname:${RTEMPDIR}
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while creating temp dir on $switchname\n";
        exit
      }

    }
IBEOF
}

function copy_from_ib ()
{
  fixRootPassword "$switch_rootpassword"
  /usr/bin/expect -f - 2>>$ERRFIL << IBEOF
    #set timeout 5
    set timeout $passwordcheck_timeout
    set le_switch_rootpassword "$fixedRootPassword"
    log_user 0
    spawn $SCOPY $ibswitch_user@$switchname:${RTEMPDIR}/s_*.out $OUTPUTDIR
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while copying files from $switchname\n";
        exit
      }

    }
IBEOF
  if [[ -e $OUTPUTDIR/s_root_collect_timing.out && -e $COLLECT_TIMING ]]
  then
    cat $OUTPUTDIR/s_root_collect_timing.out >> $COLLECT_TIMING
    rm -f $OUTPUTDIR/s_root_collect_timing.out  >/dev/null 2>&1
  fi

}

function cleanup_ib ()
{
  if [ -e "/tmp/${program_name}_ibswitch_$switchname.sh" ] ; then
    rm -f /tmp/${program_name}_ibswitch_$switchname.sh
  fi

  fixRootPassword "$switch_rootpassword"

  /usr/bin/expect -f - 2>>$ERRFIL << IBEOF
  set timeout $passwordcheck_timeout
  set le_switch_rootpassword "$fixedRootPassword"
  log_user 0
  spawn $SSHELL $ibswitch_user@$switchname rm -f ${RTEMPDIR}/s_*.out ${RTEMPDIR}/o_*.out ${RTEMPDIR}/${SWITCH_TYPE_FIL_SHORT}
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while cleaning files on $switchname\n";
        exit
      }

    }
IBEOF
  /usr/bin/expect -f - 2>>$ERRFIL << IBEOF
  set timeout $passwordcheck_timeout
  set le_switch_rootpassword "$fixedRootPassword"
  log_user 0
  spawn $SSHELL $ibswitch_user@$switchname rmdir ${RTEMPDIR}
    match_max 100000
    expect {
      "no)?" {
        send -- "yes\n"
      }
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      eof {
        exit
      }
    }
    # Look for passwd prompt
    expect {
      "*?assword:*" {
	send -- "\$le_switch_rootpassword\n"
      }
      # Stop the on logon tests and if asked to connect to master switch choose no
      eof {
        exit
      } timeout {
        send_error "Timed out while removing temp dir on $switchname\n";
        exit
      }

    }
IBEOF

}

#Function to validate root password
checkUserPassword ()
{
 validateUserPassword=$4
 nodeNameToCheck=$1
 userToCheck=$2
 passwordToCheck=$3

 fixRootPassword "$passwordToCheck"

 if [ -n "$5" ] 
 then
  targetHostType="$5"
 else
  targetHostType="normal"
 fi
 if [[ -n "$5" && "$5" = "ibswitch" ]]; then hostTypeSwitch=1;else hostTypeSwitch=0;fi
 if [[ -n "$5" && "$5" = "normal" ]]; then hostTypeCell=1;else hostTypeCell=0;fi
 if [[ `uname -s` = "Linux" || $hostTypeCell -eq 1 ]] && [ $hostTypeSwitch -eq 0 ];then loginDelayHost=1;else loginDelayHost=0;fi  
 #stty -echo
 if [[ -n "$RAT_PASSWORDCHECK_TIMEOUT" && $RAT_PASSWORDCHECK_TIMEOUT -gt 1 ]]; then passwordcheck_timeout=$RAT_PASSWORDCHECK_TIMEOUT;else passwordcheck_timeout=10;fi
 #echo "passwordcheck_timeout=$passwordcheck_timeout"
 if [ $validateUserPassword -gt 1 ]; then  hasDollar=$(echo $passwordToCheck|grep -c "$");if [ $hasDollar -ge 1 ]; then passwordToCheck=$(echo $passwordToCheck|sed 's/\$/\\$/g');fi;fi

 if [[ $targetHostType = "zfscell" ]] ; then passwordcheck_timeout=10; fi

 $EXPECT -f - << IBEOF
                           set timeout $passwordcheck_timeout
			   set le_passwordToCheck "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } { 
                             exp_internal 1
                           } 
			   if { "$targetHostType" != "zfscell" } {
                             spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck "echo \"LoginSuccessfull\""
			   } else {
                             spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck script "printf(\"LoginSuccessfull\\\\n\");"
			   }
                           match_max 100000
                           expect {
                             "no)?" {
                                 send -- "yes\n"
                                 }
                             "*?assword:*" {
				 send -- "\$le_passwordToCheck\n"
                                 }
                             "Permission denied *" {
                                 exit 2;
                                 }
                             LoginSuccessfull { exit 0; }
 			     timeout {
                                 send_error "Timed out\n";
                                 exit 3
                             }
                             eof {
                                 exit 0
                                 }
                          }
                           expect {
                             "*?assword:*" {
				 send -- "\$le_passwordToCheck\n"
                                 }
                             "Permission denied *" {
                                 exit 2;
                                 }
                             LoginSuccessfull { exit 0; }
 			     timeout {
                                 send_error "Timed out\n";
                                 exit 3
                             }
                             eof {
                                 exit 0
                                 }
                          }
                        expect {
                                default {exit 2}
                                LoginSuccessfull
                               }
                         exit 0
IBEOF
 #stty echo
 passwordCheckStatus=$(echo $?)
 if [[ $passwordCheckStatus -eq "3" ]] ; then
    passwordCheckStatus=2
 #  echo -e  "\n\n${RED}Timed out while checking password on ${nodeNameToCheck}\n. Set RAT_PASSWORDCHECK_TIMEOUT to increase timeout. Ex: export RAT_PASSWORDCHECK_TIMEOUT=10\n\n${program_name} is exiting.${NORM}"
 fi
 if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $loginDelayHost -eq 1  && passwordCheckStatus -ne 0 && $validateUserPassword -gt 1 ]]
 then
    echo -e  "\n\n${RED}The password entered for the ${userToCheck}  userid did not validate on ${nodeNameToCheck}\n\nThis userid may now be subject to a login delay on the specified node.Please review the pam utility configuration, and allow the specified amount of login delay time to elapse before retrying exachk.Please also check your pam failed login counts for this userid against the permitted total, and clear if required.\n\n${program_name} is exiting.${NORM}"
    exit
 fi
 while [[ $passwordCheckStatus -ne 0  && $validateUserPassword -gt 1 ]]
  do
    validateUserPassword=$(expr $validateUserPassword - 1 )
    echo -e "\n\n${RED}${userToCheck} password for $nodeNameToCheck was incorrect. $validateUserPassword retries remaining.${NORM}\n"
    printf  "Enter $userToCheck  password for ${BLINK}${nodeNameToCheck}${NORM} :- "
    stty -echo
    read -r passwordToCheck

    fixRootPassword "$passwordToCheck"

    if [ $validateUserPassword -gt 1 ]; then  hasDollar=$(echo $passwordToCheck|grep -c "$");if [ $hasDollar -ge 1 ]; then passwordToCheck=$(echo $passwordToCheck|sed 's/\$/\\$/g');fi;fi
    $EXPECT -f - << IBEOF
                           set timeout $passwordcheck_timeout
			   set le_passwordToCheck "$fixedRootPassword"
                           log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } { 
                             exp_internal 1
                           } 
			   if { "$targetHostType" == "normal" } {
                             spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck "echo \"LoginSuccessfull\""
			   } else {
                             spawn -noecho $SSHELL $userToCheck@$nodeNameToCheck script "printf(\"LoginSuccessfull\\\\n\");"
			   }
                           match_max 100000
                           expect {
                             "no)?" {
                                 send -- "yes\n"
                                 }
                             "*?assword:*" {
				 send -- "\$le_passwordToCheck\n"
                                 }
                             "Permission denied *" {
                                 exit 2;
                                 }
                             LoginSuccessfull { exit 0; }
 			     timeout {
                                 send_error "Timed out\n";
                                 exit 2
                             }
                             eof {
                                 exit 0
                                 }
                          }
                           expect {
                             "*?assword:*" {
				send -- "\$le_passwordToCheck\n"
                                 }
                             "Permission denied *" {
                                 exit 2;
                                 }
                             LoginSuccessfull { exit 0; }
 			     timeout {
                                 send_error "Timed out\n";
                                 exit 2
                             }
                             eof {
                                 exit 0
                                 }
                          }
                        expect {
                                default {exit 2}
                                LoginSuccessfull
                               }
                         exit 0
IBEOF
    passwordCheckStatus=$(echo $?)
    if [[ $passwordCheckStatus -eq "3" ]] ; then
      echo -e  "\n\n${RED}Timed out while checking password on ${nodeNameToCheck}\n. Set RAT_PASSWORDCHECK_TIMEOUT to increase timeout. Ex: export RAT_PASSWORDCHECK_TIMEOUT=10\n\n${program_name} is exiting.${NORM}"
      exit;
    fi
    stty echo
 done
 if [[ $passwordCheckStatus -ne 0  && $4 -gt 1 ]]
 then
    echo -e "\n\n${RED}${userToCheck} password for $nodeNameToCheck was incorrect. $userToCheck privileged checks will not be executed on $nodeNameToCheck ${NORM}\n"
    noRootScriptNode[$noRootScriptNodeCount]=$nodeNameToCheck
    noRootScriptNodeCount=$( expr $noRootScriptNodeCount + 1 )
 fi
# echo "\n noRootScriptNode=${noRootScriptNode[*]}"
#echo "passwordCheckStatus=$passwordCheckStatus"
}

checkCellSshConfig ()
{
 cell_ssh_counter=0
 for cellip in `cat $CELLIP|cut -d\" -f2`
 do
   cell_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $1 $cellip pwd >/dev/null 2>&1;echo $?);
   if [ $cell_ssh_status -ne 0 ];then a_cellWithNoSsh[$cell_ssh_counter]=$cellip;fi
   cell_ssh_counter=$(expr $cell_ssh_counter + 1 )
 done
 cell_ssh_counter=0
}
show_version ()
{
   dataFilesDate=$($GREP FILE_DATE $REFFIL|awk '{print $3}')
   dataFIleMonth=$(echo $dataFilesDate|cut -d- -f2|tr "[a-z]" "[A-Z]")  
   case $dataFIleMonth in
     JAN) dataFIleMonthNo=01;;
     FEB) dataFIleMonthNo=02;;
     MAR) dataFIleMonthNo=03;;
     APR) dataFIleMonthNo=04;;
     MAY) dataFIleMonthNo=05;;
     JUN) dataFIleMonthNo=06;;
     JUL) dataFIleMonthNo=07;;
     AUG) dataFIleMonthNo=08;;
     SEP) dataFIleMonthNo=09;;
     OCT) dataFIleMonthNo=10;;
     NOV) dataFIleMonthNo=11;;
     DEC) dataFIleMonthNo=12;;
     *) dataFIleMonthNo=00;;
   esac
   dataFIleDay=$(echo $dataFilesDate|cut -d- -f1|tr "[a-z]" "[A-Z]")  
   dataFIleYear=$(echo $dataFilesDate|cut -d- -f3|tr "[a-z]" "[A-Z]")  
   #echo -e "\n$program_name  version: 2.1.0.${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}\n"
}
 
# gadiga : create /tmp/.program in all nodes to store temp files

create_rtemp_dir ()
{
  for hname in `cat $HOSTLIST`
  do
    if [ $hname != $localnode ]
    then
	 $SSHELL $hname "$bash_scr -c \"if [ -f $RTEMPDIR ] ; then rm -f $RTEMPDIR >/dev/null 2>&1; fi; if [ ! -d $RTEMPDIR ]; then mkdir -p $RTEMPDIR>/dev/null 2>&1;fi\""
         $SSHELL $hname "$bash_scr -c \"if [ ! -e $EXADATA_CELL_COLLECTIONS ]; then touch $EXADATA_CELL_COLLECTIONS;fi\""
         remote_script='
         i=0;
	 hname=$(hostname);
         if [ -e "/etc/profile" ] ;
         then
                   pfiles[$i]="/etc/profile";
                   i=$(($i + 1));
         fi;
         bpfile=""
         if [ -e "$HOME/.bash_profile" ] ;
         then
                   pfiles[$i]="$HOME/.bash_profile";
                   bpfile="$HOME/.bash_profile";
                   i=$(($i + 1));
         elif [ -e "$HOME/.bash_login" ] ;
         then
                   pfiles[$i]="$HOME/.bash_login";
                   bpfile="$HOME/.bash_login";
                   i=$(($i + 1));
         elif [ -e "$HOME/.profile" ] ;
         then
                   pfiles[$i]="$HOME/.profile";
                   bpfile="$HOME/.profile";
                   i=$(($i + 1));
         fi
         C_PROMPT=0;
         FFILES="";
         for pfile in ${pfiles[*]}
         do
         remote_profile_prompt_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e '\''s/^[ ]*//'\''|grep -v ^#|grep -ci '\''read -p'\'')
         remote_profile_trap_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e '\''s/^[ ]*//'\''|grep -v ^#|grep -wi '\''trap'\'' | grep -wci '\''logout'\'')
         remote_profile_oraenv_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e '\''s/^[ ]*//'\''|grep -v ^#|grep -ciw '\''oraenv'\'')

         if [[ -n "$remote_profile_prompt_check" ]] && [[ $remote_profile_prompt_check -gt 0 || $remote_profile_trap_check -gt 0 || $remote_profile_oraenv_check -gt 0 ]]
         then
                C_PROMPT=1;
                FFILES=$FFILES" "$pfile;
         fi
         done

         if [ $C_PROMPT -eq 1 ];
         then
                echo -e "There are prompts, traps or calling oraenv in $FFILES on $hname which will cause issue in $program_name successful execution. Please remove or comment all read -p, trap and oraenv statments and run again"
         else
                echo "PASS";
         fi
'
        #-----Different shell issue
        echo "#!$bash_scr" > /tmp/cprofile.sh
        echo "$remote_script" >> /tmp/cprofile.sh
        chmod +x /tmp/cprofile.sh
        $SCOPY /tmp/cprofile.sh $hname:/tmp

        $($SSHELL -o NumberOfPasswordPrompts=0 $hname 'chmod +x /tmp/cprofile.sh >/dev/null');
        remote_node_profile=$($SSHELL -o NumberOfPasswordPrompts=0 $hname /tmp/cprofile.sh)
        $($SSHELL -o NumberOfPasswordPrompts=0 $hname 'rm -f /tmp/cprofile.sh >/dev/null');
        #-------
	
        if [ "$remote_node_profile" != "PASS" ];
        then
                echo -e $RED"\n\n$remote_node_profile\n\n"$NORM;
                exit 1;
        fi
    else
      i=0;
      if [ -e "/etc/profile" ] ;
      then
                pfiles[$i]="/etc/profile";
                i=$(($i + 1));
      fi;
      bpfile=""
      if [ -e "$HOME/.bash_profile" ] ;
      then
                pfiles[$i]="$HOME/.bash_profile";
                bpfile="$HOME/.bash_profile";
                i=$(($i + 1));
      elif [ -e "$HOME/.bash_login" ] ;
      then
                pfiles[$i]="$HOME/.bash_login";
                bpfile="$HOME/.bash_login";
                i=$(($i + 1));
      elif [ -e "$HOME/.profile" ] ;
      then
                pfiles[$i]="$HOME/.profile";
                bpfile="$HOME/.profile";
                i=$(($i + 1));
      fi

      C_PROMPT=0;
      FFILES='';
      for pfile in ${pfiles[*]}
      do
        profile_prompt_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e 's/^[ ]*//'|grep -v ^#|grep -ci 'read -p')
        profile_trap_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e 's/^[ ]*//'|grep -v ^#|grep -wi 'trap' |grep -wci 'logout')
        profile_oraenv_check=$(cat $pfile /dev/null 2>&1|tr "\011" " "|sed -e 's/^[ ]*//'|grep -v ^#|grep -ciw 'oraenv')
        if [[ -n "$profile_prompt_check" ]] && [[ $profile_prompt_check -gt 0 || $profile_oraenv_check -gt 0 || $profile_trap_check -gt 0 ]]
        then
                C_PROMPT=1;
                FFILES=$FFILES" "$pfile;
        fi
      done
      if [ $C_PROMPT -eq 1 ];
      then
        echo -e $RED"\n\nThere are prompts, traps or calling oraenv in $FFILES on $hname which will cause issue in $program_name successful execution. Please remove or comment all read -p, trap and oraenv statments and run again\n\n"$NORM
        exit 1
      fi
    fi
      #profile prompt checking code ends here
  done
}

create_rtemp_dir_in_cells ()
{
  for cellname in `cat $CELLIP|cut -d\" -f2`
  do
    $SSHELL $cell_ssh_user@$cellname " if [ ! -d $RTEMPDIR ]; then mkdir -p $RTEMPDIR>/dev/null 2>&1;fi"
  done
}

is_this_oda ()
{
  if [ $OFFLINE -eq 0 ]
  then
      if [ -e /opt/oracle/oak/install/inittab ] 
      then
	  oda_machine=1
          it_is_rac=0
          ORANGE="\033[35;40m"
          components=$(echo ${user_components}:ODA)
          #changin default timeout for ODA
          if [ -z "$RAT_ROOT_TIMEOUT" ]; then watchdog_wakeup_root=600;echo -e "\nincreasing root collection time out to 600 for ODA\n">>$LOGFIL;fi
          #Added new model to support VM in ODA
          if [[ -n "$VMTYPE" && "$VMTYPE" = "PVM" ]]; then components=$(echo ${user_components}:ODA_VM) ;fi
          #To copy rpm_list.out file from script dir to .cgrep to be used for custom rpm audit check
          if [ -f $SCRIPTPATH/bm_rpm_list.out ]; then cp  $SCRIPTPATH/bm_rpm_list.out $SCRIPTPATH/.cgrep;fi
          if [ -f $SCRIPTPATH/vm_rpm_list.out ]; then cp  $SCRIPTPATH/vm_rpm_list.out $SCRIPTPATH/.cgrep;fi
          if [ $upgrade_mode -gt 0 ]
          then
              echo -e "${RED}Checking upgrade best practices are not yet supported by ${program_name} for Oracle database appliance${NORM}"
              exit 1
          fi 
          if [ $TYP = "-p" ]
          then
              echo -e "${RED}Patch recommendations are not yet supported by ${program_name} for Oracle database appliance${NORM}"
              exit 1
          fi 
          if [ $upgrade_mode -eq 2 ]
          then
              components=$(echo ${components}:PREUPGR)
          elif [ $upgrade_mode -eq 3 ]
          then
              components=$(echo ${components}:POSTUPGR)
          fi
      else
	  oda_machine=0
      fi 
      echo "ORACLE_DATABASE_APPLIANCE = $oda_machine">>$MASTERFIL   
  else
      oda_machine=$(grep -w "ORACLE_DATABASE_APPLIANCE" $DUMPDIR/$CHKFIL|awk '{print $3}')
      if [[ -n "$oda_machine" && $oda_machine -eq 1 ]];then 
        it_is_rac=0; 
        ORANGE="\033[35;40m"; 
      fi
  fi
}
#-- done creating tmp dir
copy_em_xml_files_to_remote_nodes ()
{
  old_IFS=$IFS
  unset IFS
 EMSSHELL=$(echo $SSHELL|sed 's/ -q//g')
 EMSCOPY=$(echo $SCOPY|sed 's/ -q//g')
 if [[ -n "$RAT_OUTPUT" && -n "$RAT_COPY_EM_XML_FILES" && $RAT_COPY_EM_XML_FILES -eq 1 ]]
 then
     for racNodeName in `cat $HOSTLIST`
     do
        BASEXMLREPFIL=$(basename $XMLREPFIL)
        BASEXMLSKIPFIL=$(basename $XMLSKIPFIL) 
        if [ $racNodeName = $localnode ]
        then
            if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} ];then mv $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL}_${FDS} >/dev/null 2>&1;fi
            if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} ];then mv $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}_${FDS} >/dev/null 2>&1;fi
            cp $XMLREPFIL $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} >/dev/null 2>&1
            cp $XMLSKIPFIL $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}  >/dev/null 2>&1
        else
           $EMSSHELL $usern@$racNodeName "if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} ];then mv $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLREPFIL}_${FDS} >/dev/null 2>&1;fi" >/dev/null 2>&1
           $EMSSHELL $usern@$racNodeName "if [ -e $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} ];then mv $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL} $RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}_${FDS} >/dev/null 2>&1;fi" >/dev/null 2>&1
           $EMSSHELL $usern@$racNodeName "ls -l $RAT_OUTPUT >/dev/null 2>&1" >/dev/null 2>&1
           ratOutputExists=$(echo $?)
           if [ $ratOutputExists -eq 0 ]
           then
               $EMSCOPY $XMLREPFIL $usern@$racNodeName:$RAT_OUTPUT/${localnode}_${BASEXMLREPFIL} >/dev/null 2>&1 
               $EMSCOPY $XMLSKIPFIL $usern@$racNodeName:$RAT_OUTPUT/${localnode}_${BASEXMLSKIPFIL}  >/dev/null 2>&1
           else
               echo "$RAT_OUTPUT does not exists on $racNodeName so can not copy $XMLREPFIL and $XMLSKIPFIL" >>$LOGFIL
           fi       
        fi
     done
 else
     echo "RAT_OUTPUT is not set or RAT_COPY_EM_XML_FILES is not set to 1 so can not copy xml files to remote compute nodes" >>$LOGFIL
 fi
  IFS=$old_IFS
}

# Added this function to not to check MAA score card if no database was chosen or no database was running on cluster
check_maa_scorecard ()
{
 if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
 then 
    maa_scorecard=0
 elif [[ -n "$upgrade_mode" && $upgrade_mode -eq 2 ]]
 then
     maa_scorecard=0
 else
    if [ ${#mb_db_names[@]} -gt 0 ]
    then
        maa_scorecard=1
    else
        maa_scorecard=0
    fi
 fi  
 #if [ "$TYP" = "-m" ]; then skip_maa_scorecard=1;else skip_maa_scorecard=0;fi  
}


check_hacheck ()
{
 if [[ -n "$db_name_to_check_none" &&  $db_name_to_check_none -eq 1 ]]
 then 
    include_hacheck=0
 elif [[ -n "$upgrade_mode" && $upgrade_mode -gt 0 ]]
 then
     include_hacheck=0
 else
    if [ ${#mb_db_names[@]} -gt 0 ]
    then
        include_hacheck=1
    else
        include_hacheck=0
    fi
 fi   
 #if [ "$TYP" = "-r" ]; then skip_hacheck=1;else skip_hacheck=0;fi  
}

###########################################################
# Test if this is an Exalogic compute node
# Returns 1 if it's Exalogic, 0 otherwise
###########################################################

check_if_exalogic()
{
  EMOC_FILE=/usr/lib/init-exalogic-node/.emoc_version
  is_exalogic_machine=0
  in_ec_exalogic=0
  if [[ -f "$EMOC_FILE" ]] ; then
    in_ec_exalogic=1
    is_exalogic_machine=1
  fi

  only_hacheck_run=0
  if [[ $is_exalogic_machine -eq "0" ]] ; then
    check_if_exalogic_physical;
  else
    set_exalogic_env;
  fi

  if [[ ! -f "exadiscover/exadiscover.sh" && $in_ec_exalogic -eq "1" ]] ; then
    echo -e "${RED}Error: exadiscover does not exists.. exiting${NORM}";
    exit;
  fi
}

check_if_exalogic_physical()
{
  IMAGE_ID_FILE=/usr/lib/init-exalogic-node/.image_id
  IMAGE_HISTORY_FILE=/var/log/init-exalogic-node/.image_history
  IMAGEINFO=/usr/sbin/imageinfo

  is_exalogic_machine=1
  if [ $is_exalytics_machine -eq 0 ]; then  RackIdentifier="";fi
  exalogic_version_actual="";
  exalogic_version_cn="";

    # Testing if /usr/lib/init-exalogic-node/.image_id file exists
    if [ ! -f ${IMAGE_ID_FILE} ] ; then
      #echo "ERROR: This is not an Exalogic compute node"
      is_exalogic_machine=0
    fi
    # Testing if /var/log/init-exalogic-node/.image_history file exists
    if [ ! -f ${IMAGE_HISTORY_FILE} ] ; then
      #echo "ERROR: This is not an Exalogic compute node"
      is_exalogic_machine=0
    fi

    dom0_node=0
    if grep -q "control_d" /proc/xen/capabilities > /dev/null 2>&1
    then
      dom0_node=1
    fi

    localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1`
    if [[ $is_exalogic_machine -eq "1" && $in_ec_exalogic -eq "0" && $dom0_node -eq "1" ]] ; then
      printf "$localnode is an Oracle Virtual Server Node. It is recommended to run ${program_name} from Enterprise Controller Node. Do you want to continue running on this node [y|n] [n] :"
      read ans;
      case "$ans" in 
      Y|y)
        echo "Running ${program_name} on $localnode";;
        #in_ec_exalogic=1;;
        *)
        echo "Exiting.."; exit;;
       esac
    fi

    if [ $is_exalogic_machine -eq 1 ]
    then
      set_exalogic_env;
    fi
}

function set_exalogic_env ()
{
  html_rack_type="System"
  it_is_rac=0
  if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
    #RackIdentifier=$(grep rack_name $EOUT | cut -d= -f2 | awk '{print $NF}')
    RackIdentifier=""
  else
    #checking for existance of binary to support solaris because ipmitool does not exists there
    if [ `uname -s` = "Linux" ]; then IPMITOOL="/usr/bin/ipmitool";elif [ `uname -s` = "SunOS" ]; then IPMITOOL="/opt/ipmitool/bin/ipmitool";fi
    if [ -e $IPMITOOL ]; then RackIdentifier=$($IPMITOOL sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}');fi
    #RackIdentifier=$(ipmitool sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}')
  fi

  if [ -n "$RAT_DB" ]
  then
    exalogic_version_actual=$RAT_DB
  elif [ -e "$IMAGEINFO" ]
  then
    exalogic_version_actual=$($IMAGEINFO|grep -iw "image version"|cut -d':' -f2|cut -d' ' -f2)
  elif [ -e "/usr/lib/init-exalogic-node/.emoc_version" ]
  then
    exalogic_version_actual=$(cat /usr/lib/init-exalogic-node/.emoc_version | cut -d= -f2 | sed "s/'//g")
  else
    echo -e "${RED} ${program_name} did not find Exalogic version from environment. Please set RAT_DB like RAT_DB=1.0.0.2 and run $program_name again${NORM}"
    exit 1
  fi

  #if [[ -n "$exalogic_version" && $exalogic_version -eq 20100 ]]; then components=$(echo ${components}:EXALOGIC_VM);else components=$(echo ${components}:EXALOGIC);fi 
  exalogic_version=$(echo $exalogic_version_actual |tr -d '.')
  if [ -n "$exalogic_version" ]; then exalogic_version=10020;fi

  if [ $upgrade_mode -gt 0 ]
  then
    echo -e "${RED}Checking upgrade best practices are not supported by ${program_name} for Exalogic${NORM}"
    exit 1
  fi

  if [ $TYP = "-p" ]
  then
    echo -e "${RED}Patch recommendations are not supported by ${program_name} for Exalogic${NORM}"
    exit 1
  fi 

}

node_pingable ()
{
  nodename="$1"
  ping -c 1 $nodename >/dev/null 2>&1
  if [ $? -eq "0" ]
  then
    pingable=1
  else
    pingable=0
  fi
}

test_node_reachability()
{
  nodename="${n_prefix}";
  ping -c 1 $nodename >/dev/null 2>&1
  if [ $? -eq "0" ]
  then
    el_node_ping=1
  else
    echo "Error: Host $nodename is not reachable. '$n_prefix' is wrong";
  fi
}

#Commented old way to decide either its physical or logical Rack and coverted it to function which will be called for each remote node to support hybrid rack
assign_exalogic_module ()
{
  if [[ $OFFLINE -eq 0 || $RAT_RUNMODE_INTERNAL = "slave" ]]
  then
    el_prefix="";
    case $1 in
      $ea_db_node)
        el_prefix="_DB";;
      $ea_ec1_node)
        el_prefix="_EC";;
      $ea_ovmm_node)
        el_prefix="_OVMM";;
      "$ea_pc1_node"|"$ea_pc2_node")
        el_prefix="_PC";;
      *)
        el_prefix="";;
    esac
    if [[ -n "$el_prefix" ]] ; then
      if [ `echo $components|grep -c ":"` -eq 0 ]
      then
        components=$(echo ${components}:EXALOGIC$el_prefix)
      else
        components=$(echo $components|$AWK -F":" 'sub($NF"$","")')
        components=$(echo ${components}EXALOGIC$el_prefix)  
      fi
    else
      if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" && -z "$exalogic_version_actual_cn" ]] ; then
        if [[  $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
          exalogic_version_actual_cn=$(/usr/sbin/imageinfo 2>/dev/null |grep -iw "image version"|cut -d':' -f2|cut -d' ' -f2)
        else
          exalogic_version_actual_cn=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $1 "/usr/sbin/imageinfo 2>/dev/null |grep -iw \"image version\"|cut -d':' -f2|cut -d' ' -f2")
        fi

        echo "EXALOGIC_ACTUAL_VERSION_CN = $exalogic_version_actual_cn" >>$MASTERFIL
      fi
      if [[  $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
        remote_node_component_check=$(ls -ld /proc/xen >/dev/null 2>&1;echo $?)
      else
        remote_node_component_check=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $1 "ls -ld /proc/xen" >/dev/null 2>&1;echo $?)
      fi
      if [ $remote_node_component_check -eq 0 ]
      then
          if [ `echo $components|grep -c ":"` -eq 0 ]
          then
              components=$(echo ${components}:EXALOGIC_VM)
          else
              components=$(echo $components|$AWK -F":" 'sub($NF"$","")')
              components=$(echo ${components}EXALOGIC_VM)  
          fi
      else
          if [ `echo $components|grep -c ":"` -eq 0 ]
          then
              components=$(echo ${components}:EXALOGIC)
          else
              components=$(echo $components|$AWK -F":" 'sub($NF"$","")')
              components=$(echo ${components}EXALOGIC)  
          fi
      fi
    fi
    echo "$1.COMPONENT = $components">>$MASTERFIL
  else
      components=$(grep "$i.COMPONENT" $DUMPDIR/$CHKFIL |awk '{print $3}') 
  fi 
       #if [[ -n "$exalogic_version" && $exalogic_version -eq 20100 ]]; then components=$(echo ${components}:EXALOGIC_VM);else components=$(echo ${components}:EXALOGIC);fi 
}

generate_exalogic_node_info_from_exadiscover ()
{
  # More info about exadiscover here
  # https://stbeehive.oracle.com/teamcollab/wiki/Exalogic+Health+Check:Exacheck%27s+Integration+with+ExaDiscover
  # https://stbeehive.oracle.com/teamcollab/wiki/Exalogic+Diagnostics:ExaDiscover

  EOUT=$WRKDIR/exadiscover.out
  EAOUT=$WRKDIR/exachk_exalogic.conf

  from_exadiscover=1
  #if [[ ! -f "$EOUT" ]] ; then
    #sh exadiscover/exadiscover.sh -f shell | grep rack_ > $EAOUT
  #fi

  if [[ ! -f "$EAOUT" ]] ; then
    sh exadiscover/exadiscover.sh -f shell | grep rack_ > $EAOUT
    sh exadiscover/exadiscover.sh -f shell -a >> $EAOUT
    cp -f $EAOUT $WRKDIR/.cgrep/
  else
    echo "Using cached file $EAOUT ...."
  fi
  
  if [[ -e "$EAOUT" ]] ; then
    cp -f $EAOUT $OUTPUTDIR 2>/dev/null
  fi

  # Get the racktype
  rtype=$(grep rack_size $EAOUT | cut -d= -f2)
  case "$rtype" in 
    "Full")
      exalogic_rack=3;;
    "Half")
      exalogic_rack=2;;
    "Quarter")
      exalogic_rack=1;;
    "Eighth")
      exalogic_rack=0;;
    *)
      exalogic_rack=3;;
  esac
  RackIdentifier=$(grep "rack_id_01=" $EAOUT | cut -d= -f2 | head -1|awk '{print $NF}')

  ea_need_vm=1
  if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_cvm_only -eq "1" ]] ; then
    ea_need_vm=0
  fi

  if [[ $ea_need_vm -eq "1" ]] ; then
    grep "c_nodes_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 > $WRKDIR/o_host_list.out
  fi

  ea_db_node=$(grep "db_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  echo "$ea_db_node" >> $WRKDIR/o_host_list.out

  ea_ec1_node=$(grep "ec_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  ea_ec1_node=$localnode
  echo "$ea_ec1_node" >> $WRKDIR/o_host_list.out

  ea_ovmm_node=$(grep "ovmm_[0-9]*_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  echo $ea_ovmm_node >> $WRKDIR/o_host_list.out
  ea_pc1_node=$(grep "pc_01_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  if [[ -n "$ea_pc1_node" ]] ; then
    echo $ea_pc1_node >> $WRKDIR/o_host_list.out
  fi
  ea_pc2_node=$(grep "pc_02_IPoIB-admin=" $EAOUT  | cut -d= -f2 | head -1)
  if [[ -n "$ea_pc2_node" ]] ; then
    echo $ea_pc2_node >> $WRKDIR/o_host_list.out
  fi

  rack_id=$(grep "rack_id_01=" $EAOUT  | cut -d= -f2 | head -1)

  #grep "sn_nodes_[0-9]*.*-eth-admin=" $EAOUT | cut -d= -f2 | sed 's/,/\n/g' |sort -u> $WRKDIR/o_storage.out
  rm -f $WRKDIR/o_storage.out
  for snip in `grep "sn_nodes_[0-9]*.*-eth-admin=" $EAOUT | cut -d= -f2 | sed 's/,/\n/g' |sort -u`
  do
    sname=$(nslookup $snip |grep name|awk '{print $NF}'|sed 's/.$//')
    if [[ -z "$sname" ]] ; then
      sname="$snip";
    fi
    echo "$sname" >> $WRKDIR/o_storage.out
  done

  rm -f $WRKDIR/o_ibswitches.out
  for switchip in `grep "ib_switch_[0-9]*_.*-eth-admin" $EAOUT | cut -d= -f2 |sort -u`
  do
    switchname=$(nslookup $switchip|grep name|awk '{print $NF}'|sed 's/.$//')
    if [[ -z "$switchname" ]] ; then
      switchname=$switchip
    fi
    echo "$switchname" >> $WRKDIR/o_ibswitches.out
  done
  
}

generate_exalogic_node_info()
{
  #assign_exalogic_module
  if [ $OFFLINE -eq "0" ]
  then
    from_exadiscover=0
    if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
      generate_exalogic_node_info_from_exadiscover;
    else
      el_cfile="/usr/lib/init-exalogic-node/exalogic_machine.conf"
      if [ -z "$RAT_ELRACKTYPE" ] ;  # 3=FULL, 2=HALF, 1=QUARTER 0=1/8
      then 
        if [ -r "$el_cfile" ]
        then
          exalogic_rack=$(grep "RACK_TYPE=" $el_cfile | cut -d"=" -f2)
        fi
        if [ -z "$exalogic_rack" ]
        then
          echo "Unable to determine rack type. Please set RAT_ELRACKTYPE and try again"
          exit;
        fi
      else 
        exalogic_rack="$RAT_ELRACKTYPE";
      fi;
    fi;

    cnlist_file="$OUTPUTDIR/o_host_list.out"
    snlist_file="$OUTPUTDIR/o_storage.out"
    swlist_file="$OUTPUTDIR/o_ibswitches.out"
    HOSTLIST=$cnlist_file

# To generate list of compute nodes
    if [ -n "$RAT_CLUSTERNODES" ]  # First check for env
    then
      rm -f $HOSTLIST
      for nodename in `echo $RAT_CLUSTERNODES`
      do
        echo $nodename>>$cnlist_file
      done
    elif [[ -r "$WRKDIR/o_host_list.out" && -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]]
    then # Use cached nodes list from previous run
       if [[ $from_exadiscover -eq "0" ]] ; then
          echo -e "Using cached file $WRKDIR/o_host_list.out for nodes list ....\n\n";
       fi
          cp $WRKDIR/o_host_list.out $cnlist_file
    elif [[ -n "$RAT_EXALOGIC_CONF" || -e "exalogic_deploy.conf" ]]
        then # Read the conf file
        rm -f $cnlist_file $snlist_file $swlist_file
        generate_exalogic_node_info_from_conf;
    else
       # Compute nodes
      case $exalogic_rack in
      3) #FULL
        cn_cnt=30
        sw_cnt=4
        EXALOGIC_RACK=FULL
        ;;
      2) #HALF
        cn_cnt=16
        sw_cnt=2
        EXALOGIC_RACK=HALF
        ;;
      1) #QUARTER
        cn_cnt=8
        sw_cnt=2
        EXALOGIC_RACK=QUARTER
        ;;
      0) #1/8 rack
        cn_cnt=4
        sw_cnt=2
        EXALOGIC_RACK="1/8"
        ;;
      *)
        echo "Invalid value for RACK '$exalogic_rack'";
        exit 1;
        ;;
      esac

      n_prefix=$(hostname|cut -d. -f1|sed 's/[0-9][0-9]$//');
      n_cnt=0;
      while [[ $n_cnt -lt $cn_cnt ]]
      do
        n_cnt=$(expr $n_cnt + 1);
        nodename=$(printf "${n_prefix}%02d" $n_cnt);
        echo "$nodename" >> $cnlist_file
      done
    fi
    if [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]]
    then
    # To generate list of infinband switchces to test
	if [ -n "$RAT_IBSWITCHES" ]
	  then
	    for switchname in `echo $RAT_IBSWITCHES`
	    do
	      echo "$switchname">>$swlist_file
	    done
        elif [ -r "$WRKDIR/o_ibswitches.out" ]
	then # Use cached nodes list from previous run
          if [[ $from_exadiscover -eq "0" ]] ; then
	    echo -e "Using cached file $WRKDIR/o_ibswitches.out for gateway infiniband switches list....\n\n";
          fi
	    cp $WRKDIR/o_ibswitches.out $swlist_file
	elif [[ -n "$RAT_EXALOGIC_CONF" || -e "exalogic_deploy.conf" ]]
	then # Read the conf file
	    rm -f  $swlist_file 
	    generate_exalogic_node_info_from_conf;
	else
            unset n_prefix
	    el_done=0
	    while [ $el_done -lt 3 ] 
	    do
	      el_done=$(expr $el_done + 1)
	      read -p "Could not find infiniband gateway switch names from env or configuration file.Please enter the first gateway infiniband switch name : " n_prefix
	      el_node_ping=0
	      test_node_reachability;
	      if [ $el_node_ping -eq "1" ] ; then break; fi;
	    done
	    if [ $el_node_ping -eq "0" ]
	    then
	      echo "Failed to get infiniband gateway switch names. Skipping infiniband gateway switches.";
	      touch $swlist_file
	    else
		 n_prefix_sub=$(echo $n_prefix|sed s/.$//);  
		 n_prefix_sub=$(echo $n_prefix_sub|sed s/.$//);  
		 n_suffix=$(echo $n_prefix|sed 's/^.*\(..\)$/\1/');
		 n_suffix_counter=0
		 if [ $exalogic_rack -eq 3 ]
		 then 
		     while [ $n_suffix_counter -lt 4 ]
		     do 
		       if [ $n_suffix_counter -eq 0 ]
		       then
			   echo "${n_prefix_sub}${n_suffix}" >> $swlist_file
			   n_suffix=$( expr $n_suffix + 1 ) 
			   n_suffix_counter=$( expr $n_suffix_counter + 1 ) 
		       else
			   echo "${n_prefix_sub}0${n_suffix}" >> $swlist_file
			   n_suffix=$( expr $n_suffix + 1 ) 
			   n_suffix_counter=$( expr $n_suffix_counter + 1 ) 
			fi
		     done
		 else
		     while [ $n_suffix_counter -lt 2 ]
		     do 
			if [ $n_suffix_counter -eq 0 ]
		       then
			   echo "${n_prefix_sub}${n_suffix}" >> $swlist_file
			   n_suffix=$( expr $n_suffix + 1 )
			   n_suffix_counter=$( expr $n_suffix_counter + 1 )
		       else
			   echo "${n_prefix_sub}0${n_suffix}" >> $swlist_file
			   n_suffix=$( expr $n_suffix + 1 )
			   n_suffix_counter=$( expr $n_suffix_counter + 1 )
			fi 
		     done
		 fi
		 n_suffix_counter=0
            fi
            #/usr/sbin/ibswitches|egrep -wi 'IB|GW'|cut -d'"' -f2|awk '{print $6}'|grep -vw localhost|cut -d' ' -f1>$swlist_file
        fi # -n IBSWITCHES close here
    # To generate list of storage nodes   
	if [ -n "$RAT_ZFS_NODES" ]
	then
	    for cellname in `echo $RAT_ZFS_NODES`
	    do
	      echo "$cellname">>$snlist_file
	    done
	elif [ -r "$WRKDIR/o_storage.out" ]
	then # Use cached nodes list from previous run
          if [[ $from_exadiscover -eq "0" ]] ; then
	    echo -e "Using cached file $WRKDIR/o_storage.out for storage nodes list ....\n\n";
          fi
	  cp $WRKDIR/o_storage.out $snlist_file
	elif [[ -n "$RAT_EXALOGIC_CONF" || -e "exalogic_deploy.conf" ]]
	then # Read the conf file
	  rm -f  $snlist_file 
	  generate_exalogic_node_info_from_conf;
	else # Ask user
	  # Cells
          unset n_prefix
	  el_done=0
	  while [ $el_done -lt 3 ] 
	  do
	    el_done=$(expr $el_done + 1)
	    read -p "Could not find storage node names from env or configuration file.Please enter the first storage server : " n_prefix
	    el_node_ping=0
	    test_node_reachability;
	    if [ $el_node_ping -eq "1" ] ; then break; fi;
	  done
	  if [ $el_node_ping -eq "0" ]
	  then
	    echo "Failed to get storage node info. Skipping storage node.";
	    touch $snlist_file
	  else
            n_prefix=$(echo $n_prefix|sed s/.$//);  
	    echo "${n_prefix}1" > $snlist_file
	    echo "${n_prefix}2" >> $snlist_file
	  fi
	fi
    fi #NO_QUESTION if colses here
    validate_exalogic_rack;
    echo "IS_EXALOGIC_MACHINE = $is_exalogic_machine" >> $MASTERFIL
    echo "IS_EXALOGIC_EC_MACHINE = $in_ec_exalogic" >> $MASTERFIL
    echo "EXALOGIC_VERSION = $exalogic_version" >> $MASTERFIL
    echo "EXALOGIC_ACTUAL_VERSION = $exalogic_version_actual" >> $MASTERFIL
    echo "EXALOGIC_RACK = $exalogic_rack" >> $MASTERFIL
    echo "EXALOGIC_RACK_IDENTIFIER = $RackIdentifier" >> $MASTERFIL
    #echo "COMPONENTS = $components" >>$MASTERFIL
    if [ -e $snlist_file ]; then cp $snlist_file  $WRKDIR >/dev/null 2>&1;fi
    if [ -e $swlist_file ]; then cp $swlist_file  $WRKDIR >/dev/null 2>&1;fi
    #rm -f $WRKDIR/o_host_list.out $WRKDIR/o_storage.out $WRKDIR/o_ibswitches.out
  else
    is_exalogic_machine=`grep IS_EXALOGIC_MACHINE $MASTERFIL | awk '{print $3}'`
    in_ec_exalogic=`grep IS_EXALOGIC_EC_MACHINE $MASTERFIL | awk '{print $3}'`
    exalogic_version=`grep EXALOGIC_VERSION $MASTERFIL | awk '{print $3}'`
    exalogic_version_actual=`grep EXALOGIC_ACTUAL_VERSION $MASTERFIL | awk '{print $3}'`
    exalogic_rack=`grep EXALOGIC_RACK $MASTERFIL | awk '{print $3}'`
    RackIdentifier=`grep EXALOGIC_RACK_IDENTIFIER $MASTERFIL | sed 's/EXALOGIC_RACK_IDENTIFIER = //'`
  fi
  case $exalogic_rack in
      3) #FULL
        EXALOGIC_RACK=FULL
        ;;
      2) #HALF
        EXALOGIC_RACK=HALF
        ;;
      1) #QUARTER
        EXALOGIC_RACK=QUARTER
        ;;
      0) #1/8 rack
        EXALOGIC_RACK="1/8"
        ;;
      *) #1/8 rack
        EXALOGIC_RACK="FULL"
        ;;
  esac

  if [[ -n $go_next && $go_next = "e" ]] ; then exit; fi
}

######################################################
# This script generates the info for Exalogic node info in each of these output files respectively:
# 1. o_host_list.out = contains hostname of compute nodes
# 2. o_storage.out = contains hostname of ZFS storage
# 3. o_ibswitches.out = contains hostname of switches for IB nodes
######################################################
generate_exalogic_node_info_from_conf()
{
 #db_machine_compute=1
 if [ $OFFLINE -eq "0" ]
 then
  if [ -n "$RAT_EXALOGIC_CONF" ]
  then
    conf_file="$RAT_EXALOGIC_CONF"
  elif [ $# -eq 0 ] ; then
        conf_file="exalogic_deploy.conf"
  elif [ $# -eq 1 ] ; then
        conf_file=$1
  fi

  #echo "Parsing $conf_file"
  if [ ! -f $conf_file ] ; then
        echo "The exalogic config file doesn't exist. Set conf file location in env variable RAT_EXALOGIC_CONF and run again"
        exit 1
  fi

  if [ -e $cnlist_file -a -e $snlist_file -a -e $swlist_file ] ; then
        echo "Exalogic node info files already exist. Please refer to $cnlist_file, $swlist_file, and $snlist_file for more information"
        exit
  else

        rm -rf $cnlist_file
        rm -rf $swlist_file
        rm -rf $snlist_file
  fi

  ###########################
  # Retrieve the required info
  ##########################
  rackname=""
  sn_prefix=""
  cn_prefix=""
  # Storage node name prefix
  sn_prefix=`cat $conf_file | grep SNODE_PREFIX | cut -d ' ' -f 2`

  # Rackname
  rackname=`cat $conf_file | grep RACK_NAME | cut -d ' ' -f 2`

  # Compute node name prefix
  cn_prefix=`cat $conf_file | grep CNODE_PREFIX | cut -d ' ' -f 2`

  ####################################################
  # Generate o_host_list.out
  cat $conf_file | grep "$rackname$cn_prefix" | cut -f2 > $cnlist_file
#  cat $conf_file | grep "$rackname$cn_prefix" | cut -f2 > $cnlist_file

  ######################################################
  # Generate o_storage.out
  cat $conf_file | grep "$rackname$sn_prefix" | cut -f2 > $snlist_file

  ######################################################
  # Generate o_ibswitches.out
  cat $conf_file | grep swnode | cut -d " " -f 2 | cut -f2 > $swlist_file

  components=$(echo ${user_components}:EXALOGIC)

  #echo "$cnlist_file, $snlist_file, and $swlist_file generated successfully"
  #echo "IS_EXALOGIC_MACHINE = $is_exalogic_machine" >> $MASTERFIL
  #echo "EXALOGIC_VERSION = $exalogic_version" >> $MASTERFIL
 else
  is_exalogic_machine=`grep IS_EXALOGIC_MACHINE $MASTERFIL | awk '{print $3}'`
  in_ec_exalogic=`grep IS_EXALOGIC_EC_MACHINE $MASTERFIL | awk '{print $3}'`
  exalogic_version=`grep EXALOGIC_VERSION $MASTERFIL | awk '{print $3}'`
  exalogic_version_actual=`grep EXALOGIC_ACTUAL_VERSION $MASTERFIL | awk '{print $3}'`
  RackIdentifier=`grep EXALOGIC_RACK_IDENTIFIER $MASTERFIL | sed 's/EXALOGIC_RACK_IDENTIFIER = //'`
  #echo "Offline mode"
 fi
}
validate_exalogic_rack()
{
  if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then return; fi;
 no_of_switches=$(cat $swlist_file|wc -l)
 no_of_compute_nodes=$(cat $cnlist_file|wc -l)
 #if [[ $no_of_switches -gt 2 && $no_of_compute_nodes -lt 30 ]]
 if [[ $no_of_switches -gt 2 && $no_of_compute_nodes -lt 30 && -z "$RAT_CLUSTERNODES" && -z "$RAT_IBSWITCHES" && -z "$RAT_ELRACKTYPE" ]]
 then
     echo -e "${RED}${program_name} could not determine rack type like full or half from environment. please set RAT_ELRACKTYPE to specify rack type as following.\n${NORM}"
     echo -e "If full rack then set RAT_ELRACKTYPE to 3\nIf half rack then set RAT_ELRACKTYPE to 2\nif quarter rack then set RAT_ELRACKTYPE to 1\nif 1/8 rack then set RAT_ELRACKTYPE to 0"
     rm -f $HOSTLIST # gadiga avoid cleanup and ssh password prompts for each host
     exit 1
 fi  
}


function check_in_profiles ()
{
  in_profile=0
  for aprofile in $profileids2run
  do
    if [[ `grep -ic "$CHECK_ID" "$SCRIPTPATH/.cgrep/profiles/$aprofile.prf"` -gt "0" ]] ; then
      in_profile=1
      return;
    fi
  done
}

function check_in_targetversion ()
{
  in_profile=0
  if [[ `grep -ic "$CHECK_ID" "$targetVesionCheckFil"` -gt "0" ]] 
   then
      in_profile=1
      return;
  fi
}


assign_stack_status ()
{
  db_status_counter=0
  dbinst_up=0
  asminst_up=0

  if [ $OFFLINE -eq 0  ]
  then
    chk_fname=$MASTERFIL
  else
    chk_fname=$DUMPDIR/$CHKFIL
  fi

#echo "========================================================================="
#echo
  for db_name_to_check in "${mb_db_names[@]}"
  do
    if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
      stack_db_status[$db_status_counter]=`grep -i "${db_name_to_check}.INSTANCE_MODE"  $chk_fname |awk '{print $3}' |sort -n |tail -1`
    else
      stack_db_status[$db_status_counter]=`grep -i "$i.${db_name_to_check}.INSTANCE_MODE"  $chk_fname |awk '{print $3}'`
    fi
    if [ -z "${stack_db_status[$db_status_counter]}" ] ; then
      stack_db_status[$db_status_counter]=0
    fi
    if [[ $dbinst_up -eq "0" && ${stack_db_status[$db_status_counter]} -gt "0" ]] ; then
      dbinst_up=${stack_db_status[$db_status_counter]}
    fi
#echo "db_status_counter=$db_status_counter, db_name_to_check=$db_name_to_check, stack_db_status=${stack_db_status[$db_status_counter]}, dbinst_up=$dbinst_up"
    db_status_counter=$(expr $db_status_counter + 1);
  done
  stack_dbinst_up[$stack_counter]=$dbinst_up
  if [ -z "${stack_db_status[0]}" ] ; then stack_db_status[0]=0; fi
  asminst_up=`grep -i "$i.ASM_STATUS"  $chk_fname |awk '{print $3}'`
  if [ -z "$asminst_up" ] ; then asminst_up=0; fi
  stack_asm_up[$stack_counter]=$asminst_up

#echo "stack_dbinst_up= ${stack_dbinst_up[$stack_counter]}"
#echo "========================================================================="
#echo
}

copy_utl_script_to_tmp ()
{
 # copy utility scripts to /tmp on all nodes so audit check can find it and execute it
    utlscrpcounter=0
    #for utlscrpt_full in `if [ -d $SCRIPTPATH/.cgrep ]; then ls -l $SCRIPTPATH/.cgrep/[a-z][!cgrep]*|awk '{print $NF}';fi`
    for utlscrpt_full in `if [ -d $SCRIPTPATH/.cgrep ]; then ls -l $SCRIPTPATH/.cgrep/ 2>/dev/null >&1|grep ^-|grep -v "grep"|awk '{print $NF}';fi`  
    do
      utlscrpt=$(basename $utlscrpt_full)
      for hname in `cat $HOSTLIST`
      do
         if  [ -e $SCRIPTPATH/.cgrep/${utlscrpt} ]
         then  
             if [ $hname = $localnode ]
             then
                 cp -f $SCRIPTPATH/.cgrep/${utlscrpt} /tmp  >/dev/null 2>&1  
                 if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "$ASREXACHK" ]; then chmod 755 /tmp/$ASREXACHK;fi
                 if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskFGMapping.sh" ]; then chmod 755 /tmp/checkDiskFGMapping.sh;fi
             else
                 $SCOPY $SCRIPTPATH/.cgrep/${utlscrpt}   $usern@$hname:/tmp >/dev/null 2>&1 
                 if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "$ASREXACHK" ]; then $SSHELL $usern@$hname "chmod 755 /tmp/$ASREXACHK";fi
                 if [ `basename $SCRIPTPATH/.cgrep/${utlscrpt}` = "checkDiskFGMapping.sh" ]; then $SSHELL $usern@$hname "chmod 755 /tmp/checkDiskFGMapping.sh";fi
             fi
         fi
         #read -p "stop for $SCRIPTPATH/.cgrep/$ASREXACHK"
      done
      a_utlscrpt[$utlscrpcounter]=$utlscrpt 
      utlscrpcounter=$(expr $utlscrpcounter + 1 )
    done
    utlscrpcounter=0 
}

add_maa_scorecard ()
{
  if [[ -n "$skip_maa_scorecard" && $skip_maa_scorecard -eq 1  ]]
  then 
       if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]]
       then
	   components=$(echo ${components}|sed 's/:MAA//')
       elif [ $single_instance_run -eq 1 ]
       then
           components=$(echo ${components}|sed 's/:SIDBMAA//')   
       else
	    components=$(echo ${components}:MAA)
       fi
       TYP=-a
  fi
  if [[ -n "$maa_scorecard" && $maa_scorecard -eq 0 ]]; then components=$(echo ${components}|sed 's/:MAA//');components=$(echo ${components}|sed 's/:SIDBMAA//'); fi
}

add_hacheck ()
{
  if [[ -n "$skip_hacheck" && $skip_hacheck -eq 1  ]] 
  then 
       #if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]]
       if [[ -n "$it_is_rac" && $it_is_rac -eq 1 ]] || [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
       then
	   components=$(echo ${components}:HACHECK)
	   #components=$(echo ${components}|sed 's/:HACHECK//')
       elif [ $single_instance_run -eq 1 ]
       then
	   components=$(echo ${components}:SIDBHACHECK)
	   #components=$(echo ${components}|sed 's/:SIDBHACHECK//')
       #else
	    #components=$(echo ${components}:HACHECK)
       fi
       TYP=-a
  fi
  if [[ -n "$include_hacheck" && $include_hacheck -eq 0 ]]
  then 
       if [ $single_instance_run -eq 1 ]
       then
           components=$(echo ${components}|sed 's/:SIDBHACHECK//')
       else
           components=$(echo ${components}|sed 's/:HACHECK//')
       fi
  fi
}

match_database_role ()
{
  dbrole_match_count=0
  dbrole_match_count=$(echo $check_database_role|grep -icw $1)
}
match_database_type ()
{
  dbtype_match_count=0
  dbtype_match_count=$(echo $check_database_type|grep -icw $1)
}

compare_reports ()
{

  perl_exe=$(which perl)
  if [ -z "$perl_exe" ] ; then
    echo -e "${RED}This feature requires Perl command. If its installed, please set PATH and try again, else please install perl and try again.${NORM}";
    usage;
  fi

  args=$(echo $* | sed 's/.*-diff//');
  if [ -z "$args" ] ; then 
    echo -e "${RED}Missing arguments${NORM}";
    usage; 
  fi

  report1=$(echo $args | awk '{print $1}');
  report2=$(echo $args | awk '{print $2}');
  if [ -z "$report3" ] ; then
    report3=$(echo $args | awk '{print $3}');
    if [[ -n "$report3" && $report3 = "-outfile" ]] ; then
      report3=$(echo $args | awk '{print $4}');
    fi
  fi

  if [[ -z "$report1" || -z "$report2" ]] ; then
    echo -e "${RED}This command requires two arguments.${NORM}";
    usage; 
  fi

  remove_report1=0
  remove_report2=0
  if [ `echo $report1 | grep -ic '\.zip$'` -gt "0" ] ; then
    zip_base=$(echo $report1 | sed 's/\.zip//');
    unzip $report1 $zip_base/$zip_base.html -d /tmp >/dev/null 2>&1
    if [ -e "/tmp/$zip_base/$zip_base.html" ] ; then
      report1=/tmp/$zip_base/$zip_base.html
      remove_report1=1
      report1_dir="/tmp/$zip_base/"
      report1_file="$zip_base.html"
    else
      echo -e "${RED}Error while unzipping $report1.. exiting${NORM}";
    fi
  fi

  if [ `echo $report2 | grep -ic '\.zip$'` -gt "0" ] ; then
    zip_base=$(echo $report2 | sed 's/\.zip//');
    unzip $report2 $zip_base/$zip_base.html -d /tmp >/dev/null 2>&1
    if [ -e "/tmp/$zip_base/$zip_base.html" ] ; then
      report2=/tmp/$zip_base/$zip_base.html
      remove_report2=1
      report2_dir="/tmp/$zip_base/"
      report2_file="$zip_base.html"
    else
      echo -e "${RED}Error while unzipping $report2.. exiting${NORM}";
    fi
  fi

  $perl_exe $SCRIPTPATH/.cgrep/diff_collections.pl $report1 $report2 $report3

  if [[ $remove_report1 -eq "1" && -d "$report1_dir" ]] ; then
    rm -f $report1_dir/$report1_file
    rmdir $report1_dir
  fi
  if [[ $remove_report2 -eq "1" && -d "$report2_dir" ]] ; then
    rm -f $report2_dir/$report2_file
    rmdir $report2_dir
  fi
}

check_if_exalytics()
{
  IMAGE_ID_FILE=/usr/lib/init-exalogic-node/.image_id
  IMAGE_HISTORY_FILE=/var/log/init-exalogic-node/.image_history
  IMAGEINFO=/usr/sbin/imageinfo
  is_exalytics_machine=1
  RackIdentifier="";
  exalytic_version_actual="";
  exalytic_version_cn="";
  ipmi_system_identifier=$(/usr/bin/ipmitool sunoem cli force 2>/dev/null "show /SP system_identifier")
  ipmi_system_identifier_exalytics=$(echo $ipmi_system_identifier|grep "system_identifier"|grep -cwi "exalytics")
  if [[ -n "$ipmi_system_identifier_exalytics" && "$ipmi_system_identifier_exalytics"  -eq 0 ]]; then is_exalytics_machine=0;fi
  dom0_node=0
  if grep -q "control_d" /proc/xen/capabilities > /dev/null 2>&1
  then
    dom0_node=1
  fi
  localnode=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1`
  if [ $is_exalytics_machine -eq 1 ]
  then
    set_exalytics_env  
  fi
}

function set_exalytics_env ()
{
  html_rack_type="System"
  it_is_rac=0
  #checking for existance of binary to support solaris because ipmitool does not exists there
  if [ -e /usr/bin/ipmitool ]; then RackIdentifier=$(/usr/bin/ipmitool sunoem cli force "show /SP system_identifier"|grep "system_identifier "|awk '{print $NF}');fi
  if [ -n "$RAT_DB" ]
  then
    exalytics_version_actual=$RAT_DB
  elif [ -e "$IMAGEINFO" ]
  then
    exalytics_version_actual=$($IMAGEINFO|grep -iw "image version"|cut -d':' -f2|cut -d' ' -f2)
  elif [ -e "/usr/lib/init-exalogic-node/.emoc_version" ]
  then
    exalytics_version_actual=$(cat /usr/lib/init-exalogic-node/.emoc_version | cut -d= -f2 | sed "s/'//g")
  else
    echo -e "${RED} ${program_name} did not find Exalytics version from environment. Please set RAT_DB like RAT_DB=1.0.0.5 and run $program_name again${NORM}"
    exit 1
  fi
  exalytics_version=$(echo $exalytics_version_actual |tr -d '.')
  components=$(echo ${components}:EXALYTICS)
  if [ $upgrade_mode -gt 0 ]
  then
    echo -e "${RED}Checking upgrade best practices are not supported by ${program_name} for Exalytics ${NORM}"
    exit 1
  fi

  if [ $TYP = "-p" ]
  then
    echo -e "${RED}Patch recommendations are not supported by ${program_name} for Exalytics ${NORM}"
    exit 1
  fi

  if [ $exalytics_version  -lt 10050 ]
  then
    echo -e "${RED}\n\n${program_name} is not supported on Exalytics version $exalytics_version_actual ${NORM}\n\n"
    exit 1
  fi
}
function generate_exalytics_node_info ()
{
  echo $localnode>$OUTPUTDIR/o_host_list.out
  echo "$localnode.COMPONENT = $components">>$MASTERFIL 
  echo "EXALYTICS_VERSION = $exalytics_version" >>$MASTERFIL
  echo "EXALYTICS_VERSION_ACTUAL = $exalytics_version_actual" >>$MASTERFIL
  echo "IS_EXALYTICS_MACHINE = $is_exalytics_machine" >>$MASTERFIL
  echo "EXALYTICS_RACK_IDENTIFIER = $RackIdentifier" >> $MASTERFIL 
  rdbms_installed[0]=0
  set_exalytics_bi_env
  read_exalytics_bi_env
}

function set_exalytics_bi_env ()
{

  if [ -e /etc/oraInst.loc ]
  then
      if [ -z "$RAT_BI_HOMES" ]
      then
          echo -e "${RED}\n$program_name found OBIEE installation and RAT_BI_HOMES environment variable is not set.\n${NORM}"
          echo -e "${RED}\nset RAT_BI_HOMES environment variable to comma separated list of BI homes installed on this system and re-run $program_name.\n${NORM}"
          echo -e "${RED}\nlike export RAT_BI_HOMES=\"/u01/oracle/BIMachine,/u02/oracle/BIMachine\"\n${NORM}"
          exit 1
      else      
          log_env_varaibles "RAT_BI_HOMES" "$RAT_BI_HOMES" "1"
          for mb_db_home in $RAT_BI_HOMES
          do
           if [ -e "$mb_db_home/instances" ] 
           then 
               echo $mb_db_home >>$OUTPUTDIR/mb_db_homes_distinct.out
           else
               echo -e "\n${RED} ${mb_db_home} is not valid path for OBIEE home so skipping for checking best practices\n${NORM}"|tee -a $LOGFIL 
           fi 
          done
      fi
  fi
}
function read_exalytics_bi_env ()
{
 mb_db_counter=0
 for mb_db_home in `if [ -e $OUTPUTDIR/mb_db_homes_distinct.out ]; then cat $OUTPUTDIR/mb_db_homes_distinct.out|sort -u;fi;`
 do
   rdbms_installed[0]=1
   mb_oracle_homes_distinct[$mb_db_counter]=$mb_db_home
   mb_db_counter=$(expr $mb_db_counter + 1)
 done 
 if [ $OFFLINE -eq 0 ]; then echo "$localnode.RDBMS_INSTALLED = ${rdbms_installed[0]}">> $MASTERFIL;fi   
 multiple_oracle_homes=$mb_db_counter
 mb_db_counter=0
}

function discover_ssc_zfs_nodes ()
{
 if [ -n "$RAT_ZFS_NODES" ]
 then
    for zfsname in `echo $RAT_ZFS_NODES`
    do
       echo "$zfsname">>$OUTPUTDIR/zfsip.ora
    done
    ZFSIP=$OUTPUTDIR/zfsip.ora
 else
     ssc_zfs_appliances=$(cat /etc/hosts|grep sn[1-2]|grep -v ilom|awk '{print $1}'|sed 's/#//g')
    for zfsname in `echo $ssc_zfs_appliances`
    do
       echo "$zfsname">>$OUTPUTDIR/zfsip.ora
    done
    ZFSIP=$OUTPUTDIR/zfsip.ora
 fi
}

function execute_zfs_collection ()
{
 if  [[ $OFFLINE -eq 0 && $zfs_password_status -ne 3 ]]
 then
     if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
     if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $1 ]]  
     then
	 #cat $IBSWITCHSCRPT
	 #read -p "good to run"
	 if [ ! -e $CELLDIR ];then mkdir $CELLDIR >/dev/null 2>&1;fi
	 cp $1 $CELLDIR 2>/dev/null 2>&1

	 root_zfs_counter=0
	 no_of_cells=$(wc -l $1 |awk '{print $1}')
	 no_of_cells=$(expr $no_of_cells - 1);
	 in_last_cell=0
	 if [[ ! -n "$RAT_ZFS_RUNMODE" ]] ; then RAT_ZFS_RUNMODE="parallel"; fi;
	 for cellname in `cat $1|cut -d= -f2|sed 's/"//g'` 
	 do
	   cellPingStatus=$($PING -c 1 $PING_W_FLAG $cellname >/dev/null 2>&1;echo $?)
	   if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
	   then
	       noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $cellname)
	       if [[ $no_of_cells -eq $root_zfs_counter ]] ; then in_last_cell=1; fi
	       cell_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
	       if [ $noPasswordAvailable -eq 0 ]
	       then
		   if [[ -n "$RAT_ZFS_RUNMODE" && $RAT_ZFS_RUNMODE = "parallel" ]] ; then
		     echo -e "\nStarting to run $zfs_ssh_user privileged commands in background on ${BLINK}ZFS Storage Appliance${NORM} $cellname\n"
		   else
		     echo -e "\nPreparing to run $zfs_ssh_user privileged commands on ${BLINK}ZFS Storage Appliance${NORM} $cellname\n"
		   fi
		   if [[ -n "$zfs_samerootpassword" && $zfs_samerootpassword -eq 0 ]]
		   then 
		       zfs_rootpassword=${a_zfs_rootpassword[$root_zfs_counter]}
		   fi			      
		   cell_type="zfscell"
		   checkUserPassword "$cellname" "$zfs_ssh_user" "$zfs_rootpassword" "1"  "$cell_type"
		   if [[ $passwordCheckStatus -eq 0 ]]
		   then
		      #echo "Running on ZFS cell";
		      #echo "$cellname = $cellname" >>$CELLDIR/cells.out
		      rm -f $RTEMPDIR/zfscell.pid
		      cr_name=$RTEMPDIR/${program_name}_${cellname}_cells.sh
		      echo "#!/bin/env bash" > $cr_name
		      echo "echo \$\$ > $RTEMPDIR/zfscell.pid" >> $cr_name
		      echo "$SSHELL $zfs_ssh_user@$cellname  < $2 > $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out" >> $cr_name
		      chmod +x $cr_name

		      fixRootPassword "$zfs_rootpassword"	
		       /usr/bin/expect -f - << IBEOF &
		       set timeout $passwordcheck_timeout
		       set le_zfs_rootpassword "$fixedRootPassword"
		       log_user 0
		       if { "$RAT_EXPECT_DEBUG" == "-d" } {
			 exp_internal 1
		       }
		       spawn $cr_name
		       match_max 100000
			 expect {
		       "no)?" {
			     send -- "yes\n"
			     }
		      }
		     # Look for passwd prompt
		     expect "*?assword:*"
		    send -- "\$le_zfs_rootpassword\n"
		     set timeout $watchdog_wakeup_root
		     expect eof {
			    exit
			  } timeout {
			    send_error "Timed out while running collections on $cellname\n";
			    exit
			  }	
IBEOF
		     sleep 2 # Wait till pid file gets created
		     zcell_pid=$(cat $RTEMPDIR/zfscell.pid)
		     if [ -n "$zcell_pid" ]
		     then # wait till we finish collection running on cell
		       if [[ -n "$RAT_ZFS_RUNMODE" && $RAT_ZFS_RUNMODE = "parallel" ]] ; then
			 cell_pids[$zcell_pid]="$zcell_pid";
			 cell_pid_names[$zcell_pid]="$cellname"
			 cell_root_password[$zcell_pid]="$cell_rootpassword"
		       else
			 keep_looping=1
			 while [ $keep_looping -eq "1" ]
			 do
			   if [ `ps -ef | grep _cells.sh |grep -c $zcell_pid` -gt 0 ]
			   then
			     printf ". "
			   else
			     break
			   fi
			   sleep 2
			 done
		       fi
		     fi #end of if [ -n "$zcell_pid" ]
		   fi # end of if [[ $passwordCheckStatus -eq 0 ]] 
	       else
		   echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
	       fi #end of if [ $noPasswordAvailable -eq 0 ]
	       if [[ -e $CELLDIR/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
	       then
		   cat $CELLDIR/c_root_collect_timing.out >> $COLLECT_TIMING
		   rm -f $CELLDIR/c_root_collect_timing.out  >/dev/null 2>&1
	       fi
	   else 
	       echo -e "\n${RED}Skipping $zfs_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} because its not available.${NORM}\n"|tee -a $LOGFIL
	       add_to_skipped_nodes "${cellname}" "Storage Server is not available"
	   fi  #end of cellPingStatus
	   root_zfs_counter=$(expr $root_zfs_counter + 1)
	 done
	 if [[ -n "$RAT_ZFS_RUNMODE" && $RAT_ZFS_RUNMODE = "parallel" ]] ; then wait_for_cell_completion;fi
     fi
     #if [ -e $CELLDIR/cells.out ]; then cp $CELLDIR/cells.out $RTEMPDIR >/dev/null 2>&1;fi
     root_zfs_counter=0 
     echo -e "\n\n"
 fi 


}
#function to discover mixed hardware cells
mixed_hardware_cells_discovery ()
{
 #read -p "change files in $CELLDIR" 
 mixed_hardware=0
 if [ -e $CELLDIR ]; then  mixed_hardware=$(find $CELLDIR -name '*CellMakeModel*report.out' -exec md5sum {} \;|awk '{print $1}'|sort -u|wc -l);fi
 if [[ $mixed_hardware -gt 1 ]]
 then
      for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out)
      do
        mixed_hardware_v2=$(cat $mixedCellFil|grep -wci "SUN FIRE X4275")
        if [ $mixed_hardware_v2 -ge 1 ]; then break;fi
     done
      for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out)
      do
        mixed_hardware_x2_2=$(cat $mixedCellFil|grep -wci "SUN FIRE X4[1-2]70 M2")
        if [ $mixed_hardware_x2_2 -ge 1 ]; then break;fi
     done
      for mixedCellFil in $(ls $CELLDIR/*CellMakeModel*report.out)
      do
        mixed_hardware_x3_2=$(cat $mixedCellFil|grep -wci "SUN FIRE X4[1-2]70 M3")
        if [ $mixed_hardware_x3_2 -ge 1 ]; then break;fi
     done
 fi
 if [ $OFFLINE -eq 0 ]
 then
     echo -e "\nmixed hardware status = $mixed_hardware mixed_hardware_v2=$mixed_hardware_v2 mixed_hardware_x2_2=$mixed_hardware_x2_2 mixed_hardware_x3_2=$mixed_hardware_x3_2\n">>$LOGFIL
 fi
}

function set_root_all_prompt ()
{
  return
  if [ $userid -eq 0 ] ; then return; fi
  if [ -e "$EXPECT" ] ; then
    echo
    echo
    read -p  "Is root password same on all components?[y/n][y]" samerootpassword_YesNo
    if [ -z "$samerootpassword_YesNo" ] ; then samerootpassword_YesNo="y"; fi
    case $samerootpassword_YesNo in
    y|Y|Yes|YES|yes)
      echo -e "\n"
      printf  "Enter root password for components :- "
      stty -echo
      read -r global_root_password
      stty echo
      echo
      echo
      root_hostname=$(cat $HOSTLIST|head -1)
      checkUserPassword "$root_hostname" "root" "$global_root_password" "3"
      if [ $passwordCheckStatus -eq 0 ]
      then
        root_all_prompt=1
        global_root_password="$passwordToCheck"
      fi
    esac
  fi
}

function submit_client_run ()
{
  # Set all RAT_ env in client run
  rm -f $RTEMPDIR_D/setenv.sh
  env | grep RAT_ | grep -v RAT_EXPECT_DEBUG | grep -v RAT_EXPECT_STRACE_DEBUG  > $RTEMPDIR_D/rat_env.txt
  while read envs
  do
    e_key=$(echo $envs| cut -d"=" -f1)
    e_val=$(echo $envs| sed 's/[^=]*=//')
    echo "export $e_key=\"$e_val\"" >> $RTEMPDIR_D/setenv.sh
  done < $RTEMPDIR_D/rat_env.txt

  echo $argsaved > $RTEMPDIR_D/commands
  touch $RTEMPDIR_D/run.log

  keep_looping=0
  while [ $keep_looping -eq "1" ] ; do
    if [ -e "$LOCKFIL" ] ; then
      epid=$(cat $LOCKFIL)
      keep_looping=0
    fi
    if [ ! -e "$RTEMPDIR_D/run.log" ] ; then keep_looping=0; fi;
    if [ $keep_looping -eq "1" ] ; then sleep 1; fi
  done

  #kill -INT $dpid
  #if [ -n "$epid" ] ; then
    #tail --pid=$epid -f $RTEMPDIR_D/run.log
    mypid=$$
    echo $mypid > $RTEMPDIR_D/client.pid
    tail -f $RTEMPDIR_D/run.log 2>/dev/null
    if [ -e "$RTEMPDIR_D/run_error.log" ] ; then
      cat $RTEMPDIR_D/run_error.log; rm -f $RTEMPDIR_D/run_error.log
    fi
    # | while read line; do
      #if [[ `echo "$line" | grep -c "UPLOAD.if required"` -eq "0" ]] ; then
      #  echo "$line"
      #else
      #  echo "$line"
      #  exit
      #fi
    #done
  #fi
  exit;
}

function stop_daemon_actual ()
{
  dpid=$(cat $RTEMPDIR_D/daemon.pid)
  kill -15 $dpid
  stopped=0;
  while [[ $stopped -eq "0" ]] ; do
    if [[ `ps -ef | grep -w $dpid | grep -v grep | wc -l` -eq "0" ]] ; then
      stopped=1;
    else
      printf ". ";
      sleep 1;
    fi
  done

  rm -rf $RTEMPDIR_D

  echo
  echo
  echo "Stopped."
  echo
  log_daemon "Daemon is stopped on user request"
  exit;
}

function stop_daemon ()
{
  log_daemon "Stopping daemon as the $1 password is changed on $2 after daemon was started"
  send_email "${program_name} daemon was stopped" "Stopping daemon as the $1 password is changed on $2 after daemon was started. Please restart the daemon."
  touch $RTEMPDIR_D/stop
}

function set_date_vars ()
{
  t_yr=$(echo $1 | cut -d":" -f1)
  t_yr=$(expr $t_yr + 0)

  t_mm=$(echo $1 | cut -d":" -f2)
  t_mm=$(expr $t_mm + 0)

  t_dd=$(echo $1 | cut -d":" -f3)
  t_dd=$(expr $t_dd + 0)

  t_hh=$(echo $1 | cut -d":" -f4)
  t_hh=$(expr $t_hh + 0)

  t_mi=$(echo $1 | cut -d":" -f5)
  t_mi=$(expr $t_mi + 0)

  t_ss=$(echo $1 | cut -d":" -f6)
  t_ss=$(expr $t_ss + 0)
}

function next_autorun_on ()
{
  if [[ -f "$p_conf_file" && `grep -c "AUTORUN_INTERVAL" $p_conf_file` -gt "0" ]] ; then
    read_conf "AUTORUN_INTERVAL"
    if [[ $p_conf_value -eq "0" ]] ; then 
      echo
      echo -e "${RED}Auto run is not configured. Please use ${program_name} -set AUTORUN_INTERVAL=<n[h|d]> to enable auto run.${NORM}"
      echo
      return;
    fi
    auto_interval_in_mins=$(expr $p_conf_value \* 60)
    auto_interval_in_secs=$(expr $auto_interval_in_mins \* 60)
  else
    echo
    echo -e "${RED}Auto run is not configured. Please use ${program_name} -set AUTORUN_INTERVAL=<n[h|d]> to enable auto run.${NORM}"
    echo
    return
  fi

  if [ -z "$auto_interval_in_secs" ] ; then
    auto_interval_in_secs=86400 # Once every day
  fi

  get_dnow
  if [ -e "$RTEMPDIR_D/last_autorun_time" ] ; then
    dlast=$(cat $RTEMPDIR_D/last_autorun_time)
    set_date_vars $dnow
    epoch_now=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    set_date_vars $dlast
    epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    next_epoch=$(expr $epoch_last + $auto_interval_in_secs)

    echo
    perl -e 'use Time::Local; my @months = ("Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"); my ($sec, $min, $hour, $day,$month,$year) = (localtime('$next_epoch'))[0,1,2,3,4,5]; print "Next auto run starts on ".$months[$month]." ".$day.", ".($year+1900); print " ".$hour.":".$min.":".$sec."\n";';
    echo
    #diff_epoch=`expr $next_epoch - $epoch_now` # dif in seconds
    #diff_hr=$(expr $diff_epoch / 3600)
    #echo "Will start a new run in $diff_hr hours"
    #if [[ $diff_hr -gt "24" ]] ; then
    #  diff_day=$(expr $diff_hr / 24)
    #  echo "Will start a new run in $diff_day days"
    #fi
  fi
}

function start_auto_run ()
{
  if [ -e "$RTEMPDIR_D/commands" ] ; then return; fi

  if [[ -f "$p_conf_file" && `grep -c "AUTORUN_INTERVAL" $p_conf_file` -gt "0" ]] ; then
    read_conf "AUTORUN_INTERVAL"
    if [[ $p_conf_value -eq "0" ]] ; then return; fi
    auto_interval_in_mins=$(expr $p_conf_value \* 60)
    auto_interval_in_secs=$(expr $auto_interval_in_mins \* 60)
  else
    return
  fi

  if [ -z "$auto_interval_in_secs" ] ; then
    auto_interval_in_secs=86400 # Once every day
  fi

  get_dnow
  if [ -e "$RTEMPDIR_D/last_autorun_time" ] ; then
    dlast=$(cat $RTEMPDIR_D/last_autorun_time)
    set_date_vars $dnow
    epoch_now=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    set_date_vars $dlast
    epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    diff_epoch=`expr $epoch_now - $epoch_last`
#log_daemon "diff_epoch=$diff_epoch auto_interval_in_secs=$auto_interval_in_secs dnow=$dnow dlast=$dlast"
    if [ -z "$diff_epoch" ] ; then return; fi
    if [ $diff_epoch -lt $auto_interval_in_secs ] ; then
      return
    fi
  fi
  echo $dnow > $RTEMPDIR_D/last_autorun_time
  started_autorun=1
  read_conf "AUTORUN_FLAGS"
  if [ -n "$p_conf_value" ] ; then
    echo "$p_conf_value" > $RTEMPDIR_D/commands
  else
    touch $RTEMPDIR_D/commands
  fi
}

function ping_a_host ()
{
  hname=$1
  if [ $platform = "SunOS" ]; then
    $PING -s $hname 5 5 >/dev/null 2>&1
  elif [ $platform = "HP-UX" ]; then
    $PING $hname -n 5 -m 5 >/dev/null 2>&1
  else
    $PING -c 1 $PING_W_FLAG $hname >/dev/null 2>&1
  fi
  ping_exitcode=`echo $?`
}

function get_dnow ()
{
  dnow=$(date '+%Y:%m:%d:%H:%M:%S')
}

function write_dnow_init ()
{
  get_dnow
  echo "$dnow" > $RTEMPDIR_D/last_autorun_time
  echo "$dnow" > $RTEMPDIR_D/last_pchk_time
}

function check_daemon_passwords ()
{
  if [[ -f "$p_conf_file" && `grep -c "PASSWORD_CHECK_INTERVAL" $p_conf_file` -gt "0" ]] ; then
    read_conf "PASSWORD_CHECK_INTERVAL"
    if [[ $p_conf_value -eq "0" ]] ; then return; fi
    pchk_interval_in_mins=$(expr $p_conf_value \* 60)
    pchk_interval_in_secs=$(expr $pchk_interval_in_mins \* 60)
  fi

  if [ -z "$pchk_interval_in_secs" ] ; then
    pchk_interval_in_secs=86400 # Once every day
  fi

  get_dnow
  if [ -e "$RTEMPDIR_D/last_pchk_time" ] ; then
    dlast=$(cat $RTEMPDIR_D/last_pchk_time)
    set_date_vars $dnow
    epoch_now=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    set_date_vars $dlast
    epoch_last=$(perl -e 'use Time::Local;print timelocal('$t_ss','$t_mi','$t_hh','$t_dd','$t_mm'-1,'$t_yr');')
    diff_epoch=`expr $epoch_now - $epoch_last`
    if [ -z "$diff_epoch" ] ; then return; fi
#log_daemon "diff_epoch=$diff_epoch interval=$pchk_interval_in_secs dnow=$dnow dlast=$dlast"
    if [ $diff_epoch -lt $pchk_interval_in_secs ] ; then
      return
    fi
  fi
  echo $dnow > $RTEMPDIR_D/last_pchk_time

  log_daemon "Started checking passwords...."

  touch $RTEMPDIR_D/password_check.running
  root_hostname_counter=0
  for root_hostname in `cat $RTEMPDIR_D/.hosts.txt 2>/dev/null`
  do
    ping_a_host $root_hostname
    if [[ -n "$ping_exitcode" && $ping_exitcode -eq "0" ]] ; then
      if [[ -n "$samerootpassword" && $samerootpassword -eq "0" ]] ; then
        checkUserPassword "$root_hostname" "root" "${a_compute_rootpassword[$root_hostname_counter]}" 1
      else
        checkUserPassword "$root_hostname" "root" "$compute_rootpassword" 1
      fi
      if [ $passwordCheckStatus -ne "0" ] ; then
        stop_daemon "root" "$root_hostname"
      fi
    fi
    root_hostname_counter=$(expr $root_hostname_counter + 1)
  done

  root_cell_counter=0
  cell_type="normal"
  if [[ -n " $is_exalogic_machine" &&  $is_exalogic_machine -eq "1" ]]
  then
    cell_type="zfscell"
  fi
  for cellname in `cat $RTEMPDIR_D/.cells.txt 2>/dev/null |cut -d\" -f2`
  do
    cellPingStatus=$($PING -c 1 $PING_W_FLAG $cellname >/dev/null 2>&1;echo $?)
    if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]] ; then 
      if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq "0" ]] ; then
        checkUserPassword "$cellname" "$cell_ssh_user" "${a_cell_rootpassword[$root_cell_counter]}" "1" $cell_type
      else
        checkUserPassword "$cellname" "$cell_ssh_user" "$cell_rootpassword" "1" $cell_type
      fi
      if [ $passwordCheckStatus -ne "0" ] ; then
        stop_daemon "$cell_ssh_user" "$cellname"
      fi
    fi
    root_cell_counter=$(expr $root_cell_counter + 1)
  done

  root_zfs_counter=0
  for zfsname in `cat $RTEMPDIR_D/.zfs.txt 2>/dev/null|cut -d= -f2|sed 's/"//g'`
  do
    zfsPingStatus=$($PING -c 1 $PING_W_FLAG $zfsname >/dev/null 2>&1;echo $?)
    if [[ -n "$zfsPingStatus" && $zfsPingStatus -eq 0 ]] ; then
      if [[ -n "$zfs_samerootpassword" && $zfs_samerootpassword -eq "0" ]] ; then
        checkUserPassword "$zfsname" "$zfs_ssh_user" "${a_zfs_rootpassword[$root_zfs_counter]}" "1" "zfscell"
      else
        checkUserPassword "$zfsname" "$zfs_ssh_user" "$zfs_rootpassword" "1" "zfscell"
      fi
      if [ $passwordCheckStatus -ne "0" ] ; then
        stop_daemon "$zfs_ssh_user" "$zfsname"
      fi
    fi
    root_zfs_counter=$(expr $root_zfs_counter + 1)
  done

  ib_root_counter=0
  for switchname in `cat $RTEMPDIR_D/.ibs.txt 2>/dev/null`
  do
    $PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
    switchping_status=$(echo $?)
    if [ $switchping_status -eq 0 ] ; then
      if [[ -n "$ib_samerootpassword" && $ib_samerootpassword -eq "0" ]] ; then
        checkUserPassword "$switchname" "$ibswitch_user" "${a_ib_switch_root_password[$ib_root_counter]}" "1" "ibswitch"
      else
        checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "1" "ibswitch"
      fi
      if [ $passwordCheckStatus -ne "0" ] ; then
        stop_daemon "$ibswitch_user" "$switchname"
      fi
    fi
    ib_root_counter=$(expr $ib_root_counter + 1)
  done

  node_index=0 
  for hname in "${a_node_names[@]}"
  do
    ping_a_host $hname
    if [[ -n "$ping_exitcode" && $ping_exitcode -eq "0" ]] ; then
      checkUserPassword "$hname" "$usern" "${a_node_passwords[$node_index]}" "1"
      if [ $passwordCheckStatus -ne "0" ] ; then
        stop_daemon "$usern" "$hname"
      fi
    fi
    node_index=$(expr $node_index + 1)
  done
  log_daemon "Finished checking passwords...."
  rm -f $RTEMPDIR_D/password_check.running
}

function send_mail_using_cell ()
{

  root_cell_counter=0
  for cellname in `cat $RTEMPDIR_D/.cells.txt |cut -d\" -f2`
  do
    if [[  -n "$cell_samerootpassword" && $cell_samerootpassword -eq "0" ]] ; then
      cell_rootpassword=${a_cell_rootpassword[$root_cell_counter]}
    fi
    root_cell_counter=$(expr $root_cell_counter + 1 )
    fixRootPassword "$cell_rootpassword"
    lle_cell_rootpassword=$fixedRootPassword

    cellPingStatus=$($PING -c 1 $PING_W_FLAG $cellname >/dev/null 2>&1;echo $?)
    if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
    then
      $EXPECT -f - >/dev/null 2>&1 << IBEOF
    log_user 1
    spawn -noecho $SSHELL $cell_ssh_user@$cellname "echo $matter | $mail_cmd -s '$subject' $remail"
      exp_internal 1
    if { "$RAT_EXPECT_DEBUG" == "-d" } {
      exp_internal 1
    }    
    set timeout 60
    set le_cell_rootpassword "$lle_cell_rootpassword"
    set i 0
    log_user 1
    while {\$i < 1000000} {
      match_max 100000
      expect {
        "no)?" {
          send -- "yes\r"
         }
         "*?assword:*" {
           send -- "\$le_cell_rootpassword\n"
         }
         eof {
           exit 0
         }
      }
      sleep 1
    }
    set timeout 7200
    expect eof
    exit
IBEOF
      break;
    fi
  done
}

function run_client_script ()
{

  global_pass_prompt_ans="n"
  if [[ $root_all_prompt -eq "1" ]] ; then
    global_pass_prompt_ans="y"
  fi

  same_password_cell_ans="y"
  same_password_zfs_ans="y"
  same_password_node_ans="y"
  same_password_switch_ans="y"
  node_password_prompts=""
  if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq "0" ]] ; then 
    same_password_cell_ans="n"; 
    root_cell_counter=0
    for cellname in `cat $RTEMPDIR_D/.cells.txt |cut -d\" -f2`
    do
      if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
      then
        cellname_full=$cellname
      else
        cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)
      fi
      cell_password_prompts="$cell_password_prompts
     \"Enter * password for*STORAGE SERVER* $cellname_full :\" {
        send -- \"${a_cell_rootpassword[$root_cell_counter]}\\r\"
      }"
      root_cell_counter=$(expr $root_cell_counter + 1 )
    done
  fi

  if [[ -n "$zfs_samerootpassword" && $zfs_samerootpassword -eq "0" ]] ; then 
    same_password_zfs_ans="n"; 
    root_zfs_counter=0
    for zfsname in `cat $RTEMPDIR_D/.zfs.txt|cut -d= -f2|sed 's/"//g'`
    do
      zfs_password_prompts="$zfs_password_prompts
     \"Enter * password for*ZFS Storage Appliance* $zfsname :\" {
        send -- \"${a_zfs_rootpassword[$root_zfs_counter]}\\r\"
      }"
      root_zfs_counter=$(expr $root_zfs_counter + 1 )
    done
  fi

  if [[ -n "$samerootpassword" && $samerootpassword -eq "0" ]] ; then 
    same_password_node_ans="n"; 
    root_hostname_counter=0
    for root_hostname in `cat $RTEMPDIR_D/.hosts.txt`
    do
      node_password_prompts="$node_password_prompts
     \"Enter root password *$root_hostname :\" {
        send -- \"${a_compute_rootpassword[$root_hostname_counter]}\\r\"
      }"
      root_hostname_counter=$(expr $root_hostname_counter + 1)
    done
  fi

  if [[ -n "$ib_samerootpassword" && $ib_samerootpassword -eq "0" ]] ; then 
    same_password_switch_ans="n"; 
    ib_root_counter=0
    for switchname in `cat $RTEMPDIR_D/.ibs.txt`
    do
      switch_password_prompts="$switch_password_prompts
     \"Enter * password for*INFINIBAND SWITCH* $switchname :\" {
        send -- \"${a_ib_switch_root_password[$ib_root_counter]}\\r\"
      }
     \"Enter * password for* $switchname :\" {
        send -- \"${a_ib_switch_root_password[$ib_root_counter]}\\r\"
      }"
      ib_root_counter=$(expr $ib_root_counter + 1 )
    done
  fi


  db_os_auth_prompts=""
  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do
    if [[ -n "${mb_sysdba_user[$mb_db_counter]}" ]] ; then
      db_os_auth_prompts="$db_os_auth_prompts
      \"OS authenticaltion is not enabled so please enter sysdba privileged user name for $db_name_to_check:\" {
        send -- \"${mb_sysdba_user[$mb_db_counter]}\\r\"
      }
      \"Enter password for ${mb_sysdba_user[$mb_db_counter]}@$db_name_to_check:\" {
        send -- \"${mb_sysdba_pswd[$mb_db_counter]}\\r\"
      }"
    fi
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  db_os_auth_prompts="$db_os_auth_prompts
     \"OS authenticaltion is not enabled so please enter sysdba privileged user name for *\" {
        send -- \\\r\"
      }
      \"Enter user name again for *:*\" {
        send -- \"\\r\"
      }
      \"Enter password for *@*\" {
        send -- \"\\r\"
      }"

  pdb_password_prompts=""
  mb_pdb_counter=0
  for pdb_name in "${mb_pdb_names[@]}"
  do
    pdb_password_prompts="$pdb_password_prompts
    \"Enter * user password for $pdb_name pluggable database\" {
      send -- \"${mb_pdb_sys_password[$mb_pdb_counter]}\\r\"
    }"
    mb_pdb_counter=$(expr $mb_pdb_counter + 1)
  done
  pdb_password_prompts="$pdb_password_prompts
    \"Enter * user password for * pluggable database\" {
      send -- \"\\r\"
    }"

  ssh_password_prompts=""
  node_index=0
  for hname in "${a_node_names[@]}"
  do
    ssh_password_prompts="$ssh_password_prompts
    \"Enter ${usern} *password on $hname * :\" {
      send -- \"${a_node_passwords[$node_index]}\\r\"
    }"
    node_index=$(expr $node_index + 1)
  done
  ssh_password_prompts="$ssh_password_prompts
    \"Enter ${usern} *password on * :\" {
      send -- \"\\r\"
    }"
  
  #echo "$cell_password_prompts"
  #echo "$zfs_password_prompts"
  #echo "$node_password_prompts"
  #echo "$switch_password_prompts"

  fixRootPassword "$cell_rootpassword"
	lle_cell_rootpassword=$fixedRootPassword	
  fixRootPassword "$switch_rootpassword"
	lle_switch_rootpassword=$fixedRootPassword
  fixRootPassword "$zfs_rootpassword"
	lle_zfs_rootpassword=$fixedRootPassword
  fixRootPassword "$global_root_password"
	lle_global_root_password=$fixedRootPassword
  fixRootPassword "$compute_rootpassword"
	lle_compute_rootpassword=$fixedRootPassword
  
  $EXPECT -f - >> $RTEMPDIR_D/run.log 2>&1 << IBEOF
    log_user 1
    spawn -noecho $RTEMPDIR_D/run.sh
    if { "$RAT_EXPECT_DEBUG" == "-d" } {
      exp_internal 1
    }    
    set timeout 60
    set le_cell_rootpassword "$lle_cell_rootpassword"
    set le_switch_rootpassword "$lle_switch_rootpassword"
    set le_zfs_rootpassword "$lle_zfs_rootpassword"
    set le_global_root_password "$lle_global_root_password"
    set le_compute_rootpassword "$lle_compute_rootpassword"
    set i 0
    log_user 1
    while {\$i < 1000000} {
      match_max 100000
      expect {
        eof {
           exit
         }
        "no)?" {
          send -- "yes\r"
         }
         "CRS stack is running and CRS_HOME is not set. Do you want to set CRS_HOME*" {
           send -- "y\r"
         }
         "Select respective number to choose database*checking best practices.*" {
           send -- "\r"
         }
         "Select databases from list for checking best practices.*" {
           send -- "\r"
         }
         "Please indicate your selection from one of the above*" {
           send -- "\r"
         }
         "Do you want to configure SSH for user*" {
           send -- "n\r"
         }
         "We can configure ssh only for this run and reverse the changes back. do you want to continue?*" {
           send -- "y\r"
         }
         "Is root password same on all components? *" {
           send -- "$global_pass_prompt_ans\r"
         }
         "Is * password same on all STORAGE SERVER" {
           send -- "$same_password_cell_ans\r"
         }
         "Is * password same on all ZFS Storage Appliance" {
           send -- "$same_password_zfs_ans\r"
         }
         "Is * password same on all*nodes" {
           send -- "$same_password_node_ans\r"
         }
         "Is * password same on all INFINIBAND SWITCH" {
           send -- "$same_password_switch_ans\r"
         }
         $ssh_password_prompts
         $cell_password_prompts
         $zfs_password_prompts
         $node_password_prompts
         $switch_password_prompts
         "Unable to determine nodes in cluster.  Do you want to enter manually.*" {
           send -- "\r"
         }
         "Enter cluster node names *," {
           send -- "\r"
         }
         "CRS binaries found at * Do you want to set CRS_HOME to *" {
           send -- "\r"
         }
         "Enter * password*STORAGE SERVER*" {
           send -- "\$le_cell_rootpassword\r"
         }
         "Enter * password*INFINIBAND SWITCH*" {
           send -- "\$le_switch_rootpassword\r"
         }
         "Enter * password*ZFS Storage Appliance*" {
           send -- "\$le_zfs_rootpassword\r"
         }
         "Enter root password*components*" {
           send -- "\$le_global_root_password\r"
         }
         "Enter root password*" {
           send -- "\$le_compute_rootpassword\r"
         }
         "Enter root  password*" {
           send -- "\$le_compute_rootpassword\r"
         }
         $db_os_auth_prompts
         $pdb_password_prompts
         "Do you want to continue*" {
           send -- "\r"
         }
         "Output directory to read for offline use is*" {
           send -- "\r"
         }
         "Press enter to  continue..*" {
           send -- "\r"
         }
         "*           Node name -*" {
           set timeout 7200
           expect eof
           exit
         }
         "*Checking Best Practice Recommendations*" {
           set timeout 7200
           expect eof
           exit
         }
      }
      sleep 1
    }
    set timeout 7200
    expect eof
    exit
IBEOF

}

function cleanup_client ()
{
  if [ -e "${RTEMPDIR}/${program_name}.pid" ] ; then 
    program_pid=$(cat ${RTEMPDIR}/${program_name}.pid)
  fi
  if [ -e "$RTEMPDIR_D/run.pid" ] ; then
    run_pid=$(cat $RTEMPDIR_D/run.pid)
  fi
  if [[ -n "$program_pid" && `ps -ef| grep -w "$program_pid" | grep -v grep| wc -l` -gt "0" ]] ; then
    kill -15  $program_pid
  fi
  if [[ -n "$run_pid" && `ps -ef| grep -w "$run_pid" | grep -v grep| wc -l` -gt "0" ]] ; then
    kill -15  $run_pid
  fi

  if [ -e "$RTEMPDIR_D/client.pid" ] ; then
    rm -f $RTEMPDIR_D/client.pid
  fi
}

function log_daemon ()
{
  echo -e "`date '+%a %b %d %H:%M:%S %Y'` - $1\n" >> $WRKDIR/${program_name}_daemon.log
}

function get_program_key ()
{
  md5sum_program=$(which md5sum 2>/dev/null| grep -v "no md5sum in")
  if [ -n "$md5sum_program" ] ; then
    program_key=$(md5sum $0 | awk '{print $1}')
  else
    program_key=$(ls -l $0 | awk '{print $5$6$7$8}')
  fi
}

function killsub() 
{
  kill ${1} >/dev/null 2>/dev/null
  #wait ${1} 2>/dev/null
}
# TODO
# Check if request is from same user - done
# md5sum use full path instead of one in PATH
# when user process is killed, kill client also - done.. not allowing stop when active client exists

function handle_client_request ()
{
  #send_email "Started ${program_name} run" "Started exachk run"
  args=$(cat $RTEMPDIR_D/commands)
  log_daemon "Started ${program_name} execution : args = $args"

  #echo "starting to run $0 args = $args"

  export RAT_DAEMON_CLIENT=1
  get_program_key

  if [[ $program_key = $RAT_PROGRAM_KEY ]] ; then
    echo "#!/bin/bash" > $RTEMPDIR_D/run.sh
    echo "echo \$\$ > $RTEMPDIR_D/run.pid" >> $RTEMPDIR_D/run.sh
    if [ -e "$RTEMPDIR_D/setenv.sh" ] ; then
      echo ". $RTEMPDIR_D/setenv.sh" >> $RTEMPDIR_D/run.sh
    fi
    echo "$0 $args" >> $RTEMPDIR_D/run.sh
    chmod +x $RTEMPDIR_D/run.sh
    run_client_script
    rm -f $RTEMPDIR_D/run.pid
  else
    #echo >>$RTEMPDIR_D/run.log
    echo > $RTEMPDIR_D/run_error.log
    echo -e "${RED}$0 is changed since daemon started. Restart(stop & start) daemon using new ${program_name}. You could also use -nodaemon option to ignore daemon. ex: ${program_name} -nodaemon <other options>.${NORM}" >> $RTEMPDIR_D/run_error.log
    echo >> $RTEMPDIR_D/run_error.log
    log_daemon "Failed to run ${program_name} as $0 is changed since daemon started. Restart(stop & start) daemon using new ${program_name}"
  fi

  if [ -f "$RTEMPDIR_D/client.pid" ] ; then
    cpid=$(cat $RTEMPDIR_D/client.pid)
    if [[ -n "$cpid" && `ps -ef |grep -w "$cpid"| grep -v grep|wc -l` -gt "0" ]] ; then
      log_daemon "Client pid : $cpid"
      tpid=$(ps -ef |grep -w $cpid|grep tail |grep -v grep |awk '{print $2}')
      if [ -n "$tpid" ] ; then
        #echo "killing using kill"
        killsub $tpid >/dev/null 2>&1
      else
        killtree $cpid 9 >/dev/null 2>&1
      fi
    fi
  fi
  mv $RTEMPDIR_D/commands $RTEMPDIR_D/commands.done
  mv $RTEMPDIR_D/run.log $RTEMPDIR_D/run.log.done
  rm -f $RTEMPDIR_D/client.pid
  log_daemon "Finished ${program_name} execution"
}

#function to map ip address to switch name and find switch type for each(leaf or spine)
switch_ip_type_name_mapping ()
{
 if [[ -e $OUTPUTDIR/o_ibswitches_${localnode}.out && -e $OUTPUTDIR/o_verify_topology_report_${localnode}.out ]]
 then
     if [ -e $SWITCH_TYPE_FIL ]; then rm -rf $SWITCH_TYPE_FIL >/dev/null 2>&1;fi
     for switchip in `cat $OUTPUTDIR/o_ibswitches_${localnode}.out`
     do
       ib_switch_type=$(grep "$switchip (" $OUTPUTDIR/o_verify_topology_report_${localnode}.out|awk '{print $1}'|uniq)
       is_ibswitch_ip=$(echo $switchip|grep -c [A-Za-z])
       if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
       then
           ib_switch_name=$(nslookup $switchip|grep -i name|awk '{print $NF}'|sed 's/\.$//')
       else
           ib_switch_name=$switchip
       fi
       echo "$switchip|$ib_switch_type|$ib_switch_name">>$SWITCH_TYPE_FIL
     done  
 fi
 unset is_ibswitch_ip
}


#Set the defaults
# multilinemb_db_homes_fil 
#main scripts execution starts from here
program_name=$(echo $(basename $0)|sed 's/[\.\/]//g')
bash_found=$(which bash >/dev/null 2>&1;echo $?)
#to disable strict bash settings
set +u
if [ $bash_found -ne 0 ]
then
   echo -e "\n${RED}Currently the ${program_name} tool requires the BASH shell. Please install bash and try again.${NORM}\n"
   exit 1;
fi
#if [ `uname -s` = "HP-UX" ]
#then
#   echo -e "\n${RED}The ${program_name} is not supported on `uname -s` platform yet.${NORM}\n"
#fi
ECHO=:
DEBUG=:
AUDITTAB=db_audit
supported_modules="PREUPGR              
POSTUPGR             
NONE
PREUPGRX3-8          
POSTUPGRX3-2         
HACHECK  
SIDBHACHECK            
EXALOGIC_DB          
EXALOGIC_OVMM        
EXALOGIC_EC          
EXALOGIC_PC          
ODA                  
PREUPGRX2-8          
PREUPGRDBM           
POSTUPGRX2-2         
POSTUPGRX2-8         
POSTUPGRDBM          
EXALOGIC_VM          
X3-8                 
SIDB                 
SIDBMAA              
ACFS                 
ASM                  
CRS                  
DBM                  
MAA                  
OS                   
OVM                  
OVS                  
RDBMS                
UPGR                 
X2-2                 
X2-8                 
PREUPGRX2-2          
POSTUPGRX3-8         
X3-2                 
EXALOGIC             
RACCHECK             
PREUPGRX3-2          
SUPERCLUSTER         
PREUPGRSUPERCLUSTER  
POSTUPGRSUPERCLUSTER
AVM"

# Changes made by jrmullan 03/22/10
if [ -n "$SUDOCMD" ]
then
   # A valid sudo command was set up, this is specifically set for the Dell environment where they allow DBA's to
   # use sudo for specific files.  In this case /tmp/root_raccheck.sh
   echo ""
else
   export SUDOCMD="/usr/bin/sudo"
fi
if [[ -n "$RAT_LOCALONLY" && $RAT_LOCALONLY -eq 1 ]]; then localonly=1;else localonly=0;fi
trim="sed 's/^ *\(.*\) *$/\1/'"
trim1="sed 's/^[[:space:]]*//g' | sed 's/[[:space:]]*$//g'"
ltrim="sed 's/^[[:space:]]*//g'"
rtrim="sed 's/[[:space:]]*$//g'"
#AUDITTAB=bp_audit
#location where raccheck.sh staged
#CHECKHOME=$HOME/giri/stage
#if [ ! -f $CHECKHOME/collections.dat ]
#then
#if [ `uname -s` = "Linux" ]
#then
#    CHECKHOME=$(readlink -f $0)
#    CHECKHOME=$(dirname $CHECKHOME)
#    CHECKHOME=$PWD
#else
 #   CHECKHOME=$(dirname $0)
#fi
#read -p "CHECKHOME=$CHECKHOME"
#fi
#To fix bug reported by Srini to ignore ORACLE_SID when run in offline and create zip file at current working dir.

CHECKHOME=$PWD
#CHECKHOME_RELATIVE=$(dirname $0)
if [[ -n "$ORACLE_SID" && $OFFLINE -eq 1 ]]
#if [ -n "$ORACLE_SID" ]
then
    WRKDIR=$CHECKHOME/$ORACLE_SID
else
   WRKDIR=$CHECKHOME
fi
#Function to change old environment variable names to new standard environment names
change_old_env_variables 
#following check is to have output directory created at some diffrent local other than where we run raccheck from.
if [ -z $RAT_OUTPUT ]; then WRKDIR=$WRKDIR; else WRKDIR=$RAT_OUTPUT; fi; 

check_wrkdir;
assign_usern

SCRIPTPATH=$(dirname $0)
SCRIPTFIL=$SCRIPTPATH/$program_name
REFFIL=$SCRIPTPATH/collections.dat
REFFIL1=$SCRIPTPATH/rules.dat

if [[ -n "$RAT_FDS_INTERNAL" ]] ; then # In slave mode, its set
  FDS=$RAT_FDS_INTERNAL
else
  FDS=`date '+%m%d%y_%H%M%S'`
fi

INPUTDIR=${WRKDIR}/.input_${FDS}
SQLFIL=$INPUTDIR/d_check.sql
UPLOADFIL_VAR=$program_name
UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_$FDS
OUTPUTDIR_VAR=$program_name
OUTPUTDIR=$WRKDIR/${OUTPUTDIR_VAR}_$FDS
SPOOLFIL=$OUTPUTDIR/d_check.out
OSOUTFIL=$OUTPUTDIR/o_check
UPDATEFIL=$OUTPUTDIR/db_update_$FDS.sql
SQLLOGFIL=$OUTPUTDIR/sql.log
LOGFIL=$OUTPUTDIR/${program_name}.log
SKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks.log
REPFIL=$OUTPUTDIR/${program_name}.rep
XMLREPFIL=$OUTPUTDIR/${program_name}_results.xml
XMLSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.xml
ERRFIL=$OUTPUTDIR/${program_name}_error.log
HOSTLIST=$OUTPUTDIR/o_host_list.out
MASTERFIL=$OUTPUTDIR/raccheck_env.out
ORCLENVFIL=$INPUTDIR/set_orcl_env.sh
SREPFIL=$OUTPUTDIR/${program_name}_summary.rep
WRNDBPWD=0
WATCHDOG=$INPUTDIR/watchdog.sh
WATCHLOG=$OUTPUTDIR/watchdog.log
EXESQL=$INPUTDIR/exec_raccheck_sqls.sh
napply_missing_list=$OUTPUTDIR/o_napply_missing_list.out
upload_raccheck_result_fil=$OUTPUTDIR/upload_${program_name}_result.sql
upload_raccheck_patch_result_fil=$OUTPUTDIR/upload_${program_name}_patch_result.sql
REPFIL_PASS=$OUTPUTDIR/${program_name}_pass.rep
REPFIL_FAIL=$OUTPUTDIR/${program_name}_fail.rep
SREPFIL_PASS=$OUTPUTDIR/${program_name}_summary_pass.rep
SREPFIL_FAIL=$OUTPUTDIR/${program_name}_summary_fail.rep
CWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_pass.rep
SCWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_summary_pass.rep
CWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_fail.rep
SCWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_summary_fail.rep
PREPFIL=$OUTPUTDIR/${program_name}_patches.rep
PSREPFIL=$OUTPUTDIR/${program_name}_patches_summary.rep
CWSQLPARAM=$OUTPUTDIR/${program_name}_cw_sqlparam.out
CWOSPARAM=$OUTPUTDIR/${program_name}_cw_osparam.out
CWOSPKG=$OUTPUTDIR/${program_name}_cw_ospkg.out
CWOSPATCH=$OUTPUTDIR/${program_name}_cw_ospatch.out
CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
EXCLUDEFIL=$CHECKHOME/excluded_check_ids.txt
RTEMPDIR=/tmp/.${program_name}
RTEMPDIR_D=/tmp/.${program_name}_${usern}_d
SYSTEM_DESC_FIL=${RTEMPDIR}/cell_system_description.out 
SerialNumberFil=/var/log/cellos/SerialNumbers
LOCKFIL=${RTEMPDIR}/${program_name}.pid
AVMIDFIL=/opt/oracle.SupportTools/onecommand/databasemachine.xml
SWITCH_TYPE_FIL=$OUTPUTDIR/switch_ip_type_name_mapping_detail.out
SWITCH_TYPE_FIL_SHORT=switch_ip_type_name_mapping_detail.out
delete_lock_file=0
no_patches=0
if [ -z "$RAT_SSHELL" ]
then
    SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -q"
    SSHELL_EL=$(echo ${SSHELL}t)
else
    SSHELL=$RAT_SSHELL   
fi
if [ -z "$RAT_SCOPY" ]
then
    SCOPY="/usr/bin/scp -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -q"
else
    SCOPY=$RAT_SCOPY
fi
if [[ -n "$RAT_EXPECT_STRACE_DEBUG" && "$RAT_EXPECT_STRACE_DEBUG" = "strace" && `uname -s` = "Linux" ]]; 
then 
    EXPECT="strace /usr/bin/expect"
else
    EXPECT=/usr/bin/expect
fi
write_report_on_fail=1
write_switchname_in_report=1
write_cellname_in_report=1 
noRootScriptNodeCount=0
cgrep_platform=$(uname -s)
COLLECT_TIMING=$OUTPUTDIR/${program_name}_collection_timings.out
ROOT_COLLECT_TIMING=${RTEMPDIR}/o_root_collect_timing.out
CHECKS_TIMING=$OUTPUTDIR/${program_name}_checks_timings.out
RACCHECK_TIMING=$OUTPUTDIR/${program_name}_timings.out
MISCCWCHECK=$OUTPUTDIR/o_misc_clusterwide_checks.out
EXADATA_CELL_COLLECTIONS=/tmp/o_exadata_disk.out 
CELLDIR="$OUTPUTDIR/.CELLDIR"
fmt_line_header="---------------------------------------------------------------------------------"
#this was unset because tr command does not work if LANG is set to on Solaris.reported by e-dialog
unset LANG NLS_LANG

# Defaults
components=NONE
upgrade_mode=0
print_pass_on_screen=0
TYP_S=""
TYP="-a"
ASREXACHK=asrexacheck #variable to store the name of asreaxchk script
cross_node_checkids_counter=0 #variable to store index couter for cross_node_checkid
process_cross_node_checks=0
skip_maa_scorecard=0
skip_hacheck=0
run_profile=0;
profiles2run=""
is_ssc_machine=0
is_exalogic_machine=0
print_pass_in_report=1
print_score_in_report=1

read_p2r=0
p2r_org=""

long_args=0

daemon_mode=0
daemon_command="";
daemon_only=0

argnew="$*"
argsaved="$*"

setting_conf=0
options2set=""
p_conf_file="$WRKDIR/.${program_name}_conf.dmp"

if [ `echo $argsaved | grep -cw 'd *start'` -gt "0" ] ; then
  argsaved=$(echo $argsaved | sed 's/-d *start//')
  daemon_start="-d start"
  set " $daemon_start"
fi

for arg in "$@"
do
  remove_arg=0
  if [[ $read_p2r = "-profile" ]] ; then
    p2r_org="$arg"
    #profiles2run=$(echo $arg| sed 's/,/ /g');
    profiles2run=$arg
    remove_arg=1
  elif [[ $read_p2r = "-set" ]] ; then
    setting_conf=1
    remove_arg=1
    options2set="$arg"
  elif [[ $read_p2r = "-get" ]] ; then
    reading_conf=1
    remove_arg=1
    options2get="$arg"
  elif [[ $read_p2r = "-clusternodes" ]] ; then
    RAT_CLUSTERNODES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-cells" ]] ; then
    RAT_CELLS="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-zfsnodes" ]] ; then
    RAT_ZFS_NODES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-ibswitches" ]] ; then
    RAT_IBSWITCHES="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-outfile" ]] ; then
    report3="$arg"
    remove_arg=1
  elif [[ $read_p2r = "-targetversion" ]]; then
    targetversion="$arg" 
    remove_arg=1
  fi

  if [ $remove_arg -eq "1" ] ; then
    argnew=$(echo "$argnew" | sed 's/'$read_p2r'//' | sed "s/$arg//")
    long_args=1
  fi

  case $arg in 
  "-profile")
    run_profile=1;
    TYP="-b";
    read_p2r="$arg"
    ;;
  "-set"|"-get")
    read_p2r="$arg"
    ;;
  "-clusternodes")
    read_p2r="$arg"
    ;;
  "-cells")
    read_p2r="$arg"
    ;;
  "-zfsnodes")
    read_p2r="$arg"
    ;;
  "-ibswitches")
    read_p2r="$arg"
    ;;
  "-localonly")
    read_p2r="$arg"
    localonly=1
    RAT_LOCALONLY=1
    remove_arg=2
    ;;
  "-nopass")
    read_p2r="$arg"
    print_pass_in_report=0
    remove_arg=2
    ;;
   "-noscore")
    read_p2r="$arg"
    print_score_in_report=0
    remove_arg=2
    ;;
   "-preupgrade")
    TYP="-u"
    upgrade_mode=1
    remove_arg=2
    argnew="-u -o pre"
    ;;
   "-postupgrade")
    TYP="-u"
    upgrade_mode=1
    remove_arg=2
    argnew="-u -o post"
    ;;
   "-targetversion")
     read_p2r="$arg"
    ;;
   "-sf")
     #change this line before beta 
     exit
    ;;
  "-diff")
    compare_reports $*
    exit
    ;;
  "-outfile")
    read_p2r="$arg"
    ;;
  "-nodaemon")
    read_p2r="$arg"
    opt_n=1;
    remove_arg=2
    ;;
  "-daemon")
    read_p2r="$arg"
    daemon_only=1;
    remove_arg=2
    ;;
  *)
    read_p2r="none"
    ;;
  esac

  if [ $remove_arg -eq "2" ] ; then
    argnew=$(echo $argnew | sed 's/'$read_p2r'//')
    long_args=1
  fi
done

if [[ -n "$reading_conf" && $reading_conf -eq "1" ]] ; then
  show_conf_file $options2get
  exit
fi

argnew_afterlong=""
if [[ -n "$long_args" && $long_args -eq "1" ]] ; then
  argnew_afterlong=$(echo $argnew| sed 's/ //g')
  if [[ -z "$argnew" || `echo "$argnew" | grep -ic '^ *$'` -gt "0" ]] ; then argnew="-b"; fi
else
  argnew="$*"
  argnew_afterlong="$argnew"
fi
#To add current directory in PATH to execute cgrep from current location
while getopts "abnvhpfmsuSo:c:t:d:" OPT $argnew
do
 case $OPT in
 a) 
    TYP="-a"
    ;;
 b) 
    TYP="-b"
    ;;
 p) 
    TYP="-p"
    ;;
 f) 
    TYP="-f"
    ;;
 s) 
    TYP_S="-s"
    ;;
 t) 
    if [ -n "$OPTARG" ]
    then
      targetversion=$OPTARG
    else
      echo "Invalid input for target version.";
      exit;
    fi
    ;;
 u) 
    TYP="-u"
    upgrade_mode=1
    opt_n=1
    supportedTargetVersion="112030 112040 121010"
    supportedTargetVersionPrint="11.2.0.3.0,11.2.0.4.0 or 12.1.0.1.0"
    ;;
 S)
    TYP_S="-S"
    ;;
 o)
    case $OPTARG in
    verbose|VERBOSE|Verbose|V|v)
      print_pass_on_screen=1
      ;;
    pre)
      if [[ -n "$upgrade_mode" && $upgrade_mode -eq 1 ]];then upgrade_mode=2;components=$(echo "${components}:PREUPGR");fi
      ;;
    post)
      if [[ -n "$upgrade_mode" && $upgrade_mode -eq 1 ]];then upgrade_mode=3;components=$(echo "${components}:RACCHECK:MAA:POSTUPGR");fi
      ;;
    *)
      echo "Invalid option : -o $OPTARG"
      exit;
      ;;
    esac
    ;;
 c)
    if [ -n "$OPTARG" ]
    then
        OPTARG=$(echo $OPTARG|tr "[A-Z]" "[a-z]")
        OPTARG=$(echo "$OPTARG"|sed 's/[:_,]/:/g')
        components=$OPTARG
        options_components=$OPTARG
        #read -p "options_components=$options_components"  
    fi
    ;;
 n)
    opt_n=1;
    ;;
 d)
    daemon_mode=1;
    daemon_command="start";
    if [ -n "$OPTARG" ]
    then
        OPTARG=$(echo $OPTARG|tr "[A-Z]" "[a-z]") 
        daemon_command="$OPTARG";
    fi
    ;;
 v)
    TYP="-v"
    ;;
 m)
    TYP="-m"
    skip_maa_scorecard=1 
    
    ;;
r)
   TYP="-r"
   skip_hacheck=1 
    ;;
 *) usage ;;
 esac
done

shift `expr $OPTIND`
#if [ $# -gt 5 ]
#then
# usage
#fi

if [[ $# -lt 1 || -z "$TYP" ]]
then
    TYP="-a"
fi
if [[ "$TYP" = "-u" && $upgrade_mode -eq 1 ]]; then echo -e "\n${RED}specify -o pre or -o post option with -u argument like ./${program_name} -u -o pre\n\n${NORM}";usage;fi
user_components=$components

if [[ -n "$setting_conf" && $setting_conf -eq "1" ]] ; then
  update_conf_file
  if [ -z "$argnew_afterlong" ] ; then exit; fi
fi

daemon_running=0
if [[ -e "$RTEMPDIR_D/daemon.pid" ]] ; then # daemon is running
  dpid=$(cat $RTEMPDIR_D/daemon.pid)
  if [[ -n "$dpid" && `ps -ef | grep $dpid | grep -v grep | wc -l` -gt "0" ]] ; then
    daemon_running=1
  fi
fi

if [[ $daemon_running -eq "0" && -n "$RTEMPDIR_D" && -d "$RTEMPDIR_D" ]] ; then
  rm -rf $RTEMPDIR_D
fi

# Dont use daemon for offline, silent or -S/-s
#if [[ "$TYP" = "-f" || "$TYP_S" = "S" || "$TYP_S" = "s" ]] ; then
if [[ "$TYP" = "-f" || "$TYP" = "-v" ]] ; then
  opt_n=1
fi

if [[ -n "$opt_n" && $opt_n -eq "1" ]] ; then
  daemon_running=0
  daemon_command=""
  daemon_mode=0
fi

if [[ -n "$daemon_only" && $daemon_only -eq "1" && $daemon_running -eq "0" ]] ; then
  echo
  echo -e "${RED}Daemon is not running. Please start the daemon using '$program_name -d start'${NORM}";
  echo
  exit;
fi

if [[ -n "$daemon_command" && $daemon_command != "start" && $daemon_command != "stop" && $daemon_command != "status" && $daemon_command != "nextautorun" ]] ; then
  echo
  echo -e "${RED}Invalid daemon command $daemon_command. Valid options are start,stop,status,nextautorun${NORM}";
  echo
  exit;
fi

if [[ $daemon_running -eq "0" && $daemon_command = "nextautorun" ]] ; then
  echo
  echo -e "${RED}Daemon is not running. Please start the daemon using '$program_name -d start'${NORM}";
  echo
  exit;
elif [[ $daemon_command = "nextautorun" ]] ; then
  next_autorun_on
  exit  
fi

if [[ $daemon_running -eq "1" && -n "$daemon_command" && $daemon_command = "start" ]] ; then
  echo
  echo -e "${RED}Daemon is already running with PID $dpid${NORM}";
  echo
  exit;
fi

if [[ -n "$daemon_command" && $daemon_command = "start" &&  ! -e "$EXPECT" ]] ; then
  # expect should be there
  echo -e "${RED}Could not start ${program_name} in daemon mode because expect($EXPECT) is not available to supply root passwords.${NORM}" 
  echo
  echo -e "${RED}NOTICE:  Installing the expect utility (/usr/bin/expect) will allow ${program_name} to gather root passwords at the beginning of the process and execute ${program_name} on all nodes in parallel speeding up the entire process. For more info - http://www.nist.gov/el/msid/expect.cfm.  Expect is available for all major platforms.  See User Guide for more details.${NORM}"
  echo;
  exit;
fi

if [[ $daemon_running -eq "1" && -n "$daemon_command" && $daemon_command = "stop" ]] ; then
  printf "Stopping the daemon ";
  if [ -e "$RTEMPDIR_D/commands" ] ; then
    echo
    cpid=$(cat $RTEMPDIR_D/client.pid);
    echo -e "${RED}Failed to stop the daemon as there is an active client run (PID : $cpid)${NORM}"
    echo
    exit;
  fi

  stop_daemon_actual
elif [[ $daemon_running -eq "0" && -n "$daemon_command" && $daemon_command = "stop" ]] ; then
  echo "Daemon is not running"
  exit
fi

if [[ -n "$daemon_command" && $daemon_command = "status" ]] ; then
  if [[ $daemon_running -eq "1" ]] ; then
    echo "Daemon is running. PID : $dpid";
  else
    echo "Daemon is not running.";
  fi
  exit;
fi

# Client mode. just submit command and wait for daemon

if [[ $daemon_running -eq "1" && -z "$daemon_command" && -z "$RAT_DAEMON_CLIENT" ]] ; then

  if [ -e "$RTEMPDIR_D/commands" ] ; then
    echo "Another instance is already in queue.. exiting";
    exit;
  fi

  trap 'cleanup_client $USER_INTERRUPT' INT TERM EXIT
  echo "Sending commands to daemon (mypid $$) args : $argsaved"

  submit_client_run
fi

profileids2run=""

profile_db_checks=1
profile_root_checks=1
profile_cell_checks=1
profile_zfs_checks=1
profile_switch_checks=1
profile_module_checks=1
profile_cvm_only=0

if [[ $run_profile -eq "1" && -z "$profiles2run" ]] ; then
  echo -e "${RED}Profile name is missing${NORM}"
  echo;
  usage;
elif [[ $run_profile -eq "1" ]] ; then
  TYP="-b"
  profile_db_checks=0
  profile_root_checks=0
  profile_cell_checks=0
  profile_zfs_checks=0
  profile_switch_checks=0
  profile_module_checks=0
  selected_profiles=0

  old_ifs=$IFS
  IFS=","
  for aprofile in $profiles2run
  do
    aprofile_id=$(grep -i "^$aprofile|" $SCRIPTPATH/.cgrep/profiles.dat|cut -d"|" -f2)
    if [ -z "$aprofile_id" ] ; then
      echo -e "${RED}Selected profile $aprofile does not exists.. exiting ${NORM}"
      echo;
      IFS="$old_ifs"
      usage;
    elif [ ! -e "$SCRIPTPATH/.cgrep/profiles/$aprofile_id.prf" ] ; then
      echo -e "${RED}Selected profile $aprofile does not exists.. exiting ${NORM}"
      echo;
      IFS="$old_ifs"
      usage;
    fi
    profileids2run="$profileids2run $aprofile_id"
    pline=$(grep -i "^$aprofile|" $SCRIPTPATH/.cgrep/profiles.dat);
    db_checks=$(echo $pline | cut -d"|" -f3)
    root_checks=$(echo $pline | cut -d"|" -f4)
    cell_checks=$(echo $pline | cut -d"|" -f5)
    zfs_checks=$(echo $pline | cut -d"|" -f5)
    switch_checks=$(echo $pline | cut -d"|" -f6)
    module_checks=$(echo $pline | cut -d"|" -f7)

    ccnt_file=$(wc -l $SCRIPTPATH/.cgrep/profiles/$aprofile_id.prf | awk '{print $1}')
    
    selected_profiles=$(expr $selected_profiles + 1)

    if [ -n "$db_checks" ] ; then
      profile_db_checks=$(expr $profile_db_checks + $db_checks)
    fi

    if [ -n "$root_checks" ] ; then
      profile_root_checks=$(expr $profile_root_checks + $root_checks)
    fi
    if [ -n "$cell_checks" ] ; then
      profile_cell_checks=$(expr $profile_cell_checks + $cell_checks)
    fi
    if [ -n "$zfs_checks" ] ; then
      profile_zfs_checks=$(expr $profile_zfs_checks + $zfs_checks)
    fi
    if [ -n "$switch_checks" ] ; then
      profile_switch_checks=$(expr $profile_switch_checks + $switch_checks)
    fi
    if [ -n "$comp_checks" ] ; then
      profile_module_checks=$(expr $profile_comp_checks + $comp_checks)
    fi

    if [[ -n "$pline" && `echo "$pline" | grep -ic "EXALOGIC_CVM="` -gt "0" ]]
    then
      cvm_ccnt=$(echo $pline | sed 's/.*EXALOGIC_CVM=//' | sed 's/|.*//'| sed 's/:.*//')
      if [[ -n "$ccnt_file" && -n "$cvm_ccnt" && $cvm_ccnt -eq $ccnt_file ]] ; then
        profile_cvm_only=1
      fi
    fi
  done
  IFS=$old_ifs

#echo "selected_profiles=$selected_profiles profile_cell_checks=$profile_cell_checks";
  cell_in_profile=$(echo "$profiles2run" | grep -icw storage_server)
  if [ $cell_in_profile -eq 0 ];then cell_in_profile=$(echo "$profiles2run" | grep -icw storage);fi
  switch_in_profile=$(echo "$profiles2run" | grep -icw switch)
  zfs_in_profile=$(echo "$profiles2run" | grep -icw zfs)

  # Set RAT_LOCALONLY if we are running on cell or switch
  if [ $selected_profiles -eq "1" ] && [[ $cell_in_profile -gt "0" || $switch_in_profile -gt "0" || $zfs_in_profile -gt "0" ]] ; then
    RAT_LOCALONLY=1
    localonly=1;
  elif  [[ $selected_profiles -eq "2" && $cell_in_profile -gt "0"  &&  $switch_in_profile -gt "0" ]] ; then
    RAT_LOCALONLY=1
    localonly=1;
  elif  [[ $selected_profiles -eq "2" && $switch_in_profile -gt "0" && $zfs_in_profile -gt "0" ]] ; then
    RAT_LOCALONLY=1
    localonly=1;
  fi
  # Ask root password in case cell is not selected and root count=0
  if [[ $switch_in_profile -gt "0"  && $profile_cell_checks -eq "0" && $profile_root_checks -eq "0" ]] ; then
    profile_root_checks=1
  fi

  if [ $selected_profiles -eq "1" ] && [ $cell_in_profile -gt "0" ]
  then
    profile_root_checks=0
  fi # ignore cell root

  #if [[ $profile_switch_checks -gt "0"  && $profile_cell_checks -eq "0" ]] ; then
    #profile_cell_checks=1
  #  if [[ $selected_profiles -eq "1"  ]] ; then profile_root_checks=0; fi
  #fi
fi

# Target version
if [ -n "$targetversion" ]
then
  read_targetversion_count=1
  correct_target_version=0

  targetversion=$(echo $targetversion|sed 's/[A-Za-z]//g')
  targetversion=$(echo $targetversion|sed 's/\.//g') 
  if [ `echo $targetversion|wc -c` -ne 7 ] || [ `echo $supportedTargetVersion|grep -icw $targetversion` -lt 1 ]
  then 
      echo -e "${RED}\nInvalid upgrade target version format or upgrade version not yet supported.${NORM}\n"
      correct_target_version=0
  else 
      correct_target_version=1
  fi
  while [[ $read_targetversion_count -le 2 && $correct_target_version -eq 0 ]]
  do
    read_targetversion
    read_targetversion_count=$(expr $read_targetversion_count + 1)
  done
  if [ $correct_target_version -ne 1 ]; then cleanup;exit -1;fi
fi
if [ ! -e $REFFIL ]
then
# this reference file drives the entire script  if we can't find it then no use proceeding
    echo -e $RED"The reference data file cannot be found."$NORM
    echo -e $RED"Expected location - "${REFFIL}${NORM}
    exit 1
fi
#Following section to copy right executable at working directory
data_file_type=$(grep -ic FILE_ID $REFFIL)
if [ ! -e $EXADATA_CELL_COLLECTIONS ]; then touch $EXADATA_CELL_COLLECTIONS >/dev/null 2>&1;fi
if [[ -n "$data_file_type" && $data_file_type -le 0 ]]
then 
    if [ $cgrep_platform = "Linux" ]
    then 
	if [ -e /etc/redhat-release ] 
	then
	    os_version=$(cat /etc/redhat-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
            if [ $os_version -eq 3 ]
            then
                cp $SCRIPTPATH/.cgrep/lcgrep3 $WRKDIR/cgrep >/dev/null 2>&1
            elif [ $os_version -eq 4 ]
            then
               cp $SCRIPTPATH/.cgrep/lcgrep4 $WRKDIR/cgrep >/dev/null 2>&1
            elif [ $os_version -eq 5 ]
            then
                cp $SCRIPTPATH/.cgrep/lcgrep5 $WRKDIR/cgrep >/dev/null 2>&1
            elif [ $os_version -eq 6 ]
            then
                cp $SCRIPTPATH/.cgrep/lcgrep6 $WRKDIR/cgrep >/dev/null 2>&1 
            fi    
            #read -p "what_os=$what_os is_exalogic_machine=$is_exalogic_machine and os_version=$os_version"
	elif [ -e /etc/SuSE-release ] 
	then
	     os_version=$(cat /etc/SuSE-release|grep -v ^#|grep release|tr "[A-Z]" "[a-z]"|sed 's/[a-z]//g'|cut -d. -f1|cut -d'(' -f1|sed 's/ //g'|head -1)
             if [ -z "$os_version" ]; then os_version=$(cat /etc/SuSE-release|grep -i version|awk '{print $3}');fi
             if [ $os_version -eq 9 ]
             then
                 cp $SCRIPTPATH/.cgrep/lcgreps9 $WRKDIR/cgrep >/dev/null 2>&1    
             elif [ $os_version -eq 10 ]
             then
                 cp $SCRIPTPATH/.cgrep/lcgreps10 $WRKDIR/cgrep >/dev/null 2>&1
             elif [ $os_version -eq 11 ]
             then
                 cp $SCRIPTPATH/.cgrep/lcgreps11 $WRKDIR/cgrep >/dev/null 2>&1
             fi
	fi
        chmod 755 $WRKDIR/cgrep >/dev/null 2>&1
    elif [ $cgrep_platform = "SunOS" ]
    then
        if [ `uname -p` = "sparc" ]
        then
           cp $SCRIPTPATH/.cgrep/scgrep $WRKDIR/cgrep >/dev/null 2>&1
        elif [ `uname -p|grep -ic 86` -ge 1 ]
        then
           cp $SCRIPTPATH/.cgrep/scgrepx86 $WRKDIR/cgrep >/dev/null 2>&1
        fi 
        chmod 755 $WRKDIR/cgrep
    elif [ $cgrep_platform = "AIX" ]
    then 
        cp $SCRIPTPATH/.cgrep/acgrep $WRKDIR/cgrep >/dev/null 2>&1
        chmod 755 $WRKDIR/cgrep
    elif [ $cgrep_platform = "HP-UX" ]
    then
        cp $SCRIPTPATH/.cgrep/hiacgrep $WRKDIR/cgrep >/dev/null 2>&1
        chmod 755 $WRKDIR/cgrep

    #else
    #    echo -e "\n${RED}Error RC-001- Unable to read driver files. Please report this error to your Oracle representative for action.\n\nExiting .....\n${NORM}"
    #    exit 1;
    fi
    #cgrep_perm=$(ls -l cgrep |awk '{ print $1}'|grep -ic x)
    #if [ $cgrep_perm -le 0 ];then echo -e "\n${RED}Error RC-002 - cgrep is not executable. Please change permission to 755 for cgrep and run agian.\n\nExiting .....\n${NORM}";exit 1;fi;
    if [ ! -e $WRKDIR/cgrep ]
    then
        echo -e "\n${RED}RC-001- Unable to read driver files.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n ${program_name} exiting .....\n${NORM}"
        exit 1;
    fi
    export PATH=$PATH:. 
    cgrep_test=$($WRKDIR/cgrep FILE_ID $REFFIL>/dev/null 2>&1)
    if [ $? -ne 0 ]
    then
        #read -p "grep =$GREP cgrep_test=$cgrep_test"
        echo -e "\n${RED}RC-002- Unable to read driver files.  Please refer to the section for this error code in "Appendix A - Troubleshooting Scenarios" of the "${program_name} User Guide".\n\n ${program_name} exiting .....\n${NORM}"
        exit 1;
    fi
    GREP=$WRKDIR/cgrep
else 
    GREP=/bin/grep
fi


show_version
     #change this line before beta 
program_version="2.2.2.1"
if [ "$TYP" = "-v" ]
then 
   echo -e "\n$program_name  version: ${program_version}_${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[a-z]" "[A-Z]"
   cleanup
   exit 0
else
   show_version_envfile=$(echo "${program_name}_version = ${program_version}_${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[a-z]" "[A-Z]")  
   modelVersion=$(echo $show_version_envfile | awk -F"=" '{print $2}')
   validate_datafile_date
   #modelVersion=$(echo "${dataFIleYear}${dataFIleMonthNo}${dataFIleDay}"|tr "[:lower:]"  "[:upper:]")
fi
#follwoing check is to not to ru non storage server
if [ "$TYP" != "-f"  ]
then
    if [ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ]
    then 
       if [ -e  /opt/oracle/cell/cellsrv/deploy/config/cellinit.ora ]
       then
           echo -e "${RED}Running ${program_name} on Storage server is not supported.Please run it from compute node.${NORM}"
           exit 1
       fi
    fi
fi 
#######

components=$(echo $components|tr "[a-z]" "[A-Z]")
components=$(echo "$components"|sed 's/[:_,]/:/g'|sed 's/ /:/g')
#read -p "components=$components"
loop_components=$(echo $components|sed 's/:/ /g')
for loop_component in $loop_components
do
if [ `echo $supported_modules| grep -ic $loop_component` -lt 1 ]
then
    echo -e "${RED}${components} is not supported component. ${program_name} will run generic checks for components identified from environment${NORM}"
    unset options_components user_components
    if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] ; then read -p "Press any key to continue ...";fi
    components=NONE
fi
done
if [ "$upgrade_mode" -eq "2" ]
then
    read_targetversion_count=0
    while [[ $read_targetversion_count -le 2 && $correct_target_version -eq 0 ]]
    do
       read_targetversion
       read_targetversion_count=$(expr $read_targetversion_count + 1)  
    done
    if [ $correct_target_version -ne 1 ]; then cleanup;exit -1;fi
    user_components=PREUPGR 
elif [ "$upgrade_mode" -eq "3" ]
then
    user_components="RACCHECK:MAA:POSTUPGR"
fi 
#read -p "print_pass=$print_pass_on_screen and components=$user_components type=$TYP"
if [ "$TYP_S" = "-s" ]
then
   NOQUESTION="1"
   DOROOT="1"
   #TYP="-a"
   rootYesNoint=2
elif [ "$TYP_S" = "-S" ]
then
   NOQUESTION="1"
   DOROOT="0"
   #TYP="-a"
   rootYesNoint=3
   #if [ -z "$RAT_CELL_SSH_USER" ];then RAT_CELL_SSH_USER=cellmonitor;fi
   #if [ -e $CELLIP ]; then checkCellSshConfig "$RAT_CELL_SSH_USER";fi
else
   NOQUESTION="0"
fi

skip_in_silent=1
if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] ; then skip_in_silent=0; fi
if [[ -n "$NOQUESTION" && $NOQUESTION -eq 1 && $daemon_running -eq "1" ]] ; then skip_in_silent=0; fi

if [ -f "$REFFIL1" ]
then
    SILENT="0"
else
    SILENT="1"
    UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_collect_${FDS}
  #in case of SILENT mode, force $TYP to -a, 
  #ignore whatever command line argument the use may have used
    if [ "$TYP" != "-u" ]; then TYP="-a";fi
fi
#To unset ORACLE_HOME and CRS_HOME if  its running in non-interactive mode
if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]; then unset CRS_HOME ORACLE_HOME; fi;
#Code to set debug=0 if no environment varaiable is found 
if [ -z "$RAT_DEBUG" ]
then
    RAT_DEBUG=0
else
    RAT_DEBUG=1
fi
#change this line before beta
   # RAT_DEBUG=1
#following line to print info pass also in screen
RAT_INFOPASS=1
#########################################################################################
# To generate a text file in output directory. this text file will have node names in
#cluster and will be used to run the script in offline mode
#########################################################################################
#if [ $UID -eq 0 ]
#then
#   echo -e $RED"Script should not be executed as root user.rather its prefered to execute using software owner\n"$NORM
#   exit 1;
#fi



html_rack_type="Cluster";

#to find out what kind of data files will be processed either small or big one
file_mode=$(grep -c "DB_VERSION" $REFFIL)
if [[ -n "$file_mode" && $file_mode -ge 1 ]] 
then
   DBVERSION=$(grep "DB_VERSION" $REFFIL|awk '{print $3}')
   op_mode=0
else
   op_mode=1
fi
if [ $TYP = "-f" ]
then
    OFFLINE=1
    CURRDIR=`pwd`
    if [ -z $RAT_OUTPUT ]; then CURRDIR=$CURRDIR; else CURRDIR=$RAT_OUTPUT; fi; 
    DUMPDIR=`ls -ltr $CURRDIR|grep ^d|grep ${program_name}|tail -1|awk {' print $9'}`
    DUMPDIR=$CURRDIR/$DUMPDIR
    CHKFIL=`basename $MASTERFIL`
    #echo "$%%%%%%%%%%%%%DUMPDIR=$DUMPDIR%%%%%%%%%%%%%%%%%%%%"
    #read -p  "$DUMPDIR $MASTERFIL and $CHKFIL"
    if [ $# -gt 2 ] && [[ "$3" = "app" || "$3" = "App" || "$3" = "APP" ]]
    then
        echo "" > /dev/null 2&>1
    elif [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
      if [[ -n "$RAT_COMPUTEPASSWORD_INTERNAL" &&  $RAT_COMPUTEPASSWORD_INTERNAL -ne "3" ]] ; then
        read -r -s -p "Enter root password:" root_pass
        read -s -p "Start the run:" run_start
      fi
    else
	find $DUMPDIR -name $MASTERFIL 2> /dev/null
	if [ `find $DUMPDIR -name $CHKFIL |wc -l` -ne 1 ]
	then
            if [ `find $DUMPDIR -name check_env.out |wc -l` -ne 1 ]
            then
	        echo ""
	        read -p "Please specify the directory which has all files from customer site:-" DUMPDIR
            fi
	fi
	if [ -d "$DUMPDIR" ]
	then
	    read -p  "Output directory to read for offline use is ${DUMPDIR} Is this correct[y/n][y]" ynoutputdir
	    case  $ynoutputdir in
		y|Y|yes|YES|Yes)
		;;  
		n|N|No|NO)
		     echo ""  
		     read -p "Please specify the directory which has all files from customer site:-" DUMPDIR
	      ;;
	      *)
	      ;;
	   esac
	else
	   echo -e "Directory $DUMPDIR does not exists\n"
	   exit 1;
	fi
    fi
    #following statement is to copy files from all directories to OUTPUTDIR to support offline. At the end, it will move files back to directories
    if [ -e $DUMPDIR/.CELLDIR ]; then cp -r $DUMPDIR/.CELLDIR /tmp/ >/dev/null 2>&1;fi
    find $DUMPDIR -name '*.*' -type f -exec mv -f {} $DUMPDIR  \; >/dev/null 2>&1
    if [ -e /tmp/.CELLDIR ] ;then mv -f /tmp/.CELLDIR $DUMPDIR >/dev/null 2>&1;fi
    if [ -e $DUMPDIR/check_env.out ]; then mv $DUMPDIR/check_env.out $DUMPDIR/raccheck_env.out;fi
    outfilefds1=$(basename $DUMPDIR|cut -d_ -f2)
    outfilefds2=$(basename $DUMPDIR|cut -d_ -f3)
    outfilefds3=$(basename $DUMPDIR|cut -d_ -f4)
    outfilefds4=$(basename $DUMPDIR|cut -d_ -f5)
    if [ -n "$outfilefds4" ] ; then outfilefds3="${outfilefds3}_${outfilefds4}"; fi
    UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_${outfilefds1}_${outfilefds2}_${outfilefds3}
    #read -p "${UPLOADFIL} is the correct directory to analyze?[y/n][y]"
    HOSTLIST=$DUMPDIR/o_host_list.out
    OUTPUTDIR=$DUMPDIR
    SPOOLFIL=$OUTPUTDIR/d_check.out
    OSOUTFIL=$OUTPUTDIR/o_check
    UPDATEFIL=$OUTPUTDIR/db_update_$FDS.sql
    SQLLOGFIL=$OUTPUTDIR/sql.log
    napply_missing_list=$OUTPUTDIR/o_napply_missing_list.out
    if [[ -z "$RAT_RUNMODE_INTERNAL" ]] ; then
      LOGFIL=/dev/null
      SKIPFIL=/dev/null
      REPFIL=/dev/null
      XMLREPFIL=/dev/null
      XMLSKIPFIL=/dev/null
      SREPFIL=/dev/null
      REPFIL_PASS=/dev/null
      SREPFIL_PASS=/dev/null
      REPFIL_FAIL=/dev/null
      SREPFIL_FAIL=/dev/null
      PREPFIL=/dev/null
      PSREPFIL=/dev/null
      CWCREPFIL_PASS=/dev/null
      SCWCREPFIL_PASS=/dev/null
      CWCREPFIL_FAIL=/dev/null
      SCWCREPFIL_FAIL=/dev/null
      CWSQLPARAM=/dev/null
      CWOSPARAM=/dev/null
      CWOSPKG=/dev/null
      CWOSPATCH=/dev/null
      MISCCWCHECK=/dev/null
    elif [[ $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
      hostname | cut -d"." -f1 > $HOSTLIST
      #LOGFIL=$OUTPUTDIR/${program_name}.log
    fi
    CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
    CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
    CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
    CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
    IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
    IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
    IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
    IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
    ASM_HOME=`grep ASM_HOME $DUMPDIR/$CHKFIL |awk '{print $3}'`
    RUNMODE=`grep SILENT $DUMPDIR/$CHKFIL |awk '{print $3}'`
    RUNSWITCH=`grep -w SWITCH $DUMPDIR/$CHKFIL |awk '{print $3}'`
    RUNFILEID=`grep FILE_ID $DUMPDIR/$CHKFIL |awk '{print $3}'`
    FILEID=`$GREP FILE_ID $REFFIL |awk '{print $3}'`
    FILEID2=`$GREP FILE_ID $REFFIL1 |awk '{print $3}'|head -1`
    FILESIG=`grep FILE_SIG $DUMPDIR/$CHKFIL|awk '{print $3 }'`
    crs_installed=`grep CRS_INSTALLED $DUMPDIR/$CHKFIL |awk '{print $3}'`
    rdbms_installed=`grep RDBMS_INSTALLED $DUMPDIR/$CHKFIL |awk '{print $3}'`
    crs_up=`grep CRS_UP $DUMPDIR/$CHKFIL |awk '{print $3}'`
    db_up=`grep ${ORACLE_SID}_UP $DUMPDIR/$CHKFIL |awk '{print $3}'`
    somdb_up=`grep SOMEDB_UP $DUMPDIR/$CHKFIL |awk '{print $3}'`
    localnode=`grep LOCALNODE $DUMPDIR/$CHKFIL |awk '{print $3}'`
    rootYesNoint=`grep ROOT_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}'`
    multiple_db=$(grep MULTIPLE_DATABASE $DUMPDIR/$CHKFIL |awk '{print $3}')
    components=$(grep ${localnode}.COMPONENTS $DUMPDIR/$CHKFIL |awk '{print $3}')
    if [[ -n "$RUNSWITCH" && $RUNSWITCH = "-u" ]]; then upgrade_mode=$(grep UPGRADE_MODE $DUMPDIR/$CHKFIL |awk '{print $3}');fi
    CRS=$(grep CRS_HOME $DUMPDIR/$CHKFIL |awk '{print $3}')
    ibswitch_password_status=$(grep IBSWITCH_PASSWORD_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}')
    cell_password_status=$(grep CELL_PASSWORD_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}')
    zfs_password_status=$(grep ZFS_PASSWORD_OPTION $DUMPDIR/$CHKFIL |awk '{print $3}')
    current_exadata_version=$(grep CURRENT_EXADATA_VERSION $DUMPDIR/$CHKFIL |awk '{print $3}')
    print_score_in_report=$(grep PRINT_SCORE_IN_REPORT $DUMPDIR/$CHKFIL |awk '{print $3}')
    offline_counter=0
    wrong_customer_id_tries=0
    mb_db_counter=0
    CELLDIR="$OUTPUTDIR/.CELLDIR"
    CELLIP="$CELLDIR/cellip.ora"   
    ZFSIP="$CELLDIR/zfsip.ora"   
    is_exalogic_machine=`grep IS_EXALOGIC_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'` 
    in_ec_exalogic=`grep IS_EXALOGIC_EC_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`
    exalogic_version=`grep EXALOGIC_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
    exalogic_version_actual=`grep EXALOGIC_ACTUAL_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
    RackIdentifier=`grep EXALOGIC_RACK_IDENTIFIER $DUMPDIR/$CHKFIL | sed 's/EXALOGIC_RACK_IDENTIFIER = //'`
    is_exalytics_machine=`grep IS_EXALYTICS_MACHINE $DUMPDIR/$CHKFIL | awk '{print $3}'`
    exalytics_version=`grep EXALYTICS_VERSION $DUMPDIR/$CHKFIL | awk '{print $3}'`
    RackIdentifier=`grep EXALYTICS_RACK_IDENTIFIER $DUMPDIR/$CHKFIL | sed 's/EXALYTICS_RACK_IDENTIFIER = //'`
    crs112=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "11.2"`
    crs121=`grep CRS_ACTIVE_VERSION $DUMPDIR/$CHKFIL | head -1 |grep -c "12.1"`
 #function to discover and support mixed hardware type storage servers
    mixed_hardware_cells_discovery 
    if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`;fi
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
    then
      func_init_arrays
      multiple_db=0
      mb_running_host[0]=0;
    fi
    if [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
    then
      func_init_arrays
      multiple_db=0
      mb_running_host[0]=0;
      read_exalytics_bi_env
    fi
    single_instance_run=`grep SINGLE_INSTANCE_RUN $DUMPDIR/$CHKFIL | awk '{print $3}'`
    for db_name_to_check in `cat $DUMPDIR/$CHKFIL|grep -i DB_NAME|awk '{print $3}'|cut -d'|' -f1`
    do
      mb_db_names[$mb_db_counter]=$db_name_to_check
      mb_database_role[$mb_db_counter]=$(grep "${db_name_to_check}.DATABASE_ROLE" $DUMPDIR/$CHKFIL|awk '{print $3}')
      mb_database_type[$mb_db_counter]=$(grep "${db_name_to_check}.DATABASE_TYPE" $DUMPDIR/$CHKFIL|awk '{print $3}')
      mb_running_host[$mb_db_counter]=$(grep "${db_name_to_check}.CHECKED_NODE" $DUMPDIR/$CHKFIL|awk '{print $3}')
      #echo "${mb_database_role[$mb_db_counter]}"
      mb_db_counter=$(expr $mb_db_counter + 1 )
    done
    mb_db_counter=0 
    #read -p "stop"
    for node in `cat $HOSTLIST`
    do
      crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $DUMPDIR/$CHKFIL |awk '{print $3}'`
      rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $DUMPDIR/$CHKFIL |awk '{print $3}'`
      asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $DUMPDIR/$CHKFIL |awk '{print $3}'`
      stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $DUMPDIR/$CHKFIL |awk '{print $3}'`
      stack_crs_version[$offline_counter]=`grep -i "$node.CRS_ACTIVE_VERSION" $DUMPDIR/$CHKFIL |awk '{print $3}'`
      stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $DUMPDIR/$CHKFIL |awk '{print $3}'`
      stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $DUMPDIR/$CHKFIL |awk '{print $3}'`
      stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $DUMPDIR/$CHKFIL |awk '{print $3}'`
      stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $DUMPDIR/$CHKFIL |awk '{print $3}'`
      if [ $multiple_db -eq 1 ]
      then
          db_status_counter=0
          mb_db_counter_local=0
          stack_db_instances[$offline_counter]=`grep -i "$node" $DUMPDIR/$CHKFIL|grep INSTANCE_NAME|awk '{print $3}'`
          #echo "instances on $node ${stack_db_instances[$offline_counter]}"
          for db_name_to_check in "${mb_db_names[@]}"
          do
             if [ $node = ${mb_running_host[$mb_db_counter_local]} ]
             then #remote_database_code
                 stack_db_status[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $DUMPDIR/$CHKFIL|awk '{print $3}'`
                 stack_local_db_inst[$mb_db_counter_local]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $DUMPDIR/$CHKFIL|awk '{print $3}'`
                 #stack_db_name[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
#                echo "$db_name_to_check instance is  ${stack_local_db_inst[$db_status_counter]}"
                 db_status_counter=$(expr $db_status_counter + 1)
             fi
             mb_db_counter_local=$(expr $mb_db_counter_local + 1)
          done
          db_status_counter=0
      else
        stack_dbinst_name[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_NAME" $DUMPDIR/$CHKFIL|awk '{print $3}'`
        if [[ -n "${mb_running_host[$mb_db_counter_local]}" && $node = ${mb_running_host[$mb_db_counter_local]} ]]
        then
            stack_db_status[$db_status_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $DUMPDIR/$CHKFIL|awk '{print $3}'`
            #read -p " stack_db_status=${stack_db_status[$db_status_counter]}"
        fi;
        stack_dbinst_up[$offline_counter]=`grep -i "$node.${db_name_to_check}.INSTANCE_MODE"  $DUMPDIR/$CHKFIL|awk '{print $3}'`
      fi
      offline_counter=`expr $offline_counter + 1`  
    done
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
    then
      func_init_arrays
        components=EXALOGIC
    fi
    mb_set_oracle_home_version_distinct
    #is_this_db_machine
    write_db_machine_info_to_envfile $localnode
    GetMachineRole
    is_this_oda
    if [[ `echo $components|grep -icw dbm` -ge 1 && `echo $components|grep -ic rdbms` -lt 1 && $db_machine_compute -eq 1 ]]
    then
        components=EXADATA
    fi
    #read -p "components=$components at 8490"
    #echo "${mb_oracle_homes_distinct[@]} ${mb_oracle_versions_distinct[@]} ${mb_oracle_homes_version_distinct[@]}"
    #read -p "see it"
    offline_counter=0
    if [ $op_mode -eq 1 ]
    then
        func_create_small_files
    fi
    if [[ $RUNSWITCH != "-p" && ${stack_dbinst_up[$offline_counter]} -ne 0 ]]
    then
         DB=$(grep -i "DB_NAME" $DUMPDIR/$CHKFIL |awk '{print $3}'|cut -d'|' -f1|cut -d'|' -f1)
        #DB=`grep db_name $SPOOLFIL |awk {'print $3'}`
    fi
    #FILESIG=`echo $FILESIG |sed -e 's/ /g'`
    if [ $RUNMODE -eq "1" ]
    then
        MISCCWCHECK=$OUTPUTDIR/o_misc_clusterwide_checks.out
        REPFIL=$OUTPUTDIR/${program_name}.rep
        XMLREPFIL=$OUTPUTDIR/${program_name}_results.xml
        XMLSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.xml
        SREPFIL=$OUTPUTDIR/${program_name}_summary.rep
        REPFIL_PASS=$OUTPUTDIR/${program_name}_pass.rep
	REPFIL_FAIL=$OUTPUTDIR/${program_name}_fail.rep
	SREPFIL_PASS=$OUTPUTDIR/${program_name}_summary_pass.rep
	SREPFIL_FAIL=$OUTPUTDIR/${program_name}_summary_fail.rep
	CWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_pass.rep
	SCWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_summary_pass.rep
	CWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_fail.rep
	SCWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_summary_fail.rep
	PREPFIL=$OUTPUTDIR/${program_name}_patches.rep
	PSREPFIL=$OUTPUTDIR/${program_name}_patches_summary.rep
        CWSQLPARAM=$OUTPUTDIR/${program_name}_cw_sqlparam.out
        CWOSPARAM=$OUTPUTDIR/${program_name}_cw_osparam.out
        CWOSPKG=$OUTPUTDIR/${program_name}_cw_ospkg.out
        CWOSPATCH=$OUTPUTDIR/${program_name}_cw_ospatch.out
        CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
        CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
        CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
        CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
        IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
        IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
        IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
        IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
        SKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks.log
     
   #to fix the bug reported by Srini. if user runs raccheck in offline for more than, report will have data for more than 1
        if [ -f $REPFIL ]; then rm $REPFIL;fi;
        if [ -f $XMLREPFIL ]; then rm $XMLREPFIL;fi;
        if [ -f $XMLSKIPFIL ]; then rm $XMLSKIPFIL;fi;   
	if [ -f $SREPFIL ]; then rm $SREPFIL; fi;
	if [ -f $SCWCREPFIL_FAIL  ]; then rm $SCWCREPFIL_FAIL; fi;
	if [ -f $SREPFIL_FAIL ]; then rm $SREPFIL_FAIL; fi;
	if [ -f $SCWCREPFIL_PASS ]; then rm $SCWCREPFIL_PASS; fi;
	if [ -f $SREPFIL_PASS ]; then rm $SREPFIL_PASS; fi;
	if [ -f $CWCREPFIL_FAIL ]; then rm $CWCREPFIL_FAIL; fi;
	if [ -f $REPFIL_FAIL ]; then rm $REPFIL_FAIL; fi;
	if [ -f $CWCREPFIL_PASS ]; then rm $CWCREPFIL_PASS; fi;
	if [ -f $REPFIL_PASS ]; then rm $REPFIL_PASS; fi;
	if [ -f $PREPFIL ]; then rm $PREPFIL; fi;
	if [ -f $PSREPFIL ]; then rm $PSREPFIL; fi;
	if [ -f $CWSQLPARAM ]; then rm $CWSQLPARAM; fi;
	if [ -f $CWOSPARAM ]; then rm $CWOSPARAM; fi;
	if [ -f $CWOSPKG ]; then rm $CWOSPKG; fi;
	if [ -f $CWOSPATCH ]; then rm $CWOSPATCH; fi;
	if [ -f $MISCCWCHECK ]; then rm $MISCCWCHECK; fi;
        if [ -f $CELLSREPFIL_PASS ]; then rm $CELLSREPFIL_PASS;fi
        if [ -f $CELLSREPFIL_FAIL ]; then rm $CELLSREPFIL_FAIL;fi
        if [ -f $CELLREPFIL_PASS ]; then rm $CELLREPFIL_PASS;fi
        if [ -f $CELLREPFIL_FAIL ]; then rm $CELLREPFIL_FAIL;fi
        if [ -f $IBSREPFIL_PASS ]; then rm $IBSREPFIL_PASS;fi
        if [ -f $IBSREPFIL_FAIL ]; then rm $IBSREPFIL_FAIL;fi
        if [ -f $IBREPFIL_PASS ]; then rm $IBREPFIL_PASS;fi
        if [ -f $IBREPFIL_FAIL ]; then rm $IBREPFIL_FAIL;fi
        if [ -f $SKIPFIL ]; then rm $SKIPFIL;fi
    fi
    echo  "RUNFILEID=$RUNFILEID FILEID=$FILEID AND FILEID2=$FILEID2">>$LOGFIL
    #read -p  "RUNFILEID=$RUNFILEID FILEID=$FILEID AND FILEID2=$FILEID2"
    #read -p "check fileids"
    if [ "$RUNFILEID" !=  "$FILEID" ]
    then
        echo -e "$RED Data file $REFFIL is not same file which was used by customer.$NORM"
        exit -1;
    fi
    if [ "$RUNFILEID" !=  "$FILEID2" ]
    then
        echo -e "$RED Data file $REFFIL1 is not same file which should be used with this collection.$NORM"
        exit -1;
    fi
    stack_counter=0
    no_patch_rollup=0 
    no_patch_rollup=`grep -ic "NO Patch rollup selected" $REFFIL1`
    if [ $no_patch_rollup -gt 0 ]
    then
        no_patches=1
    fi
  #code for entering correct custmer id in racrx_env.
    #if [ $RUNMODE -eq 1 ] && [ "$FILESIG" = "46C40115700EFB00E0401490CACF67C6" -o "$FILESIG" = "632427F6919907D9E0401490CACF59F0" ] 
    if [ $# -gt 2 ] && [[ "$3" = "app" || "$3" = "App" || "$3" = "APP" ]]
    then
        echo "" > /dev/null 2&>1
    else
	if [ "$FILESIG" = "46C40115700EFB00E0401490CACF67C6" -o "$FILESIG" = "632427F6919907D9E0401490CACF59F0" ] && [ 1 -eq 0 ]
	then
	   read -p "Enter Customer ID from RAT Customer page (Customer Tab > Customer Details region):- " customerid
	   while true
	   do
	     if [ `echo $customerid|wc -c` -ne 33 ]
	     then
		 echo -e "${RED}Customer ID is not correct.Enter Customer ID from RAT Customer page (Customer Tab > Customer Details region):-${NORM}"
		 read  customerid
	     fi
	     wrong_customer_id_tries=$(expr $wrong_customer_id_tries + 1)
	     if [[ $wrong_customer_id_tries -gt 1 || `echo $customerid|wc -c` -eq 33 ]];then break;fi;
	   done
	   custfile="$DUMPDIR/$CHKFIL" 
	   sed "s/$FILESIG/$customerid/" $custfile > $DUMPDIR/fileid.out
	   cp $DUMPDIR/fileid.out $custfile
	   rm $DUMPDIR/fileid.out
	fi
    fi
    #echo "$%%%%%%%%%%%%%RUNMODE=$RUNMODE%%%%%%%%%%%%%%%%%%%%" 
    #echo "$%%%%%%%%%%%%%FREPFIL=$FREPFIL%%%%%%%%%%%%%%%%%%%%" 
else 
    # Exalogic check
  OFFLINE=0
  check_if_exalytics
  check_if_exalogic
  #moved this validation from top to here is because Solaris express is supported in EL
  if [[ $is_exalogic_machine -eq 0 && "`uname -v`" = "snv_151a" ]]
  then
    echo -e "\n${RED}The ${program_name} is not supported on Solaris 11 Express. ${NORM}\n"
    exit 1;
  fi

  if [[ $is_exalogic_machine -eq "1" && $USER != "root" ]] || [[ $is_exalytics_machine -eq "1" && $USER != "root" ]]
  then
    echo "*********** Error: User must be root"
    exit;
  elif [ $is_exalogic_machine -eq "1" ]
  then
    #echo "*********** Running in a exalogic machine and user is fine"
    echo ""
  fi

    stack_counter=0
    if [ ! -d "$WRKDIR" ]
    then
        mkdir -p $WRKDIR
    fi
    if [ $# -lt 1 ]; then RUNSWITCH="-a";else  RUNSWITCH=$1;fi
    mkdir $INPUTDIR
    mkdir $OUTPUTDIR
    if [ ! -d $RTEMPDIR ]; then mkdir -p $RTEMPDIR>/dev/null 2>&1;fi
    fmt_timing_lines="--------------------------------------------------------------------------------"
    echo -e "$fmt_timing_lines\n" >>$RACCHECK_TIMING
    echo -e "`date '+%a %b %d %H:%M:%S %Y'` - ${program_name} execution started\n">>$RACCHECK_TIMING
    trap 'cleanup;exit $USER_INTERRUPT' INT TERM EXIT
    localnode=`hostname | tr "[A-Z]" "[a-z]"|cut -d. -f1`
    userid=$UID
   if [[ $op_mode -eq 1 && -z "$RAT_OS" ]] 
   then  
        func_what_platform
        if [[  -z "$os_name" || -z "$os_arch" || -z "$os_bit" || -z "$os_version" ]]
        then 
            echo -e "\n${RED}${program_name} could not find enough information about Operating system. Please set RAT_OS environment variable as following and re-run it.${NORM}"
            echo -e "\nValue in RAT_OS for Oracle Enterprise Linux 5 will be like LINUXX8664OELRHEL5 or for Solaris 10 on Sparc will be SOLARISSPARC6410"
            echo -e "\nTo construct correct value for RAT_OS, use following piece of OS information"
            echo -e "\nOS Name=LINUX \nOS Architecture=X86 or IA \nBits either 32 or 64 OS version=4 \nOS type in case of Linux like RHELOEL or SUSE etc"
            exit 1
        fi
   else
       what_os=$RAT_OS 
   fi
    
fi

if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
  cp $DUMPDIR/../.input*/*.dat $DUMPDIR/
  WATCHDOG=$DUMPDIR/watchdog.sh
  WATCHLOG=$DUMPDIR/watchdog.log
  REFFIL=$DUMPDIR/collections.dat
  userid=$UID
  LOGFIL=$DUMPDIR/${program_name}.log
  LOGFIL=$DUMPDIR/${program_name}.log
  SKIPFIL=$DUMPDIR/${program_name}_skipped_checks.log
  REPFIL=$DUMPDIR/${program_name}.rep
  XMLREPFIL=$DUMPDIR/${program_name}_results.xml
  XMLSKIPFIL=$DUMPDIR/${program_name}_exceptions.xml
  ERRFIL=$DUMPDIR/${program_name}_error.log
  COLLECT_TIMING=$DUMPDIR/${program_name}_collection_timings.out
  CHECKS_TIMING=$DUMPDIR/${program_name}_checks_timings.out
  RACCHECK_TIMING=$DUMPDIR/${program_name}_timings.out
  MISCCWCHECK=$OUTPUTDIRDUMPDIRo_misc_clusterwide_checks.out
fi
log_env_varaibles "RAT_TIMEOUT" "$RAT_TIMEOUT"
log_env_varaibles "RAT_ROOT_TIMEOUT" "$RAT_ROOT_TIMEOUT"
log_env_varaibles "RAT_SQL_TIMEOUT" "$RAT_SQL_TIMEOUT"
log_env_varaibles "RAT_UPLOAD_CONNECT_STRING" "$RAT_UPLOAD_CONNECT_STRING"
log_env_varaibles "RAT_UPLOAD_TABLE" "$RAT_UPLOAD_TABLE"
log_env_varaibles "RAT_PATCH_UPLOAD_TABLE" "$RAT_PATCH_UPLOAD_TABLE"
log_env_varaibles "RAT_UPLOAD_USER" "$RAT_UPLOAD_USER"
log_env_varaibles "RAT_UPLOAD_PASSWORD" "$RAT_UPLOAD_PASSWORD"
log_env_varaibles "RAT_UPLOAD_ORACLE_HOME" "$RAT_UPLOAD_ORACLE_HOME"
log_env_varaibles "RAT_CRS_HOME" "$RAT_CRS_HOME"
log_env_varaibles "RAT_INV_LOC" "$RAT_INV_LOC"
log_env_varaibles "RAT_ORACLE_HOME" "$RAT_ORACLE_HOME"
log_env_varaibles "RAT_ASM_HOME" "$RAT_ASM_HOME"
log_env_varaibles "RAT_OS" "$RAT_OS"
log_env_varaibles "RAT_DB" "$RAT_DB"
log_env_varaibles "RAT_DBNAMES" "$RAT_DBNAMES" "1"
log_env_varaibles "RAT_PDBNAMES" "$RAT_PDBNAMES" "1"
log_env_varaibles "RAT_DBHOMES" "$RAT_DBHOMES" 
log_env_varaibles "RAT_OUTPUT" "$RAT_OUTPUT"
log_env_varaibles "RAT_DEBUG" "$RAT_DEBUG"
log_env_varaibles "RAT_INFOPASS" "$RAT_INFOPASS"
log_env_varaibles "RAT_SCOPY" "$RAT_SCOPY"
log_env_varaibles "RAT_SSHEL" "$RAT_SSHELL"
log_env_varaibles "RAT_LOCAL" "$RAT_LOCAL"
log_env_varaibles "RAT_CELLS" "$RAT_CELLS" "1"
log_env_varaibles "RAT_ZFS_NODES" "$RAT_ZFS_NODES" "1"
log_env_varaibles "RAT_CLUSTERNODES" "$RAT_CLUSTERNODES" "1"
log_env_varaibles "RAT_IBSWITCHES" "$RAT_IBSWITCHES" "1"
log_env_varaibles "RAT_CELL_SSH_USER" "$RAT_CELL_SSH_USER"
log_env_varaibles "RAT_IBSWITCH_USER" "$RAT_IBSWITCH_USER"
log_env_varaibles "RAT_EXPECT_STRACE_DEBUG" "$RAT_EXPECT_STRACE_DEBUG"
log_env_varaibles "RAT_EXPECT_DEBUG" "$RAT_EXPECT_DEBUG"
log_env_varaibles "RAT_PDB_USER" "$RAT_PDB_USER"


if [[ $OFFLINE -eq "0" ]] || [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] ; then
   assign_scr_switches;
  
# foloowing code is to generate watcher script
    if [ -f "/opt/oracle.cellos/ORACLE_CELL_OS_IS_SETUP" ];then watchdog_dbm_root=1;else watchdog_dbm_root=0;fi 
    if [ -z "$RAT_TIMEOUT" ]
    then
       watchdog_wakeup=`grep RACCHECK_TIMEOUT $REFFIL|awk '{print $3}'` 
       if [ -z "$watchdog_wakeup" ]; then watchdog_wakeup=90;fi
    else
       watchdog_wakeup=$RAT_TIMEOUT    
    fi 
    if [ -z "$RAT_ROOT_TIMEOUT" ]
    then
        watchdog_wakeup_root=300
    else
        watchdog_wakeup_root=$RAT_ROOT_TIMEOUT
    fi
    if [ -z "$RAT_SQL_TIMEOUT" ]
    then
        watchdog_wakeup_sql=180
    else
        watchdog_wakeup_sql=$RAT_SQL_TIMEOUT
    fi 
    echo -e "RAT_TIMEOUT=$RAT_TIMEOUT watchdog_wakeup=$watchdog_wakeup watchdog_wakeup_root=$watchdog_wakeup_root watchdog_wakeup_sql=$watchdog_wakeup_sql">>$LOGFIL
    #watchlogdate=$(date '+%a %b %d %H:%M:%S %Y')
    touch $RTEMPDIR/nowatch.pid
    echo "#!$bash_scr" > $WATCHDOG  
    echo "watchdog_wakeup=$watchdog_wakeup">>$WATCHDOG
    echo "watchdog_wakeup_root=$watchdog_wakeup_root">>$WATCHDOG
    echo "watchdog_wakeup_sql=$watchdog_wakeup_sql">>$WATCHDOG
    echo "wakeup_count=1">>$WATCHDOG
    echo "watchdog_dbm_root=$watchdog_dbm_root">>$WATCHDOG
    echo "watchdog_long_wakeup=1">>$WATCHDOG
    echo "ppid=$$">>$WATCHDOG
    echo "mypid=\$\$">>$WATCHDOG
    echo "function killtree() {" >> $WATCHDOG #http://stackoverflow.com/questions/392022/best-way-to-kill-all-child-processes
    echo "  local _pid=\$1" >> $WATCHDOG
    echo "  local _sig=\${2-TERM}" >> $WATCHDOG
    echo "  kill -stop \${_pid}" >> $WATCHDOG
    #echo "  for _child in \$(ps -o pid --no-headers --ppid \${_pid}); do " >> $WATCHDOG
    echo "  for _child in \$(ps -ef |awk '\$3 == '\${_pid}' {print \$2}'); do " >> $WATCHDOG
    echo "    killtree \${_child} \${_sig}" >> $WATCHDOG
    echo "  done" >>$WATCHDOG
    echo "  kill -\${_sig} \${_pid}" >> $WATCHDOG
    echo "}" >> $WATCHDOG
    echo "echo \"\`date '+%a %b %d %H:%M:%S %Y'\` started watcher\" >$WATCHLOG">>$WATCHDOG
    #echo "echo \" mypid=\$mypid\"">>$WATCHDOG
    #echo "echo \"Process id of gracrx is \$ppid and log file is $WATCHLOG\"">>$WATCHDOG     
    echo "while [ 1 ]">>$WATCHDOG
    echo "do">>$WATCHDOG
    #echo "  lpid=\$(ps -p \$ppid|grep -v PID|awk '{print \$1}')">>$WATCHDOG
    ps -o pid >/dev/null 2>&1
    ps_o_ret=$?
    if [[ -n "$ps_o_ret" && $ps_o_ret -eq 0 ]] ; then
      echo "  lpid=\$(ps -o pid -p \$ppid|grep -v PID)">>$WATCHDOG
    else
      echo "  lpid=\$(ps -f -p  \$ppid|grep -v PID | awk '{print \$2}')">>$WATCHDOG
    fi
    echo "  if [ -z \$lpid ]">>$WATCHDOG
    echo "  then">>$WATCHDOG
    #echo "      echo -e \"Darwin is not running\\nexiting...\">>$WATCHLOG">>$WATCHDOG 
    echo "      for inputrmfile in \$(ls $INPUTDIR/* >/dev/null 2>&1|grep -v watchdog.sh)">>$WATCHDOG 
    echo "      do">>$WATCHDOG 
    echo "        rm -f \$inputrmfile >/dev/null 2>&1">>$WATCHDOG 
    echo "      done">>$WATCHDOG 
    echo "      exit 0">>$WATCHDOG
    echo "  else">>$WATCHDOG
    #echo "     if [[ -n \"\$opid\"  && \$opid -gt 1 ]]">>$WATCHDOG
    echo "     if [ -n \"\$opid\" ]">>$WATCHDOG
    echo "     then">>$WATCHDOG
    echo "     if [ \`echo \$opid|wc -w\` -gt 1 ];then opid=\$(echo \$opid|awk '{print \$1}');fi">>$WATCHDOG
    #echo "         spid=\$(ps -o pid -p \$opid >>$WATCHLOG 2>/dev/null|grep -v PID|sed 's/^ *\(.*\) *$/\1/')">>$WATCHDOG
    if [[ -n "$ps_o_ret" && $ps_o_ret -eq 0 ]] ; then
      echo "         spid=\$(ps -o pid -p \$opid|grep -v PID |sed 's/^ *\(.*\) *$/\1/')">>$WATCHDOG
    else
      echo "         spid=\$(ps -f -p \$opid|grep -v PID |  awk '{print \$2}' | sed 's/^ *\(.*\) *$/\1/')">>$WATCHDOG
    fi
    echo "         if [[ -n \"\$spid\" && \"\$spid\" -eq \"\$opid\" && \`grep -wc \"\$spid\" $RTEMPDIR/nowatch.pid 2>/dev/null\` -eq 0 ]] ">>$WATCHDOG
    echo "         then">>$WATCHDOG
    #echo "             scmd=\$(ps -ef|grep \$opid|grep -v grep|awk ' { print \$8 }')">>$WATCHDOG
    echo "             echo \"\`date '+%a %b %d %H:%M:%S %Y'\` candidate pid opid=\$opid still found as spid=\$spid\">>$WATCHLOG">>$WATCHDOG
    echo "             for cpid in \$(ps -ef |awk '\$3 == '\${spid}' {print \$2}') ">>$WATCHDOG        
    echo "             do">>$WATCHDOG
    echo "               if [[ \`grep -wc \"\$cpid\" $RTEMPDIR/nowatch.pid 2>/dev/null\` -eq 0 ]] ">>$WATCHDOG
    echo "               then">>$WATCHDOG
    echo "                  if [ \"$(/bin/uname -s)\" = \"Linux\" ]">>$WATCHDOG
    echo "                  then">>$WATCHDOG
    echo "                      scmd=\$(ps -o command -p \$opid |grep -v COMMAND)">>$WATCHDOG
    echo "                      ccmd=\$(ps -o command -p \$cpid |grep -v COMMAND)">>$WATCHDOG
    echo "                  fi">>$WATCHDOG
    echo "                  echo \"\`date '+%a %b %d %H:%M:%S %Y'\` Stuck child pid \$cpid  of parent \$spid\">>$WATCHLOG">>$WATCHDOG
    echo "                  echo \"\`date '+%a %b %d %H:%M:%S %Y'\` Stuck child command is \$ccmd\">>$WATCHLOG">>$WATCHDOG
    echo "                  killtree \$cpid 9 >>$WATCHLOG 2>&1">>$WATCHDOG
    echo "               fi">>$WATCHDOG
    echo "             done">>$WATCHDOG
    echo "             echo \"\`date '+%a %b %d %H:%M:%S %Y'\` killing stuck command \$scmd . Operating system process ID \$opid \">>$WATCHLOG">>$WATCHDOG
    echo "             kill -9 \$spid >>$WATCHLOG 2>&1">>$WATCHDOG
    echo "         fi">>$WATCHDOG
    echo "     fi">>$WATCHDOG
    echo "  fi">>$WATCHDOG
    echo "  if [ -e $WATCHLOG ];then  echo \"\`date '+%a %b %d %H:%M:%S %Y'\` running watcher \$wakeup_count \" >>$WATCHLOG;fi">>$WATCHDOG
    echo "  wakeup_count=\`expr \$wakeup_count + 1\`">>$WATCHDOG  
    #echo "  for opid in \`ps -ef|grep -v \"watchdog.sh\"| awk '\$3 == '\${ppid}' { print \$2 }'\`">>$WATCHDOG
    #echo "  opid=\$(ps -ef|grep -v \${mypid}|grep -v sleep |grep -v compute| awk '\$3 == '\${ppid}' { print \$2 }')">>$WATCHDOG
     echo "  opid_long=\"\";opid=\"\";for oop in \$(ps -ef|grep -v \${mypid}|grep -v sleep |grep -v compute| awk '\$3 == '\${ppid}' { print \$2 }'); do if [[ \`grep -wc \"\$oop\" $RTEMPDIR/nowatch.pid 2>/dev/null\` -eq "0" ]] ; then opid=\"\$opid \$oop\"; if [ -z \"\$opid_long\" ] ; then opid_long=\$oop; fi; fi; done">>$WATCHDOG
    #echo "  opid_long=\$(ps -ef|grep -v \${mypid}|grep -v sleep |grep -v compute | awk '\$3 == '\${ppid}' { print \$2 }'|head -1)">>$WATCHDOG
    echo "  if [ -n \"\$opid\" ]; then ocomm_name=\$( ps -p \$opid_long -o command 2>/dev/null|grep -vi command|awk -F/ '{print \$NF}');fi">>$WATCHDOG
    #echo "  echo ocomm_name=\$ocomm_name">>$WATCHDOG
    echo "  if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` candidate child pid for killing is \$opid - \$ocomm_name \" >>$WATCHLOG;fi">>$WATCHDOG
    #echo "  do">>$WATCHDOG 
    #echo "     opid=\$opid">>$WATCHDOG
    #echo "  done">>$WATCHDOG
    echo "  found_raccheck_sql=\$(echo \$ocomm_name|grep -c \"exec_raccheck_sqls\")">>$WATCHDOG
    echo "  found_raccheck_root=\$(echo \$ocomm_name|grep -c \"root_${program_name}\")">>$WATCHDOG
    echo "  found_raccheck_cells=\$(echo \$ocomm_name|grep -c \"${program_name}_cells\")">>$WATCHDOG
    echo "  found_raccheck_root_samepassword=\$(echo \$ocomm_name|grep -c \"expect -f\")">>$WATCHDOG
    echo "  if [[ -n \"\$found_raccheck_sql\" && \$found_raccheck_sql -ge 1 && \$watchdog_long_wakeup -eq 1 ]]">>$WATCHDOG
    echo "  then">>$WATCHDOG
    #echo "      watchdog_long_wakeup=0">>$WATCHDOG
    #echo "      echo \$watchdog_wakeup_sql">>$WATCHDOG
    echo "if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` watcher sleeping for \$watchdog_wakeup_sql seconds \" >>$WATCHLOG;fi">>$WATCHDOG
    echo "       sleep \$watchdog_wakeup_sql">>$WATCHDOG
    #echo "  elif [[ \$watchdog_long_wakeup -eq 1 && \$watchdog_dbm_root -eq 1 ]] && [[ -n \"\$found_raccheck_root\" && \$found_raccheck_root -ge 1 || -n \"\$found_raccheck_root_samepassword\" && \$found_raccheck_root_samepassword -ge 1 ]]">>$WATCHDOG
    echo "  elif [[ -n \"\$found_raccheck_root\" && \$found_raccheck_root -ge 1 || -n \"\$found_raccheck_root_samepassword\" && \$found_raccheck_root_samepassword -ge 1 || -n \"\$found_raccheck_cells\" && \$found_raccheck_cells -ge 1 ]]">>$WATCHDOG
    echo "  then">>$WATCHDOG
    #echo "      watchdog_long_wakeup=0">>$WATCHDOG
    #echo "      echo \$watchdog_wakeup_root">>$WATCHDOG
    echo " if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` watcher sleeping for \$watchdog_wakeup_root seconds \" >>$WATCHLOG;fi">>$WATCHDOG
    echo "      sleep \$watchdog_wakeup_root">>$WATCHDOG
    echo "  else">>$WATCHDOG
    #echo "      echo \$watchdog_wakeup">>$WATCHDOG
    echo " if [ -e $WATCHLOG ]; then echo \"\`date '+%a %b %d %H:%M:%S %Y'\` watcher sleeping for \$watchdog_wakeup seconds \" >>$WATCHLOG;fi">>$WATCHDOG
    echo "      sleep \$watchdog_wakeup">>$WATCHDOG
    echo "  fi">>$WATCHDOG
    echo "done">>$WATCHDOG
    chmod 755 $WATCHDOG  
    #read -p "see $WATCHDOG"
    #bash -x $WATCHDOG  >>watchdoglog.out 2>&1 & 
    $WATCHDOG &
    watchdog_pid=$! 
    #port specicifc commands are determined here and used in rest of the scipt
    case `/bin/uname` in
        Linux) bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
        PROFILE="$HOME/.bash_profile"
        if [ ! -f $PROFILE ]; then PROFILE="$HOME/.profile";fi 
        v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}')
        usern=`whoami`
        ;;
        SunOS) bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
        v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $9}')
        if [ `echo $v_crs_home_bin|grep -ic bin` -lt 1 ]; then v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}');fi
        if [ -z "$bgproc" ]
        then
            bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
        fi
        PROFILE="$HOME/.profile"
        #usern=`who am i|awk {'print $1}'`
        usern=`id|awk '{print $1}'|cut -d'(' -f2|cut -d')' -f1`
        ;;
        HP-UX) 
        PROFILE="$HOME/.profile"
        usern=`whoami`
        bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
        v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $9}') 
        if [ -z "$bgproc" ]
        then
            bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
            v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}') 
        fi
        ;;
        AIX)   bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $9'}`
        v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $9}') 
        if [ -z "$bgproc" ]
        then
            bgproc=`ps -ef|grep ora_pmon_$ORACLE_SID | grep -v grep|grep -v asm_pmon|awk {'print $8'}`
            v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}') 
        fi
        PROFILE="$HOME/.profile"
        usern=`whoami`
        ;;
        *)     /bin/echo "ERROR: Unknown Operating System"
        exit -1
        ;;
    esac
  # watcher script code entds here
    
fi

if [[ $OFFLINE -eq "0" ]] ; then
    # Node list
    if [ $is_exalogic_machine -eq "1" ]
    then
      generate_exalogic_node_info
    fi
    if [ $is_exalytics_machine -eq "1" ]
    then
      generate_exalytics_node_info
    fi

    is_crs_up
    single_instance_run=0
    if [[ ${crs_up} -ne 1 || $oracle_restart -eq 1 ]]
    then
      is_db_up;
      if [[ -n "$somedb_up" && $somedb_up -eq "1" && $is_exalogic_machine -eq "0" && $is_exalytics_machine -eq 0 ]]
      then
        single_instance_run=1
      elif [[ $is_exalogic_machine -eq "0" && $is_exalytics_machine -eq 0 ]] ; then
        attempt_cnt=3
        while [[ $attempt_cnt -ge "0" ]] ; do
          printf "This computer is for [S]ingle instance database or part of a [C]luster to run RAC database [S|C] [C]:"
          read uip
          case "$uip" in
            C|c) single_instance_run=0;;
            S|s) single_instance_run=1;;
            *) single_instance_run=0;;
          esac
          if [[ $single_instance_run -eq "2" ]] ; then
            echo "Invalid input. Try again ($attempt_cnt attempts remaining)"
            attempt_cnt=$(expr $attempt_cnt - 1)
          else
            attempt_cnt=-1
          fi
        done
        if [[ $single_instance_run -eq "2" ]] ; then
          single_instance_run=0
          echo "Running as a cluster node";
        fi
      fi
      if [[ $single_instance_run -eq "1" ]] ; then
        DOROOT=0
        components="SIDB:SIDBMAA"
        echo "$localnode" > $HOSTLIST
      fi
    fi
    if [ -n "$ORA_CRS_HOME" ]
    then
       CRS=$ORA_CRS_HOME
    elif [ -n "$CRS_HOME" ]
    then
      CRS=$CRS_HOME
    elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "0" && -n "$single_instance_run" && $single_instance_run -eq 0 ]]
    then
        
       if [ ${crs_up} -eq 1 ]
       then
           v_crs_home_bin=$(dirname $v_crs_home_bin 2>/dev/null)
           v_crs_home=$(echo $v_crs_home_bin|sed 's/\/bin//g')
           echo ""
           if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 && -f ${v_crs_home_bin}/crsd.bin ]]
           then   
               read -p "CRS stack is running and CRS_HOME is not set. Do you want to set CRS_HOME to "$v_crs_home"?[y/n][y]" setCRSHome
           elif [[ -n "$NOQUESTION" && $NOQUESTION -eq 1 && -f ${v_crs_home_bin}/crsd.bin ]]
           then
               setCRSHome=Yes
           else
               setCRSHome=No
           fi 
           case $setCRSHome in
	        y|Y|yes|YES|Yes)
	               export CRS=$v_crs_home
	        ;;
	        n|N|No|NO)
                       echo ""
                       read -p"Enter path for clusterware home:  " cHome
                       export CRS=$cHome
	        ;;
	       *)
	               export CRS=$v_crs_home
	        ;;
           esac
       elif [ -n "$local_invntr_CH" ]
       then
           read -p "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]" setCRSHome
           case $setCRSHome in
	        y|Y|yes|YES|Yes)
	               export CRS=$local_invntr_CH
	        ;;
	        n|N|No|NO)
                       echo ""
                       read -p"Enter value for ORA_CRS_HOME environment variable:  " cHome
                       export CRS=$cHome
	        ;;
	       *)
	               export CRS=$local_invntr_CH
	        ;;
           esac
       else    
           #echo -e $RED"Clusterware home not set so CRS related audit check will be skipped.\n"$NORM
           echo "Clusterware home not set so CRS related audit check will be skipped.\n" >>$LOGFIL
       fi
    fi 

    if [ ${crs_up} -eq 1 ]
    then
      check_crs_stat=$($CRS/bin/crs_stat -t >/dev/null 2>&1;echo $?)
      if [ $check_crs_stat -eq 0 ]
      then
        crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "11.2"`
        crs121=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`
        if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`;fi
      fi
    fi

    if [[ -z "$RAT_CLUSTERNODES" && $is_exalogic_machine -eq "0" && $single_instance_run -eq "0"  && $is_exalytics_machine -eq 0 ]]
    then
	if [ ${crs_up} -eq 1 ]
	then 
	    check_crs_stat=$($CRS/bin/crs_stat -t >/dev/null 2>&1;echo $?)
	    if [ $check_crs_stat -eq 0 ] 
	    then  
		crs112=`$CRS/bin/crsctl query $crs_version_switch|sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "11.2"`
                crs121=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`
                if [[ -n "$crs121" && $crs121 -gt 0 ]]; then  crs112=`$CRS/bin/crsctl query $crs_version_switch |sed -n 's/.*\[//p'|sed 's/\]//g'|grep -c "12.1"`;fi
		for i in `$CRS/bin/olsnodes`
		do   
		   echo $i|tr "[A-Z]" "[a-z]">>$HOSTLIST
		done
	    else
	       nodelist_without_olsnodes
	    fi
	else
	   nodelist_without_olsnodes
	fi
    elif [[ ! -z "$RAT_CLUSTERNODES" ]]
    then
        rm -f $HOSTLIST
        for nodename in `echo $RAT_CLUSTERNODES`
        do
	    echo $nodename>>$HOSTLIST
        done  
    fi
 #following code is to change the running node as first node in first and make it driving node
    saved_localnode="$localnode"
    localnode=$(grep -iw "${localnode}" $HOSTLIST| head -1)
    if [ -z "$localnode" ] ; then localnode="$saved_localnode"; fi;

    if [ `cat $HOSTLIST|head -1` != $localnode ]
    then
        #sed "/${localnode}/Id" $HOSTLIST > $INPUTDIR/tmp_hostlist.out
        cat $HOSTLIST|sed 's/'${localnode}'//g'> $INPUTDIR/tmp_hostlist.out
        rm $HOSTLIST
        echo $localnode >$HOSTLIST
        cat $INPUTDIR/tmp_hostlist.out|sed '/^$/d' >>$HOSTLIST
        rm $INPUTDIR/tmp_hostlist.out
    fi
    if [[ -n "$localonly" && $localonly -eq 1 ]]
    then
       localonly_nodename=$(cat $HOSTLIST|head -1)
       rm $HOSTLIST >/dev/null 2>&1
       echo $localonly_nodename >$HOSTLIST
    fi
 #ends here
    #Following code is change from top to here for handling user defined storage servers rather than reading from default cellip.ora
    if [[ -z "$RAT_CELLS" && -n $snlist_file && -e "$snlist_file" ]] 
    then # exalogic machine. list if already in file.
        for cellname in `cat $snlist_file`
        do
           echo "cell=\"$cellname\"">>$INPUTDIR/cellip.ora
        done
        CELLIP=$INPUTDIR/cellip.ora
    elif [ -z "$RAT_CELLS" ]
    then
        CELLIP=/etc/oracle/cell/network-config/cellip.ora   
    else
        for cellname in `echo $RAT_CELLS`
        do
           echo "cell=\"$cellname\"">>$INPUTDIR/cellip.ora
        done
        CELLIP=$INPUTDIR/cellip.ora
    fi
    if [[ -e $CELLIP && ! -e $CELLDIR ]];then mkdir $CELLDIR >/dev/null 2>&1;fi; 
fi



if [ $OFFLINE -eq 0 ]
then
#what type of check are we doing?
#echo "DEBUG MSG - CHECK TYPE = "$TYP
    #if [ $userid -eq 0 ]
    #then
    #     echo -e $RED"\nYou can not run using root user.Login as Oracle software owner and run it again"$NORM
    #     echo "\nYou can not run using root user.Login as Oracle software owner and run it again">>$LOGFIL
    #     #exit -1
    #fi
    #record localnode name to execute checks without ssh on localnode
    #Below code is to remoe all ^M from both data files
    if [[ -f $REFFIL && `echo $GREP|grep -ci cgrep` -lt 1 ]]
    then
        sed  's///g' $REFFIL > $INPUTDIR/collections.dat
        if [ -n "$RAT_OUTPUT" ]
        then
            cp $INPUTDIR/collections.dat $RAT_OUTPUT
            REFFIL=$RAT_OUTPUT/collections.dat
        else
            cp $INPUTDIR/collections.dat $REFFIL
        fi
        rm $INPUTDIR/collections.dat
    fi
    if [[ -f $REFFIL1 && `echo $GREP|grep -ci cgrep` -lt 1 ]] 
    then
        sed  's///g' $REFFIL1 > $INPUTDIR/rules.dat
        if [ -n "$RAT_OUTPUT" ]
        then
            cp $INPUTDIR/rules.dat $RAT_OUTPUT
            REFFIL1=$RAT_OUTPUT/rules.dat
        else
            cp $INPUTDIR/rules.dat $REFFIL1  
        fi 
        rm $INPUTDIR/rules.dat
    fi
#check inventory to see if this is a 10g or 11g database
    #version=v`grep "<COMP NAME=\"oracle.server\" VER=\"1" $ORACLE_HOME/inventory/ContentsXML/comps.xml |awk {'print $3'}`
#echo $version

    #if [ "$version" = "v" ]
    #then
    #    echo -e $RED"The inventory in the current oracle_home indicates that the"$NORM
    #    echo "The inventory in the current oracle_home indicates that the" >>$LOGFIL
    #    echo -e $RED"database is an earlier version than 10g which is not supported"$NORM
    #    echo "database is an earlier version than 10g which is not supported" >>$LOGFIL
    #    echo -e $RED"by this utility.  please check your environment and try again."$NORM
    #    echo "by this utility.  please check your environment and try again." >>$LOGFIL
    #    exit 1
    #fi
#ssh setup starts from here and not to change 
    if [[ $single_instance_run -eq "0" && $is_exalytics_machine -eq 0 ]] ; then
      echo -e "\nChecking ssh user equivalency settings on all nodes in cluster\n"|tee -a $LOGFIL
    fi
    #echo -e "Checking ssh autologin settings on all nodes in cluster\n">> $LOGFIL
    arr=0
    use_expect_for_ssh=0
    for hname in `cat $HOSTLIST`
    do
      platform=`uname -s`
      if [ $platform = "Linux" ]
      then
          PING="/bin/ping"
      else
          PING="/usr/sbin/ping"
      fi
      if [ $hname != $localnode ]
      then
	  if [ $platform = "SunOS" ]; then
	     $PING -s $hname 5 5 >/dev/null 2>&1
	  elif [ $platform = "HP-UX" ]; then
	       $PING $hname -n 5 -m 5 >/dev/null 2>&1
	  else
	      $PING -c 1 $PING_W_FLAG $hname >/dev/null 2>&1
	  fi
	  exitcode=`echo $?`
      fi
      if [[ $exitcode = 0 && $hname != $localnode ]]
      then   
          /usr/bin/ssh -o NumberOfPasswordPrompts=0 -o StrictHostKeyChecking=no -l $usern $hname ls 2>/dev/null 1>/dev/null
           ssh_setup_status=$?
           if [ $ssh_setup_status -ne 0 ]
           then
             if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
             then #takes too long
               rsh_setup_status=1
             else
              rsh -l $usern $hname ls 2>/dev/null 1>/dev/null 
              rsh_setup_status=$? 
              if [ $rsh_setup_status -eq 0 ];then SSHELL=rsh;SCOPY=rcp;fi
             fi
           fi
           echo "ssh_setup_status=$ssh_setup_status rsh_setup_status=$rsh_setup_status">$LOGFIL
           if [[ $ssh_setup_status -eq 0 || $hname = $localnode || $rsh_setup_status -eq 0 ]]
           then
           #    if [ $hname != $localnode ]
           #    then
                   echo -e $GREEN"Node $hname is configured for ssh user equivalency for $usern user\n" $NORM
                   echo "$hname is configured for ssh user equivalency for $usern user" >>$LOGFIL
           #    fi
           else
             if [[ $use_expect_for_ssh -eq 0 ]] ; then
               echo -e $RED"Node $hname is not configured for ssh user equivalency and  the script uses ssh to execue checks on remote nodes.\n\nWithout this facility the script cannot run audit checks on the remote nodes. \n\nIf necessary due to security policies the script can be run individually on each node.\n"$NORM
               echo -e "Node $hname is not configured for ssh user equivalency and  the script uses ssh to execue checks on remote nodes.\n\nWithout this facility the script cannot run audit checks on the remote nodes. \n\nIf necessary due to security policies the script can be run individually on each node.\n">>$LOGFIL
               read -p "Do you want to configure SSH for user $usern on $hname [y/n][y]" AutoLoginCheck
             fi
               case $AutoLoginCheck in
               y|Y|YES|yes|Yes)
                              AutoLoginCheckYes=1 
                              func_setup_ssh -user $usern  -hosts "$hname" 
                              if [ $? -ne 0 ]
                              then
                                 
                                  sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                                  cp $INPUTDIR/o_host_list.out $HOSTLIST
                                  rm $INPUTDIR/o_host_list.out
                                  add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency.";
                               fi
                             ;;
               n|N|NO|No|no)
                     if [[ $use_expect_for_ssh -eq 0 ]] ; then
                       read -p "We can configure ssh only for this run and reverse the changes back. do you want to continue?[y/n][y] " tmpSshConf
                     fi
                       case $tmpSshConf in
                        y|Y|YES|yes|Yes)
                                func_setup_ssh -user $usern  -hosts "$hname" 
                                if [ $? -ne 0 ]
                                then
                                    sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                                    cp $INPUTDIR/o_host_list.out $HOSTLIST
                                    rm $INPUTDIR/o_host_list.out
                                    add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency.";
                                else
                                    hnameArr[$arr]=$hname
                                    arr=`expr $arr + 1`
                                fi
                             ;;
                        n|N|NO|No)
                                  if [ $hname = $localnode ]
                                  then
                                      echo -e $RED"\nWithout ssh user equivalency, collections and audit checks will be executed only on localnode ${localnode}\n"$NORM
                                      echo -e $RED"\nWithout ssh user equivalency, collections and audit checks will be executed only on localnode ${localnode}\n">>$LOGFIL
                                      echo $localnode >$HOSTLIST
                                  else
                                      echo -e $RED"\nWithout ssh user eqivalency, no audit checks will be executed on ${hname}\n"$NORM
                                      echo -e "\nWithout ssh user equivalency, no audit check will be executed on ${hname}\n">>$LOGFIL
                                      sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                                      cp $INPUTDIR/o_host_list.out $HOSTLIST
                                      rm $INPUTDIR/o_host_list.out
                                      add_to_skipped_nodes "$hname" "User chose not to setup ssh user equivalency.";
                                  fi
                                  ;;
                       *)
                                func_setup_ssh -user $usern  -hosts "$hname"
                                hnameArr[$arr]=$hname
                                arr=`expr $arr + 1`
                             ;;
 
                      esac
                    ;;
               *)
                             AutoLoginCheckYes=1
                             func_setup_ssh -user $usern  -hosts "$hname" 
                             if [ $? -ne 0 ]
                             then
                                 sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
                                 cp $INPUTDIR/o_host_list.out $HOSTLIST
                                 rm $INPUTDIR/o_host_list.out
                                 add_to_skipped_nodes "$hname" "Failed to setup ssh user equivalency.";
                              fi
                ;;
               esac
           fi
      elif [ $hname != $localnode ]
      then
          sed  "s/$hname//g" $HOSTLIST >$INPUTDIR/o_host_list.out
          cp $INPUTDIR/o_host_list.out $HOSTLIST
          rm $INPUTDIR/o_host_list.out
          add_to_skipped_nodes "$hname" "Node is not pingable";
          echo "Node $hname is not pingable so removing from host list">>$LOGFIL
      fi
    done

    if [[ -n "$in_ec_exalogic" && $in_ec_exalogic -eq "1" ]] ; then
      for hname in `cat $HOSTLIST`
      do # get actual names
        if [ $hname = $localnode ]
        then
           node=`hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1`
        else
          noden=`$SSHELL $hname hostname | tr "[A-Z]" "[a-z]" |cut -d. -f1`
        fi
        node_pingable $noden
        if [[ $pingable -eq "0" ]] ; then
          noden="$hname"
        else # Change association
          case "$hname" in 
            "$ea_db_node") ea_db_node=$noden;;
            "$ea_ec1_node") ea_ec1_node=$noden;;
            "$ea_ovmm_node") ea_ovmm_node=$noden;;
            "$ea_pc1_node") ea_pc1_node=$noden;;
            "$ea_pc2_node") ea_pc2_node=$noden;;
          esac
        fi
        echo "$noden" >> $HOSTLIST.new
      done
      mv -f $HOSTLIST.new $HOSTLIST
    fi

#Following code is check that other instance of tool is not running in cluster
    for hname in `cat $HOSTLIST`
    do
      if [ $hname = $localnode ]
      then
          if [ -e $LOCKFIL ]
          then
              lockfile_pid_status=$(ps -ef |grep $(cat $LOCKFIL)|grep -v grep|wc -l) 
              if [[ -n "$lockfile_pid_status" && $lockfile_pid_status -gt 0 ]]
              then
                  echo -e "${RED}Another instance of $program_name is running on $hname. please allow it finish before you run it.\n${NORM}"
                  delete_lock_file=1
                  exit 1
              else
                  echo $$>$LOCKFIL
              fi
          fi
      else
          remote_lock_file=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then cat $LOCKFIL|wc -l;fi\"")
          remote_lockfile_pid=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then cat $LOCKFIL|head -1;fi\"")
          remote_lockfile_pid_status=$($SSHELL $hname "$bash_scr -c \"if [ -e $LOCKFIL ]; then ps -ef |grep $remote_lockfile_pid|grep -v grep|wc -l;fi\"")
          if [[ -n "$remote_lock_file" && $remote_lock_file -eq 1 && -n "$remote_lockfile_pid_status" && $remote_lockfile_pid_status -gt 0 ]]
          then
              echo -e "${RED}Another instance of $program_name is running on $hname.please allow it finish on $hname before you run it on $localnode.\n${NORM}"
              delete_lock_file=1
              exit 1
          elif [[ -n "$remote_lock_file" && $remote_lock_file -eq 1 ]] 
          then
              $SSHELL $hname "echo $$>$LOCKFIL"
          fi
      fi
    done
    if [[ -n "$localonly" && $localonly -eq 1 ]];then echo "localonly=$localonly">$LOCKFIL;fi
    echo $$>$LOCKFIL
    ####

    func_check_space
    #read -p "space_status=$space_status and space_fail_msg=$space_fail_msg space_pass_msg=$space_pass_msg"
    if [ $space_status -eq 1 ]
    then 
        while [ $space_status -eq 1 ]
        do
          echo -e "$space_fail_msg \n"
          read -p "Please make at least 10MB space available at above location and retry to continue.[y/n][y]?" spaceYesNo
          case $spaceYesNo in
              yes|Yes|Y|y|YES)
                   func_check_space
              ;;
              no|No|N|NO|n)
                   exit -1
              ;;
              *)
                  func_check_space
             ;;
         esac
        done
    else
       echo $space_pass_msg >> $LOGFIL
    fi

    create_rtemp_dir # gadiga Creates /tmp/.program in all nodes to store temp files

   if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "0" ]] && [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "0" ]]
   then #skip space check, stack check for exalogic 
    if [ $single_instance_run -eq "0" ] ; then
      is_crs_installed
      is_asm_installed_crs
      #is_rdbms_installed
      is_rdbms_installed_crs
    fi

    if [[ $single_instance_run -eq "1" ]] ; then
      search_invntr_platform
      is_rdbms_installed_si
      is_rdbms_installed_crs
    else
      echo SINGLE_INSTANCE_RUN = 0 >> $MASTERFIL
    fi
    echo "PRINT_SCORE_IN_REPORT = $print_score_in_report">>$MASTERFIL
    echo "CURRENT_USER = $usern">>$MASTERFIL
    echo "TARGET_VERSION = $targetversion">>$MASTERFIL
    offline_counter=0
    for node in `cat $HOSTLIST`
    do
      crs_installed[$offline_counter]=`grep -i "$node.CRS_INSTALLED" $MASTERFIL |awk '{print $3}'`
      rdbms_installed[$offline_counter]=`grep -i "$node.RDBMS_INSTALLED" $MASTERFIL |awk '{print $3}'`
      asm_installed[$offline_counter]=`grep -i "$node.ASM_INSTALLED" $MASTERFIL |awk '{print $3}'`
      stack_crs_up[$offline_counter]=`grep -i "$node.CRS_STATUS" $MASTERFIL|awk '{print $3}'`
      stack_asm_up[$offline_counter]=`grep -i "$node.ASM_STATUS" $MASTERFIL|awk '{print $3}'`
      stack_asm_sid[$offline_counter]=`grep -i "$node.ASM_INSTANCE" $MASTERFIL|awk '{print $3}'`
      stack_asm_home[$offline_counter]=`grep -i "$node.ASM_HOME" $MASTERFIL|awk '{print $3}'`
      stack_acfs_up[$offline_counter]=`grep -i "$node.ACFS_STATUS" $MASTERFIL|awk '{print $3}'`
      stack_dbinst_up[$offline_counter]=`grep -i "$node.INSTANCE_MODE"  $MASTERFIL|awk '{print $3}'`
      stack_dbinst_name[$offline_counter]=`grep -i "$node.INSTANCE_NAME" $MASTERFIL|awk '{print $3}'`
      offline_counter=`expr $offline_counter + 1`  
    done
    offline_counter=0
    if [[ ${crs_installed[$stack_counter]} -eq 0 || ${rdbms_installed[$stack_counter]} -eq 0 ]] && [[ $TYP = "-a" || $TYP = "-p" ]]
    then
       if [[ ${crs_installed[$stack_counter]} -eq 0 && $single_instance_run -eq "0" ]] ; then
           echo -e $RED"Since no CRS and RDBMS binaries could be found, the script will check only `uname` best practices. Oracle patch checking will also be skipped. $NORM \n"
           TYP="-b"
           old_typ=$TYP
      fi
    fi
   #fi # this if was a kind of problem and because of this, complete offline run was breaking
# check ORACLE_HOME, ORACLE_SID and ORA_CRS_HOME settings.
    if [[ -z "$CRS" && -n "$local_invntr_CH" ]]
    then
        read -p "CRS binaries found at $local_invntr_CH. Do you want to set CRS_HOME to "$local_invntr_CH"?[y/n][y]" setCRSHome
        case $setCRSHome in
	     y|Y|yes|YES|Yes)
	           export CRS=$local_invntr_CH
	     ;;
	     n|N|No|NO)
                    echo ""
                    read -p"Enter value for ORA_CRS_HOME environment variable:  " cHome
                    export CRS=$cHome
	     ;;
	     *)
	            export CRS=$local_invntr_CH
	    ;;
        esac
    fi
    if [[ $somedb_up -eq 1 && -z $ORACLE_HOME ]] || [[ ${rdbms_installed[$stack_counter]} -eq 1 &&  -z "$ORACLE_HOME" ]]
    then 
        echo ""
        if [ -n "$RAT_ORACLE_HOME" ] 
        then
            read -p "RDBMS binaries found at $RAT_ORACLE_HOME and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$RAT_ORACLE_HOME"?[y/n][y]" setOHHome
        else
            read -p "RDBMS binaries found at $local_invntr_OH and ORACLE_HOME not set. Do you want to set ORACLE_HOME to "$local_invntr_OH"?[y/n][y]" setOHHome
        fi
        case $setOHHome in
        y|Y|yes|YES|Yes) 
               if [ -n "$RAT_ORACLE_HOME" ]; then export ORACLE_HOME=$RAT_ORACLE_HOME; else export ORACLE_HOME=$local_invntr_OH;fi;
        ;;
        n|N|No|NO)
               echo ""
               read -p"Enter value for ORACLE_HOME environment variable:  " oHome
               export ORACLE_HOME=$oHome
        ;;
       *)
               if [ -n "$RAT_ORACLE_HOME" ]; then export ORACLE_HOME=$RAT_ORACLE_HOME; else export ORACLE_HOME=$local_invntr_OH;fi;
        ;;
        esac          
    fi
    #read -p "DBVERSION=$DBVERSION"
    #read -p "Check the files now"
    #is_db_up 

#following 19 lines of code were mode from up to here to accomdate DBVERSION variable
    RDBMS_INVENTORY=$ORACLE_HOME/inventory/ContentsXML/comps.xml
    CRS_INVENTORY=$CRS/inventory/ContentsXML/comps.xml
    g112=`echo  $DBVERSION | grep -c 11.2`
    #read -p "g112=$g112 and DBVERSION=$DBVERSION"
    # remove this after this run
    #g112=1 
    #read -p "g112=$g112 and DBVERION=$DBVERSION"
    if [[ ${crs_up} = 1 && $check_crs_stat -eq 0 ]] 
    then
         if [[ -n "$crs112" && $crs112 -ge 1 ]]
         then
              ASM_HOME=`$CRS/bin/srvctl config asm |head -1|cut -d: -f2`
              #To trim the blank spaces before path
              ASM_HOME=`echo $ASM_HOME | sed 's/^ *\(.*\) *$/\1/'`
              ASM_HOME="" 
              unset ASM_HOME
         else
              ASM_HOME=`$CRS/bin/srvctl config asm -n $i |awk {'print $2'}`
              ASM_INVENTORY=$ASM_HOME/inventory/ContentsXML/comps.xml
         fi
         echo "ASM_HOME=$ASM_HOME">>$LOGFIL 
    fi

    #if [[ $somedb_up -eq 1 && -z "$ORACLE_SID"  && ${rdbms_installed[$stack_counter]} -eq 1 && -z "$RAT_DBNAME" ]]
    if [[ ${rdbms_installed[$stack_counter]} -eq 1 && -z "$RAT_DBNAMES"   ]]
    then
        if [[ $db_counter -le 1 && -n "$db_name_to_check"  && $NOQUESTION -eq 0 && `cat $running_db_list|wc -l` -gt 1 ]] 
        then
            echo ""
            read -p "$program_name found database $db_name_to_check registered in OCR. Is this the database to check best practices for?[y/n][y]" ask_db_name_to_check
            #ports_find_sid
            case $ask_db_name_to_check in
                  y|Y|yes|YES|Yes)
                     #ports_find_sid
                     oSID=$($CRS/bin/srvctl status database -d $db_name_to_check|grep $localnode|awk '{print $2}')
                     export ORACLE_SID=$oSID
            ;;
                  n|N|No|NO)
                     echo ""
                     echo -e "${program_name} could not determine database to check best practices from OCR. So set environment variable RAT_DBNAMES to name of the database to analyse and re-run."
                     exit 1;
            ;;
                  *)
                     oSID=$($CRS/bin/srvctl status database -d $db_name_to_check|grep $localnode|awk '{print $2}')
                     export ORACLE_SID=$oSID
                     #ports_find_sid
                     #export ORACLE_SID=$oSID
             ;;
            esac
        else
            echo "Database pickedup for checking = $db_name_to_check">>$LOGFIL
            oSID=$($CRS/bin/srvctl status database -d $db_name_to_check 2>/dev/null|grep $localnode|awk '{print $2}')
            export ORACLE_SID=$oSID
            #ports_find_sid
            #export ORACLE_SID=$oSID
        fi
    else
        #db_name_to_check=$RAT_DBNAME
        #ports_find_sid
        #ORACLE_SID=$oSID
        #if [ -n "$CRS" ]; then oSID=$($CRS/bin/srvctl status database -d $db_name_to_check|grep $localnode|awk '{print $2}');fi;
        #export ORACLE_SID=$oSID
        #multiple_db=0
        echo "Database pickedup for checking = $db_name_to_check ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID">>$LOGFIL
    fi
    #read -p "ORACLE_HOME=$ORACLports_find_sidE_HOME and ORACLE_SID=$ORACLE_SID db_name_to_check=$db_name_to_check"
    #ports_find_sid
    #is_db_up
    #if [ $db_up -eq 1 ];  then checksysdba; fi
    func_stack_status
    if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
    then
       func_stack_print_aix
    else
         func_stack_print
    fi
    if [[ $OFFLINE -eq 0 && $upgrade_mode -gt 0 ]]; then func_print_homes; fi
    if [ $op_mode -eq 1 ] 
    then 
        if [ -z "$RAT_DB" ]
        then
            func_what_db
            if [[ -z  "$what_db" || -z "$DBVERSION" ]] 
            then 
                echo -e "$RED ${program_name} could not find database version from enviornment so set RAT_DB environment varaiable to database version like 11.2.0.1.0 and re-run it.$NORM"
                exit 1
            fi
        else
           DBVERSION=$RAT_DB
           what_db=$(echo $RAT_DB|sed 's/\.//g')
        fi
        func_create_small_files
    fi
    write_asm_version_master
    copy_utl_script_to_tmp
    
# generate an environment file and copy file to all hosts in cluster
    echo "#!$bash_scr">>$ORCLENVFIL
    #echo "$bash_source">>$ORCLENVFIL
    echo "if [ -e $PROFILE ]; then . $PROFILE>/dev/null 2>&1;fi">>$ORCLENVFIL
    echo "export ORACLE_HOME=$ORACLE_HOME">>$ORCLENVFIL
    echo "export ORACLE_SID=$ORACLE_SID">>$ORCLENVFIL
    echo "export CRS_HOME=$CRS">>$ORCLENVFIL
    echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL 
    #echo "export ORA_CRS_HOME=$CRS">>$ORCLENVFIL
    if [ -n "$TNS_ADMIN" ]; then echo "export TNS_ADMIN=$TNS_ADMIN">>$ORCLENVFIL;fi;
    echo "if [[ \"\${LD_LIBRARY_PATH:-unset}\"  = \"unset\" ]] ; then LD_LIBRARY_PATH=\"\"; fi">>$ORCLENVFIL
    echo "LD_LIBRARY_PATH=\${LD_LIBRARY_PATH}:$ORACLE_HOME/lib" >>$ORCLENVFIL
    echo "export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:$ORACLE_HOME/lib:$CRS/lib">>$ORCLENVFIL
  
    else
        func_init_arrays
        #func_check_space
        #func_check_another_instance
        # create_rtemp_dir # gadiga Creates /tmp/.program in all nodes to store temp files
        echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL 
        func_create_small_files
        copy_utl_script_to_tmp 
        echo "export OUTPUTDIR=$OUTPUTDIR">>$ORCLENVFIL 
    fi #is_exalogic_machine

    if [[ $OFFLINE -eq 0 && `echo $components|grep -icw dbm` -ge 1 && $db_machine_compute -eq 0  && $is_exalogic_machine -eq 0 ]] && [ $components != "RDBMS" ]
    then
        echo -e "\nDBM module not applicable on this cluster. ${program_name} will run without any module specific\n"|tee -a $LOGFIL
        components=NONE
        it_is_rac=1  
        if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] ; then read -p "Press any key to continue ...";fi
    elif [[ $OFFLINE -eq 0 && `echo $components|grep -icw dbm` -ge 1 && `echo $components|grep -ic rdbms` -lt 1 && $db_machine_compute -eq 1 ]]
    then
        components=EXADATA
    fi
    if [[ $OFFLINE -eq 0 && `echo $components|grep -ic ovm` -ge 1 && $VMTYPE != "PVM" ]]
    then
        echo -e "\nOVM module not applicable on this cluster. ${program_name} will run without any module specific\n"|tee -a $LOGFIL
        components=NONE
        it_is_rac=1  
        if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] ; then read -p "Press any key to continue ...";fi
    elif [[ $OFFLINE -eq 0 && `echo $components|grep -ic ovm` -ge 1 && $VMTYPE = "PVM" ]]
    then
        TYP="-b"
    fi
#Find out that will any command in this audit check will require root or not.
    if [ $op_mode -eq 1 ]
    then  
         #REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
         REQUIRE_ROOT=`grep  "REQUIRES_ROOT_COUNT" $REFFIL|sed  -n 's/.*REQUIRES_ROOT_COUNT //p'| sed 's/^ *\(.*\) *$/\1/'`
    else
         REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
    fi

    exa_machine=0
    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]] ; then exa_machine=1; fi
    if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] ; then exa_machine=1; fi
    root_all_prompt=0
#echo "******** $db_machine_compute  $is_exalogic_machine  Looking for cells in $CELLIP"
#cat  $CELLIP
#echo "==================="

  
    ask_cell_password=1
    if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_cell_checks -eq "0" ]] ; then
      ask_cell_password=0
    fi

  
    #if [[ -n "$exa_machine" && $exa_machine -eq 1 ]] && [[ $is_exalogic_machine -eq 1 || $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1  || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 && $TYP != "-p" ]] && [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]] && [ "$upgrade_mode" -ne "3" ] && [ $only_hacheck_run -eq 0 ] && [ $ask_cell_password -eq "1" ]
    if [[ $db_machine_compute -eq 1  || $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1  || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 ]] && [ $TYP != "-p" ] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ "$upgrade_mode" -ne "3" ] && [ $only_hacheck_run -eq 0 ] && [ $ask_cell_password -eq "1" ]
    then
      # First check if root password is same on all components. only for exa
      # The root password is stored in global_root_password
      root_all_prompt=0
      set_root_all_prompt
      set_root_all_prompt_called=1
        cell_type="normal"
        if [[ -n " $is_exalogic_machine" &&  $is_exalogic_machine -eq "1" ]]
        then
          cell_type="zfscell"
        fi
        cell_root_command=$(grep -icw "NEEDS_RUNNING STORAGE_CELL" $REFFIL)
	if [ -z "$RAT_CELL_SSH_USER" ];then cell_ssh_user=root;else cell_ssh_user=$RAT_CELL_SSH_USER;fi
        first_cell_ip=$(cat $CELLIP|cut -d\" -f2|head -1)
	for cell_ip in `cat $CELLIP|cut -d\" -f2`
	do
            cellPingStatus=$($PING -c 1 $PING_W_FLAG $cell_ip >/dev/null 2>&1;echo $?)
            if [ $cellPingStatus -eq 0 ]
            then 
		cell_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cell_ip ls >/dev/null 2>&1;echo $?);
		#cell_ssh_status=100
		cell_password_status=0
		#if [ $cell_ssh_status -eq 255 ];then cell_ssh_status=0;fi
		cellname_full=$(cat /etc/hosts|grep -w "$cell_ip"|awk '{print $NF}'|cut -d'-' -f1)
		storage_cells=$(cells1=`cat $CELLIP|cut -d\" -f2`;echo $cells1|sed 's/ /,/g');
		if [[ -n "$cell_ssh_status" && $cell_ssh_status -ne 0 ]]
		then
                  if [ $root_all_prompt -eq "1" ] ; then
                    echo "Validating root password on STORAGE SERVER"
                    echo 
                    cellssh_YesNo=1
                  else
		    echo -e "\n${cell_ssh_user} user equivalence is not setup between $localnode and ${BLINK}STORAGE SERVER${NORM} ${cellname_full}." 
		    echo -e "\n1. Enter 1 if you will enter ${cell_ssh_user} password for each ${BLINK}STORAGE SERVER${NORM} when prompted."
		    echo -e "\n2. Enter 2 to exit and configure $cell_ssh_user user equivalence manually and re-run ${program_name}."
		    echo -e "\n3. Enter 3 to skip checking best practices on ${BLINK}STORAGE SERVER${NORM}.\n"
		    read -p  "Please indicate your selection from one of the above options[1-3][1]:- " cellssh_YesNo
                  fi
		    case $cellssh_YesNo in
		    1)
		       cell_password_status=1
                       if [ $root_all_prompt -eq "1" ] ; then
                         cell_samerootpassword_YesNo="y"
                       else
		         echo -e "\n"
		         read -p  "Is ${cell_ssh_user} password same on all STORAGE SERVER?[y/n][y]" cell_samerootpassword_YesNo
                       fi
		       case $cell_samerootpassword_YesNo in
			    y|Y|Yes|YES|yes)
			      cell_samerootpassword=1
                              if [ $root_all_prompt -eq "1" ] ; then
                                cell_rootpassword="$global_root_password"
                              else
			        echo -e "\n"
			        printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} :- "
			        stty -echo
			        read -r cell_rootpassword
			        stty echo
                              fi
			      root_hostname=$cell_ip
			      checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
			      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
			      then
				 find_switch_root_password=$passwordToCheck
				 first_cell_ip=$(cat $CELLIP|cut -d\" -f2|head -1)  
			      fi
			      cell_rootpassword=$passwordToCheck
			      echo -e "\n"
			      ;;
			    n|N|No|NO|no)
			      cell_samerootpassword=0
			      root_cell_counter=0
			      echo -e "\n"
			      for cellname in `cat $CELLIP|cut -d\" -f2`
			      do
                                cell_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
                                if [[ -n "$cell_ssh_status2" && $cell_ssh_status2 -eq 0 ]]
                                then
                                    echo "$cell_ssh_user password not checked on $cellname because ssh user equivalence found for $cell_ssh_user">>$LOGFIL
                                else
                    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
                    then
                        cellname_full=$cellname
                    else
				        cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)  
                    fi
				    printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} $cellname_full :- "
				    stty -echo
				    read -r cell_rootpassword
				    stty echo
				    checkUserPassword "$cellname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
				    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
				    then
				       find_switch_root_password=$passwordToCheck
				       first_cell_ip=$cellname
				    fi
				    cell_rootpassword=$passwordToCheck
				    echo -e "\n"
				    a_cell_rootpassword[$root_cell_counter]=$cell_rootpassword
                                fi
				root_cell_counter=$(expr $root_cell_counter + 1 )
			      done

			     ;;
			   *)
			      cell_samerootpassword=1
			      echo -e "\n"
			      printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} :- "
			      stty -echo
			      read -r cell_rootpassword
			      stty echo
			      root_hostname=$cell_ip
			      checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
			      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
			      then
				 find_switch_root_password=$passwordToCheck
				 first_cell_ip=$(cat $CELLIP|cut -d\" -f2|head -1)  
			      fi
			      cell_rootpassword=$passwordToCheck
			      echo -e "\n"
			     ;;
		       esac 
		     ;;
		    2)
		       echo -e "\nLogin as $cell_ssh_user user on $localnode\n\nA. Generate $cell_ssh_user ssh keys.\n\ta. ssh-keygen -t dsa\n\tb. ssh-keygen -t rsa\nAccept defaults so the ssh keys are created for $cell_ssh_user user\n\nB. Push ssh keys to set up ssh equivalence using following command. Enter $cell_ssh_user password when prompted for.\ndcli -c $storage_cells -l $cell_ssh_user -k\n\n"
		       exit 1;
		    ;; 
		    3)
		       cell_password_status=3
		       break
		    ;;
		    *)
		       cell_password_status=1
		       echo -e "\n"
		       read -p  "Is ${cell_ssh_user} password same on all STORAGE SERVER[y/n][y]" cell_samerootpassword_YesNo
		       case $cell_samerootpassword_YesNo in
			    y|Y|Yes|YES|yes)
			      cell_samerootpassword=1
			      echo -e "\n"
			      printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} :- "
			      stty -echo
			      read -r cell_rootpassword
			      stty echo
			      root_hostname=$cell_ip
			      checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
			      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
			      then
				 find_switch_root_password=$passwordToCheck
				 first_cell_ip=$(cat $CELLIP|cut -d\" -f2|head -1)  
			      fi
			      cell_rootpassword=$passwordToCheck
			      echo -e "\n"
			      ;;
			    n|N|No|NO|no)
			      cell_samerootpassword=0
			      root_cell_counter=0
			      echo -e "\n"
			      for cellname in `cat $CELLIP|cut -d\" -f2`
			      do
                                cell_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
                                if [[ -n "$cell_ssh_status2" && $cell_ssh_status2 -eq 0 ]]
                                then
                                    echo "$cell_ssh_user password not checked on $cellname because ssh user equivalence found for $cell_ssh_user">>$LOGFIL
                                else
                    if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
                    then 
                        cellname_full=$cellname
                    else
				        cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)  
                    fi 
				    printf  "Enter ${cell_ssh_user} password for ${BLINK}STORAGE SERVER${NORM} $cellname_full :- "
				    stty -echo
				    read -r cell_rootpassword
				    stty echo
				    checkUserPassword "$cellname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
				    if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
				    then
				       find_switch_root_password=$passwordToCheck
				       first_cell_ip=$cellname
				    fi
				    cell_rootpassword=$passwordToCheck
				    echo -e "\n"
				    a_cell_rootpassword[$root_cell_counter]=$cell_rootpassword
                                fi
				root_cell_counter=$(expr $root_cell_counter + 1 )
			      done
			     ;;
			   *)
			      cell_samerootpassword=1
			      echo -e "\n"
			      printf  "Enter $cell_ssh_user password for ${BLINK}STORAGE SERVER${NORM} :- "
			      stty -echo
			      read cell_rootpassword
			      stty echo
			      root_hostname=$cell_ip
			      checkUserPassword "$root_hostname" "$cell_ssh_user" "$cell_rootpassword" "3" $cell_type
			      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
			      then
				 find_switch_root_password=$passwordToCheck
				 first_cell_ip=$(cat $CELLIP|cut -d\" -f2|head -1)  
			      fi
			      cell_rootpassword=$passwordToCheck
			      echo -e "\n"
			     ;;
		       esac
		    ;; 
		   esac
		   break
    #"\nso setup user equivalence between $localnode and all storage cells for root user and re-run $program_name."  
                elif [[ -n "$cell_ssh_status" && $cell_ssh_status -ne 0 ]]
                then
                   cell_password_status=3 
		fi
            else
                cell_password_status=3 
                add_to_skipped_nodes "$cell_ip" "Storage server is not reachable";
            fi 
	done 
      if [[ -n "$cell_password_status" && $cell_password_status -eq 1 && "$cell_ssh_user" = "root" && -z "$RAT_IBSWITCHES" ]]
      then
	    #if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq 0 ]]  
	    #then
#		 find_switch_root_password=${a_cell_rootpassword[0]}
#	    elif [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq 1 ]]
#	    then
#		 find_switch_root_password=$cell_rootpassword
#	    fi
             # gadiga - create /tmp/.program first
	      fixRootPassword "$find_switch_root_password"
              $EXPECT -f - << IBEOF
                               #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
                               log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }    
                               spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip mkdir ${RTEMPDIR}
                               match_max 100000
                                 expect {
                               "no)?" {
                                     send -- "yes\n"
                                     }
                              }
                             # Look for passwd prompt
                             expect "*?assword:*"
                            send -- "\$le_find_switch_root_password\n"
                             # Stop the on logon tests and if asked to connect to master switch choose no
                             expect eof
IBEOF
	      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip "ibswitches>${RTEMPDIR}/o_ibswitches_full.out"
			       match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			      }
			     # Look for passwd prompt
			     expect "*?assword:*"
                            send -- "\$le_find_switch_root_password\n"
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     expect eof
IBEOF
			       $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SCOPY $cell_ssh_user@$first_cell_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR}
			       match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			      }
			     # Look for passwd prompt
			     expect "*?assword:*"
                            send -- "\$le_find_switch_root_password\n"
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     expect eof
IBEOF
	      $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
                               spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip "cellcli -e \"list cell attributes makeModel\" 2>/dev/null>${SYSTEM_DESC_FIL}"
			       match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			      }
			     # Look for passwd prompt
			     expect "*?assword:*"
                            send -- "\$le_find_switch_root_password\n"
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     expect eof
IBEOF
			       $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SCOPY $cell_ssh_user@$first_cell_ip:${SYSTEM_DESC_FIL} ${RTEMPDIR}
			       match_max 100000
				 expect {	
			       "no)?" {
				     send -- "yes\n"
				     }
			      }
			     # Look for passwd prompt
			     expect "*?assword:*"
				send -- "\$le_find_switch_root_password\n"
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     expect eof
IBEOF
			       $EXPECT -f - << IBEOF
			       #set timeout 1
                               set timeout $passwordcheck_timeout
			       set le_find_switch_root_password "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }   
			       spawn $SSHELL $cell_ssh_user@$first_cell_ip rm -f ${RTEMPDIR}/o_ibswitches_full.out ${SYSTEM_DESC_FIL}
			       match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			      }
			     # Look for passwd prompt
			     expect "*?assword:*"
				send -- "\$le_find_switch_root_password\n"
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     expect eof
IBEOF

	elif [[ -n "$cell_password_status" && $cell_password_status -eq 0 && "$cell_ssh_user" = "root" && -z "$RAT_IBSWITCHES" ]]
	then
           # gadiga -cell ssh is setup. create /tmp/.program
           #Commented this and created directory as needed rather than createing here on all cells. thats how if user presses ctrl+c, we will eave directory only on 1 cell and not on all
           #create_rtemp_dir_in_cells 
	   first_cell_ip=$(cat $CELLIP|cut -d\" -f2|head -1)         
	   $SSHELL $cell_ssh_user@$first_cell_ip "mkdir ${RTEMPDIR}"
	   $SSHELL $cell_ssh_user@$first_cell_ip "ibswitches>${RTEMPDIR}/o_ibswitches_full.out"
           $SSHELL $cell_ssh_user@$first_cell_ip "cellcli -e \"list cell attributes makeModel\" 2>/dev/null>${SYSTEM_DESC_FIL}"
	   $SCOPY $cell_ssh_user@$first_cell_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1
           $SCOPY $cell_ssh_user@$first_cell_ip:${SYSTEM_DESC_FIL} ${RTEMPDIR} >/dev/null 2>&1
	   $SSHELL $cell_ssh_user@$first_cell_ip rm -f ${RTEMPDIR}/o_ibswitches_full.out ${SYSTEM_DESC_FIL} >/dev/null 2>&1
	   $SSHELL $cell_ssh_user@$first_cell_ip "rmdir ${RTEMPDIR}"
        elif [ -n  "$RAT_IBSWITCHES" ]
        then
            for switchname in `echo $RAT_IBSWITCHES`
            do
               echo $switchname >>${RTEMPDIR}/o_ibswitches_full.out
            done
	fi
    else
       cell_ssh_status=0 
    fi
    echo "cell_ssh_status=$cell_ssh_status and cell_ssh_user=$cell_ssh_user">>$LOGFIL
    echo "CELL_PASSWORD_OPTION = $cell_password_status" >>$MASTERFIL
    echo "CELL_PASSWORD_OPTION = $cell_password_status" >>$LOGFIL  
    
   #following code is find infiniband switches from first cells   


#password prompt for ZFS cells for super cluster
    ask_zfs_password=1
    if [[ -n "$run_profile" && $run_profile -eq "1" && $zfs_in_profile -eq "0" ]] ; then
      ask_zfs_password=0
    fi
  
    if [[ $is_ssc_machine -eq 2 || $is_exalogic_machine -eq 1 ]] && [[  $TYP != "-p"  && -n "$skip_in_silent" && $skip_in_silent -eq 0  && "$upgrade_mode" -ne "3" && $only_hacheck_run -eq 0 && $ask_zfs_password -eq "1" ]]
    then
      # First check if root password is same on all components. only for exa
      # The root password is stored in global_root_password
      if [ -z "$set_root_all_prompt_called" ] ; then
        root_all_prompt=0
        set_root_all_prompt
        set_root_all_prompt_called=1
      fi
      cell_type="zfscell"
        #cell_root_command=""
	if [ -z "$RAT_ZFS_SSH_USER" ];then zfs_ssh_user=root;else zfs_ssh_user=$RAT_ZFS_SSH_USER;fi
        if [ $is_ssc_machine -eq 1 ];then discover_ssc_zfs_nodes;elif [ $is_exalogic_machine -eq 1 ];then ZFSIP=$CELLIP;fi
	for cell_ip in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
	do
            zfsPingStatus=$($PING -c 1 $PING_W_FLAG $cell_ip >/dev/null 2>&1;echo $?)
            if [ $zfsPingStatus -eq 0 ]
            then 
		zfs_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $cell_ip ls >/dev/null 2>&1;echo $?);
		#cell_ssh_status=100
		zfs_password_status=0
		#if [ $cell_ssh_status -eq 255 ];then cell_ssh_status=0;fi
		zfsname_full=$(cat /etc/hosts|grep -w "$cell_ip"|awk '{print $NF}'|cut -d'-' -f1)
		zfs_storage_cells=$(cells1=`cat $ZFSIP`;echo $cells1|sed 's/ /,/g');
		if [[ -n "$zfs_ssh_status" && $zfs_ssh_status -ne 0 ]]
		then
                  if [ $root_all_prompt -eq "1" ] ; then
                    echo "Validating root password on ZFS Storage Appliance"
                    echo 
                    zfsssh_YesNo=1
                  else
		    echo -e "\n${zfs_ssh_user} user equivalence is not setup between $localnode and ${BLINK}ZFS Storage Appliance${NORM} ${cell_ip}." 
		    echo -e "\n1. Enter 1 if you will enter ${zfs_ssh_user} password for each ${BLINK}ZFS Storage Appliance${NORM} when prompted."
		    echo -e "\n2. Enter 2 to exit and configure $zfs_ssh_user user equivalence manually and re-run ${program_name}."
		    echo -e "\n3. Enter 3 to skip checking best practices on ${BLINK}ZFS Storage Appliance${NORM}.\n"
		    read -p  "Please indicate your selection from one of the above options[1-3][1]:- " zfsssh_YesNo
                  fi
		    case $zfsssh_YesNo in
		    1)
		       zfs_password_status=1
		       if [ $root_all_prompt -eq "1" ] ; then
		         zfs_samerootpassword_YesNo="y"
		       else
		         echo -e "\n"
		         read -p  "Is ${zfs_ssh_user} password same on all ZFS Storage Appliance?[y/n][y]" zfs_samerootpassword_YesNo
		       fi
		       case $zfs_samerootpassword_YesNo in
			    y|Y|Yes|YES|yes)
			      zfs_samerootpassword=1
		              if [ $root_all_prompt -eq "1" ] ; then
		                zfs_rootpassword="$global_root_password"
		              else
			        echo -e "\n"
			        printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} :- "
			        stty -echo
			        read -r zfs_rootpassword
			        stty echo
		              fi
			      root_hostname=$cell_ip
			      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
			      zfs_rootpassword=$passwordToCheck
			      echo -e "\n"
			      ;;
			    n|N|No|NO|no)
			      zfs_samerootpassword=0
			      root_zfs_counter=0
			      echo -e "\n"
			      for zfsname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
			      do
                                zfs_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $zfsname ls >/dev/null 2>&1;echo $?);
                                if [[ -n "$zfs_ssh_status2" && $zfs_ssh_status2 -eq 0 ]]
                                then
                                    echo "$zfs_ssh_user password not checked on $zfsname because ssh user equivalence found for $zfs_ssh_user">>$LOGFIL
                                else
				    printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} $zfsname :- "
				    stty -echo
				    read -r zfs_rootpassword
				    stty echo
				    checkUserPassword "$zfsname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
				    zfs_rootpassword=$passwordToCheck
				    echo -e "\n"
				    a_zfs_rootpassword[$root_zfs_counter]=$zfs_rootpassword
                                fi
				root_zfs_counter=$(expr $root_zfs_counter + 1 )
			      done

			     ;;
			   *)
			      zfs_samerootpassword=1
			      echo -e "\n"
			      printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} :- "
			      stty -echo
			      read -r zfs_rootpassword
			      stty echo
			      root_hostname=$cell_ip
			      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
			      zfs_rootpassword=$passwordToCheck
			      echo -e "\n"
			     ;;
		       esac 
		     ;;
		    2)
		       echo -e "\nLogin as $zfs_ssh_user user on $localnode\n\nA. Generate $zfs_ssh_user ssh keys.\n\ta. ssh-keygen -t dsa\n\tb. ssh-keygen -t rsa\nAccept defaults so the ssh keys are created for $zfs_ssh_user user\n\nB. Push ssh keys to set up ssh equivalence using following command. Enter $zfs_ssh_user password when prompted for.\ndcli -c $zfs_storage_cells -l $zfs_ssh_user -k\n\n"
		       exit 1;
		    ;; 
		    3)
		       zfs_password_status=3
		       break
		    ;;
		    *)
		       zfs_password_status=1
		       echo -e "\n"
		       read -p  "Is ${zfs_ssh_user} password same on all ZFS Storage Appliance[y/n][y]" zfs_samerootpassword_YesNo
		       case $zfs_samerootpassword_YesNo in
			    y|Y|Yes|YES|yes)
			      zfs_samerootpassword=1
			      echo -e "\n"
			      printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} :- "
			      stty -echo
			      read -r zfs_rootpassword
			      stty echo
			      root_hostname=$cell_ip
			      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
			      zfs_rootpassword=$passwordToCheck
			      echo -e "\n"
			      ;;
			    n|N|No|NO|no)
			      zfs_samerootpassword=0
			      root_zfs_counter=0
			      echo -e "\n"
			      for zfsname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
			      do
                                zfs_ssh_status2=$($SSHELL -o NumberOfPasswordPrompts=0 -l $zfs_ssh_user $zfsname ls >/dev/null 2>&1;echo $?);
                                if [[ -n "$zfs_ssh_status2" && $zfs_ssh_status2 -eq 0 ]]
                                then
                                    echo "$zfs_ssh_user password not checked on $zfsname because ssh user equivalence found for $zfs_ssh_user">>$LOGFIL
                                else
				    printf  "Enter ${zfs_ssh_user} password for ${BLINK}ZFS Storage Appliance${NORM} $zfsname :- "
				    stty -echo
				    read -r zfs_rootpassword
				    stty echo
				    checkUserPassword "$zfsname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
				    zfs_rootpassword=$passwordToCheck
				    echo -e "\n"
				    a_zfs_rootpassword[$root_zfs_counter]=$zfs_rootpassword
                                fi
				root_zfs_counter=$(expr $root_zfs_counter + 1 )
			      done
			     ;;
			   *)
			      zfs_samerootpassword=1
			      echo -e "\n"
			      printf  "Enter $zfs_ssh_user password for ${BLINK}ZFS Storage Appliance${NORM} :- "
			      stty -echo
			      read -r zfs_rootpassword
			      stty echo
			      root_hostname=$cell_ip
			      checkUserPassword "$root_hostname" "$zfs_ssh_user" "$zfs_rootpassword" "3" $cell_type
			      zfs_rootpassword=$passwordToCheck
			      echo -e "\n"
			     ;;
		       esac
		    ;; 
		   esac
		   break
    #"\nso setup user equivalence between $localnode and all storage cells for root user and re-run $program_name."  
                elif [[ -n "$zfs_ssh_status" && $zfs_ssh_status -ne 0 ]]
                then
                   zfs_password_status=3 
		fi
            else
                zfs_password_status=3 
                add_to_skipped_nodes "$cell_ip" "ZFS Storage Appliance is not reachable";
            fi 
	done 
    else
       zfs_ssh_status=0 
    fi
    if [[ $is_exalogic_machine -eq 1 && -n "$swlist_file" && -e "$swlist_file" && -z "$RAT_IBSWITCHES" ]]
        then # exalogic machine. read switch info from file
            for switchname in `cat $swlist_file`
            do
              $PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
              switchping_status=$(echo $?)
              if [ $switchping_status -eq 0 ]
              then 
                  echo $switchname>>${RTEMPDIR}/o_ibswitches.out
              else
                  $PING -c 1 $PING_W_FLAG $switchname >>$LOGFIL
                  echo "Infiniband switch $switchname is not reachable so its being skipped from checking best practicing">>$LOGFIL  
                  add_to_skipped_nodes "$switchname" "Infiniband switch is not reachable";
              fi
            done
            rm -f ${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1
            cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
    fi
    echo "zfs_ssh_status=$zfs_ssh_status and zfs_ssh_user=$zfs_ssh_user">>$LOGFIL
    echo "ZFS_PASSWORD_OPTION = $zfs_password_status" >>$MASTERFIL
    echo "ZFS_PASSWORD_OPTION = $zfs_password_status" >>$LOGFIL  


#password prompts for zfs appliance for super cluster ends here
    
#echo "Switches:"
#cat ${OUTPUTDIR}/o_ibswitches.out 
#echo "=============="

if [ -e ${RTEMPDIR}/o_ibswitches_full.out ]
then
    #for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|awk 'BEGIN { FS = "\" enhanced" } {print $1}'|awk '{print $NF}'|grep -vw localhost|cut -d' ' -f1`
    for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|cut -d'"' -f2|awk {'print $NF}'|grep -vw localhost|grep -vi leaf|cut -d' ' -f1`
    do
      $PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
      switchping_status=$(echo $?) 
      if [ $switchping_status -eq 0 ]
      then
          echo $switchname>>${RTEMPDIR}/o_ibswitches.out
      else
          $PING -c 1 $PING_W_FLAG $switchname >>$LOGFIL
          echo "Infiniband switch $switchname is not reachable so its being skipped from checking best practicing">>$LOGFIL
          add_to_skipped_nodes "$switchname" "Infiniband switch is not reachable";
      fi
    done
    rm -f ${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1
    cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
fi
#code is find infiniband switches from first cells ends here
#   ssh setup on cells finished here

#following code is to find exadata version by logging in as root on storage server because oracle can not run imageinfo.
if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 && $TYP != "-p" ]]
then
  if [ -n "$RAT_EXADATA_VERSION" ]
  then
      current_exadata_version=$(echo $RAT_EXADATA_VERSION|sed 's/\.//g')
      echo "Exadata version found on cluster = $current_exadata_version">>$LOGFIL
      echo "CURRENT_EXADATA_VERSION = $current_exadata_version" >>$MASTERFIL 
  else
      if [[ -n "$cell_password_status" && $cell_password_status -eq 1 && "$cell_ssh_user" = "root" ]]
      then
	  fixRootPassword "$find_switch_root_password"
	  current_exadata_version=$($EXPECT -f - << IBEOF
				    #set timeout 1
                                    set timeout $passwordcheck_timeout
				    set le_find_switch_root_password "$fixedRootPassword"
				    log_user 1
                                    if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                      exp_internal 1
                                    } 
				    spawn -noecho $SSHELL $cell_ssh_user@$first_cell_ip "imageinfo -version"
				    match_max 100000
				    expect {
				    "no)?" {
				    send -- "yes\n"
					   }
					 }
				   expect "*?assword:*"
				   send -- "\$le_find_switch_root_password\n"
				   expect eof
IBEOF
)
	  current_exadata_version=$(echo $current_exadata_version|$AWK 'BEGIN { FS = "password:" };{print $2}'|sed 's/ //g'|sed 's///g')
	  current_exadata_version=$(echo $current_exadata_version|sed 's/\./#/g'|$AWK 'BEGIN{FS=OFS="#"}{$NF="";gsub(FS"+","")}1')
	  echo "Exadata version found on cluster = $current_exadata_version">>$LOGFIL
	  echo "CURRENT_EXADATA_VERSION = $current_exadata_version" >>$MASTERFIL 
      elif [[ -n "$cell_password_status" && $cell_password_status -eq 0 && "$cell_ssh_user" = "root" ]]
      then
	  current_exadata_version=$($SSHELL $cell_ssh_user@$first_cell_ip "imageinfo -version")
	  current_exadata_version=$(echo $current_exadata_version|sed 's/\./#/g'|$AWK 'BEGIN{FS=OFS="#"}{$NF="";gsub(FS"+","")}1')
	  echo "Exadata version found on cluster = $current_exadata_version">>$LOGFIL
	  echo "CURRENT_EXADATA_VERSION = $current_exadata_version" >>$MASTERFIL 
      fi
  fi
  if [[ -z "$current_exadata_version" &&  -n "$skip_in_silent" && $skip_in_silent -eq 0 && $cell_password_status -ne 3 && $upgrade_mode -ne 3 && $only_hacheck_run -eq 0  && $ask_cell_password -ne "0" ]]
  then
      echo -e "${RED}${program_name} could not determine Exadata software version from enviornment. Set RAT_EXADATA_VERSION environment varaiable to Exadadat software version and re-run it.$NORM\n"
      echo -e "eg export RAT_EXADATA_VERSION=11.2.2.4.0\n"
      exit 1
  fi
fi  
  #read -p "$current_exadata_version"
#code to find out version ends here
#calling is_this_db_machine again because some values will be available from storage server 

is_this_db_machine $localnode
add_maa_scorecard
add_hacheck

write_db_machine_info_to_envfile $localnode
#read -p "components=$components"
    #read -p "TYP=$TYP REQUIRE_ROOT=$REQUIRE_ROOT"
    root_need_cell_ssh=0
    #if [ -n "$db_machine_compute" ] && [[ $dbm_v1 -eq 1 || $dbm_v2 -eq 1 ]] && [[  -n "$cell_password_status" && $cell_password_status -eq 3 ]]; then root_need_cell_ssh=1;fi
    if [ -n "$db_machine_compute" ] && [[ $dbm_v1 -eq 1 ]] && [[  -n "$cell_password_status" && $cell_password_status -eq 3 ]]; then root_need_cell_ssh=1;fi

    ask_root_password=1
    if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_root_checks -eq "0" ]] ; then
      ask_root_password=0
    fi
    if [[ -n "$REQUIRE_ROOT" && $REQUIRE_ROOT -ge 1 ]] && [ $TYP = "-a" -o $TYP = "-b"  -o $TYP = "-u" ] && [ $userid -ne 0 ] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ "$components" != "OVM" ] && [ $root_need_cell_ssh -eq 0 ] && [ $upgrade_mode -ne 2 ] && [ $single_instance_run -eq "0" ] && [ $only_hacheck_run -eq 0 ] && [ $ask_root_password -eq 1 ]
    then
      if [ $root_all_prompt -eq "1" ] ; then
        rootYesNo=1
      else
        #echo ""|tee -a $LOGFIL |tee -a $REPFIL
        #echo -e "\n$REQUIRE_ROOT of the included audit checks require root privilege. Please be prepared to supply the root password when prompted for each node in cluster.\n"
        echo -e "\n$REQUIRE_ROOT of the included audit checks require root privileged data collection ${print_compute_node}. If sudo is not configured or the root password is not available, audit checks which  require root privileged data collection can be skipped.\n"|tee -a $LOGFIL
        #echo -e "\n.Please select one of the following choices.\n"|tee -a $LOGFIL
        #echo  "If the root password is not available, only audit checks which do not require root privilege will be executed.\n">>$LOGFIL
        #echo -e "\n$REQUIRE_ROOT of the included audit checks require root privilege. Please select one of the following choices.\n">>$LOGFIL
        #echo  "$REQUIRE_ROOT  of the included audit checks require root privilege. Please be prepared to supply the root password when prompted for each node in cluster.\n">>$LOGFIL
        echo -e "\n1. Enter 1 if you will enter root password for each ${print_compute_node} host when prompted"
        echo -e "\n2. Enter 2 if you have sudo configured for oracle user to execute root_${program_name}.sh script ${print_compute_node}" 
        echo -e "\n3. Enter 3 to skip the root privileged collections ${print_compute_node}"
        echo -e "\n4. Enter 4 to exit and work with the SA to configure sudo ${print_compute_node} or to arrange for root access and run the tool later.\n"
        read -p  "Please indicate your selection from one of the above options[1-4][1]:- " rootYesNo
      fi
        case $rootYesNo in
             1) 
               rootYesNoint=1
               #if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $dbm_v2 -eq 1 ]]
               if [[ -e /usr/bin/expect ]]
               then
                 if [ $root_all_prompt -eq "1" ] ; then
                   samerootpassword_YesNo="y"
                 else
                   echo -e "\n"
                    
                   if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
                   then      
                       read -p  "Is root password same on all compute nodes?[y/n][y]" samerootpassword_YesNo
                   else
                       read -p  "Is root password same on all nodes?[y/n][y]" samerootpassword_YesNo
                   fi
                 fi
                   case $samerootpassword_YesNo in
                        y|Y|Yes|YES|yes)
                          samerootpassword=1
                          if [ $root_all_prompt -eq "1" ] ; then
                            compute_rootpassword="$global_root_password"
                          else
			    echo -e "\n"
			    printf  "Enter root password ${print_compute_node}:- "
			    stty -echo
			    read -r compute_rootpassword
			    stty echo
                          fi
                          root_hostname=$(cat $HOSTLIST|head -1)
                          compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $root_hostname ls >/dev/null 2>&1;echo $?);
                          if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                          then
                               echo "root password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
                          else
			      checkUserPassword "$root_hostname" "root" "$compute_rootpassword" "3"
			      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
			      then
				 find_switch_root_password=$passwordToCheck
				 first_compute_ip=$(cat $HOSTLIST|head -1)  
			      fi
			      compute_rootpassword=$passwordToCheck
			  fi
			  echo -e "\n"
                          ;;
                        n|N|No|NO|no)
                          samerootpassword=0
                          root_hostname_counter=0
                          echo -e "\n"
                          for root_hostname in `cat $HOSTLIST`
                          do
                              compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $root_hostname ls >/dev/null 2>&1;echo $?);
                              if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                              then
                                  echo "root password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL 
                              else
				  printf  "Enter root password ${print_compute_node} $root_hostname :- "
				  stty -echo
				  read -r compute_rootpassword
				  stty echo
				  checkUserPassword "$root_hostname" "root" "$compute_rootpassword" "3"
				  if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
				  then
				      find_switch_root_password=$passwordToCheck
				      first_compute_ip=$root_hostname
				  fi
				  compute_rootpassword=$passwordToCheck
				  echo -e "\n"    
				  a_compute_rootpassword[$root_hostname_counter]=$compute_rootpassword
                              fi
                              root_hostname_counter=$(expr $root_hostname_counter + 1)
                          done 
                         ;;
                       *)
                          samerootpassword=1
                          echo -e "\n"
			  printf  "Enter root password ${print_compute_node}:- "
			  stty -echo
			  read -r compute_rootpassword
			  stty echo
                          root_hostname=$(cat $HOSTLIST|head -1)
                          compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $root_hostname ls >/dev/null 2>&1;echo $?);
                          if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                          then
                               echo "root password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
                          else
			      checkUserPassword "$root_hostname" "root" "$compute_rootpassword" "3"
			      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
			      then
				 find_switch_root_password=$passwordToCheck
				 first_compute_ip=$(cat $HOSTLIST|head -1)  
			      fi
			      compute_rootpassword=$passwordToCheck
			  fi
			  echo -e "\n"
                         ;;
                   esac 
               fi  
             ;;
             2) 
               rootYesNoint=2
             ;;
             3) 
               rootYesNoint=3
             ;;
             4) 
               rootYesNoint=4
                        echo -e "\nif the intent is to set up sudo configuration please have a root privileged user add the following line to the end of sudoers file using /usr/sbin/visudo on each node of cluster.\n"   
                        echo -e "${usern} ALL=(root) NOPASSWD:/tmp/root_${program_name}.sh\n"
                        exit 1
             ;;
             *)
               rootYesNoint=1
               #if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $dbm_v2 -eq 1 ]]
               if [[ -e /usr/bin/expect ]]
               then
                   echo -e "\n"
                    
                   if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
                   then      
                       read -p  "Is root password same on all compute nodes?[y/n][y]" samerootpassword_YesNo
                   else
                       read -p  "Is root password same on all nodes?[y/n][y]" samerootpassword_YesNo
                   fi
                   case $samerootpassword_YesNo in
                        y|Y|Yes|YES|yes)
                          samerootpassword=1
			  echo -e "\n"
			  printf  "Enter root password ${print_compute_node}:- "
			  stty -echo
			  read -r compute_rootpassword
			  stty echo
                          root_hostname=$(cat $HOSTLIST|head -1)
                          compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $root_hostname ls >/dev/null 2>&1;echo $?);
                          if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                          then
                               echo "root password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
                          else
			      checkUserPassword "$root_hostname" "root" "$compute_rootpassword" "3"
			      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
			      then
				 find_switch_root_password=$passwordToCheck
				 first_compute_ip=$(cat $HOSTLIST|head -1)  
			      fi
			      compute_rootpassword=$passwordToCheck
			  fi
			  echo -e "\n"
                          ;;
                        n|N|No|NO|no)
                          samerootpassword=0
                          root_hostname_counter=0
                          echo -e "\n"
                          for root_hostname in `cat $HOSTLIST`
                          do
                              compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $root_hostname ls >/dev/null 2>&1;echo $?);
                              if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                              then
                                  echo "root password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL 
                              else
				  printf  "Enter root password ${print_compute_node} $root_hostname :- "
				  stty -echo
				  read -r compute_rootpassword
				  stty echo
				  checkUserPassword "$root_hostname" "root" "$compute_rootpassword" "3"
				  if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
				  then
				      find_switch_root_password=$passwordToCheck
				      first_compute_ip=$(cat $HOSTLIST|head -1)  
				  fi
				  compute_rootpassword=$passwordToCheck
				  echo -e "\n"    
				  a_compute_rootpassword[$root_hostname_counter]=$compute_rootpassword
                              fi
                              root_hostname_counter=$(expr $root_hostname_counter + 1)
                          done 
                         ;;
                       *)
                          samerootpassword=1
                          echo -e "\n"
			  printf  "Enter root password ${print_compute_node}:- "
			  stty -echo
			  read -r compute_rootpassword
			  stty echo
                          root_hostname=$(cat $HOSTLIST|head -1)
                          compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $root_hostname ls >/dev/null 2>&1;echo $?);
                          if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                          then
                               echo "root password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
                          else
			      checkUserPassword "$root_hostname" "root" "$compute_rootpassword" "3"
			      if [[ -n "$passwordCheckStatus" && $passwordCheckStatus -eq 0 ]]
			      then
				 find_switch_root_password=$passwordToCheck
				 first_compute_ip=$(cat $HOSTLIST|head -1)  
			      fi
			      compute_rootpassword=$passwordToCheck
			  fi
			  echo -e "\n"
                         ;;
                   esac 
               fi
             ;;
       esac
    else
       #if [ $NOQUESTION = "1" ]
       if [[ $NOQUESTION = "1" && $daemon_running -eq 0 ]] && [ $DOROOT = "1" ]
       then
          rootYesNoint=2
       else
         if [[ $root_user_allowed -eq "1" ]] && [[ "$usern" = "root" || $userid -eq 0 ]] ; then
           rootYesNoint=1
         else
           rootYesNoint=3
         fi
       fi
    fi 
    if [ $is_exalogic_machine -eq "1" ] ; then rootYesNoint=1; fi;
    echo "ROOT_OPTION = $rootYesNoint" >>$MASTERFIL
    echo "$show_version_envfile">>$MASTERFIL
    #following code is to check that if data file does not have pathcing info, it should only check the best praotices
    #if [[ $SILENT -eq 0 || $SILENT -eq 1 ]]
    #if [[ -n "$rootYesNoint" && $rootYesNoint -eq 1 && ! -e /tmp/o_ibswitches.out && -n "$RAT_CELL_SSH" ]]
    if [[ -n "$rootYesNoint" && $rootYesNoint -eq 1 && ! -e ${RTEMPDIR}/o_ibswitches.out ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] && [[ $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_v2 -eq 1 ]]
    then
	first_compute_ip=$(cat $HOSTLIST|head -1)  
        if [[ -n "$compute_ssh_status" && $compute_ssh_status -ne 0 ]]
        then
	  fixRootPassword "$find_switch_root_password"
	  $EXPECT -f - << IBEOF
			   #set timeout 1
                           set timeout $passwordcheck_timeout
			   set le_find_switch_root_password "$fixedRootPassword"
			   log_user 0
			   if { "$RAT_EXPECT_DEBUG" == "-d" } {
			     exp_internal 1   
			   }
			   spawn -noecho $SSHELL root@$first_compute_ip "ibswitches>${RTEMPDIR}/o_ibswitches_full.out"
			   match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_find_switch_root_password\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF
			   $EXPECT -f - << IBEOF
			   #set timeout 1
                           set timeout $passwordcheck_timeout
			   set le_find_switch_root_password "$fixedRootPassword"
			   log_user 0
			   if { "$RAT_EXPECT_DEBUG" == "-d" } {
			     exp_internal 1
			   }  
			   spawn $SCOPY root@$first_compute_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR}
			   match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_find_switch_root_password\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF
			   $EXPECT -f - << IBEOF
			   #set timeout 1
                           set timeout $passwordcheck_timeout
			   set le_find_switch_root_password "$fixedRootPassword"
			   log_user 0
			   if { "$RAT_EXPECT_DEBUG" == "-d" } {
			     exp_internal 1
			   }   
			   spawn $SSHELL root@$first_compute_ip rm -f o_ibswitches_full.out
			   match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_find_switch_root_password\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF
	else
	    $SSHELL root@$first_compute_ip "ibswitches>${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1"
	    $SCOPY root@$first_compute_ip:${RTEMPDIR}/o_ibswitches_full.out ${RTEMPDIR} >/dev/null 2>&1
	    $SSHELL root@$first_compute_ip "rm -f ${RTEMPDIR}/o_ibswitches_full.out>/dev/null 2>&1"
	fi
    fi
#following code is find infiniband switches from first cells   
    
    if [ -e ${RTEMPDIR}/o_ibswitches_full.out ]
    then
       #for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|$AWK 'BEGIN { FS = "\" enhanced" } ;{print $1}'|awk '{print $NF}'|grep -vw localhost|cut -d' ' -f1`
       for switchname in `cat ${RTEMPDIR}/o_ibswitches_full.out|cut -d'"' -f2|awk {'print $NF}'|grep -vw localhost|cut -d' ' -f1`
       do
         $PING -c 1 $PING_W_FLAG $switchname >/dev/null 2>&1
         switchping_status=$(echo $?)
         if [ $switchping_status -eq 0 ];then echo $switchname>>${RTEMPDIR}/o_ibswitches.out;fi
       done
       rm -f ${RTEMPDIR}/o_ibswitches_full.out >/dev/null 2>&1
       cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1
    fi
    ask_switch_password=1
    if [[ -n "$run_profile" && $run_profile -eq "1" && $profile_switch_checks -eq "0" ]] ; then
      ask_switch_password=0
    fi
    if [[ -n "$exa_machine" && $exa_machine -eq 1 && -e ${RTEMPDIR}/o_ibswitches.out ]] && [[ $is_exalogic_machine -eq 1 || $dbm_v2 -eq 1 || $dbm_x2_8 -eq 1 || $dbm_x2_2 -eq 1 || $dbm_x3_2 -eq 1 ]] && [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 ]] && [ $ask_switch_password -eq "1" ]
    then
        ibswitch_root_command=9
	if [ -z "$RAT_IBSWITCH_USER" ]
        then 
            if [ $is_exalogic_machine -eq 1 ]
            then
                ibswitch_user=root
            else
                ibswitch_user=nm2user
                ibswitch_user_noformat=$ibswitch_user
                ibswitch_user=${RED}${ibswitch_user}${NORM}   
            fi
        else 
            ibswitch_user=$RAT_IBSWITCH_USER
        fi
        if [[ $root_all_prompt -eq "1" && $ibswitch_user = "root" ]] ; then
                    echo "Validating root password on INFINIBAND SWITCH"
                    echo 
          ibswitch_YesNo=1
        else
        echo -e "\n${ibswitch_root_command} of the included audit checks require ${ibswitch_user} privileged data collection on ${BLINK}INFINIBAND SWITCH${NORM} .\n"|tee -a $LOGFIL
        echo -e "\n1. Enter 1 if you will enter ${ibswitch_user} password for each ${BLINK}INFINIBAND SWITCH${NORM} when prompted"
        echo -e "\n2. Enter 2 to exit and to arrange for ${ibswitch_user} access and run the ${program_name} later."
        echo -e "\n3. Enter 3 to skip checking best practices on ${BLINK}INFINIBAND SWITCH${NORM}\n"
        read -p  "Please indicate your selection from one of the above options[1-3][1]:- " ibswitch_YesNo
        fi
        if [ -n "$ibswitch_user_noformat" ]; then ibswitch_user=$ibswitch_user_noformat;fi 
        case $ibswitch_YesNo in
             1)
	       ibswitch_password_status=1
	       if [[ $root_all_prompt -eq "1" && $ibswitch_user = "root" ]] ; then
	         ib_samerootpassword_YesNo="y"
	       else
	         echo -e "\n"
	         read -p  "Is $ibswitch_user password same on all INFINIBAND SWITCH ?[y/n][y]" ib_samerootpassword_YesNo
	       fi
	       case $ib_samerootpassword_YesNo in
		    y|Y|Yes|YES|yes)
		      ib_samerootpassword=1
		      echo -e "\n"
                      root_hostname=$(cat $OUTPUTDIR/o_ibswitches.out|head -1)
                      switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);
                      if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
                      then
                          echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
                      else
                        if [[ $root_all_prompt -eq "1" && $ibswitch_user = "root" ]] ; then
                          switch_rootpassword="$global_root_password"
                        else
		          printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
		          stty -echo
		          read -r switch_rootpassword
		          stty echo
                        fi
                          checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch"
                          switch_rootpassword=$passwordToCheck
		          echo -e "\n"
                      fi  
		      ;;
		    n|N|No|NO|no)
		      ib_samerootpassword=0
                      ib_root_counter=0
                      echo -e "\n"  
                      for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
                      do
                        switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
                        if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
                        then
                            echo -e "\n$ibswitch_user password not checked on $switchname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
                        else
			    printf "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} ${switchname} :- "
			    stty -echo
			    read -r switch_rootpassword
			    stty echo
			    checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
			    switch_rootpassword=$passwordToCheck
			    echo -e "\n" 
			    a_ib_switch_root_password[$ib_root_counter]=$switch_rootpassword
			fi
			ib_root_counter=$(expr $ib_root_counter + 1 )
                      done
		     ;;
		   *)
		      ib_samerootpassword=1
                      echo -e "\n"
                      root_hostname=$(cat $OUTPUTDIR/o_ibswitches.out|head -1)
                      switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);
                      if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
                      then
                          echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
                      else
		          printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
		          stty -echo
		          read -r switch_rootpassword
		          stty echo
                          checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
                          switch_rootpassword=$passwordToCheck
		          echo -e "\n"
                      fi 
		     ;;
	       esac 
             ;;
             2)
               ibswitch_password_status=2
               exit 1 
             ;;
             3)
               ibswitch_password_status=3
             ;;
             *)
               ibswitch_password_status=1
               echo -e "\n"
	       read -p  "Is $ibswitch_user password same on all INFINIBAND SWITCH ?[y/n][y]" ib_samerootpassword_YesNo
	       case $ib_samerootpassword_YesNo in
		    y|Y|Yes|YES|yes)
		      ib_samerootpassword=1
		      echo -e "\n"
                      root_hostname=$(cat $OUTPUTDIR/o_ibswitches.out|head -1)
                      switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);
                      if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
                      then
                          echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
                      else
		          printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
		          stty -echo
		          read -r switch_rootpassword
		          stty echo
                          checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
                          switch_rootpassword=$passwordToCheck
		          echo -e "\n"
                      fi
		      ;;
		    n|N|No|NO|no)
		      ib_samerootpassword=0
                      ib_root_counter=0
                      echo -e "\n"  
                      for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
                      do
                        switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
                        if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
                        then
                            echo -e "\n$ibswitch_user password not checked on $switchname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
                        else
			    printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} ${switchname} :- "
			    stty -echo
			    read -r switch_rootpassword
			    stty echo
			    checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
			    switch_rootpassword=$passwordToCheck
			    echo -e "\n" 
			    a_ib_switch_root_password[$ib_root_counter]=$switch_rootpassword
			fi
			ib_root_counter=$(expr $ib_root_counter + 1 )
                      done
		     ;;
		   *)
		      ib_samerootpassword=1
                      echo -e "\n"
                      root_hostname=$(cat $OUTPUTDIR/o_ibswitches.out|head -1)
                      switch_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $root_hostname ls >/dev/null 2>&1;echo $?);
                      if [[ -n "$switch_ssh_status1" && $switch_ssh_status1 -eq 0 ]]
                      then
                          echo -e "\n$ibswitch_user password not checked on $root_hostname because ssh user equivalence found for $ibswitch_user\n"|tee -a $LOGFIL
                      else
		          printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} :- "
		          stty -echo
		          read -r switch_rootpassword
		          stty echo
                          checkUserPassword "$root_hostname" "$ibswitch_user" "$switch_rootpassword" "3" "ibswitch" 
                          switch_rootpassword=$passwordToCheck
		          echo -e "\n"
                      fi  
		     ;;
	       esac
             ;;
        esac
    #else
    #    ibswitch_password_status=2            
         echo "IBSWITCH_PASSWORD_OPTION = $ibswitch_password_status" >>$MASTERFIL
         echo "IBSWITCH_PASSWORD_OPTION = $ibswitch_password_status" >>$LOGFIL
    fi
       #echo "cell_ssh_status=$cell_ssh_status">>$LOGFIL
    #lets print the nodes where root passwords are not working and ask user what does he want to do.
    if [[ -n "$noRootScriptNode" && ${#noRootScriptNode[@]} -gt 0 ]]
    then
        echo -e "${RED}root passwords for following nodes are incorrect.\n\nYou can still continue but root privileged checks will not be executed on following nodes.\n${NORM}"
        nodesNoRootPasswordCounter=1
        for nodesNoRootPassword in ${noRootScriptNode[*]}
        do
          echo -e "$nodesNoRootPasswordCounter. $nodesNoRootPassword\n"
          echo "Incorrect root password for $nodesNoRootPassword">>$LOGFIL
          nodesNoRootPasswordCounter=$(expr $nodesNoRootPasswordCounter + 1 )
        done
        nodesNoRootPasswordCounter=0
        printf "Do you want to continue[y/n][y]:- "
        read nodesNoRootPasswordYesNO
        case $nodesNoRootPasswordYesNO in
            y|Y|yes|YES|Yes) ;;
            n|N) echo ""
                 echo -e "${RED}\nPlease collect all root passwords and run $program_name again.\n${NORM}"  
                 exit 1
            ;;
           *)
             ;;
        esac    
       echo -e "\n" 
    fi 
    #-----------------

  # Stop here in daemon mode
  if [[ -n "$daemon_mode" && $daemon_mode -eq "1" ]] ; then
    mkdir $RTEMPDIR_D

    get_program_key
    export RAT_PROGRAM_KEY=$program_key
    if [ -n "$CRS" ] ; then export CRS_HOME=$CRS; fi

    ( 
      keep_running=1 
      loop_cnt_autorun=0
      while [ $keep_running -eq "1" ] ;do
        loop_cnt_autorun=$(expr $loop_cnt_autorun + 1)
        if [ -e "$RTEMPDIR_D/commands" ] ; then
          handle_client_request;
        elif [ -e "$RTEMPDIR_D/stop" ] ; then
          stop_daemon_actual;
        elif [[ $loop_cnt_autorun -eq "10" ]] ; then
          loop_cnt_autorun=0
          started_autorun=0
          start_auto_run
          if [[ $started_autorun -eq "0" ]] ; then
            check_daemon_passwords
          fi
        fi
        sleep 5;
      done
    ) &
    dpid=$!
    echo $dpid > $RTEMPDIR_D/daemon.pid
    rm -f $WRKDIR/${program_name}_daemon.log
    echo "Daemon is started with PID : $dpid";
    log_daemon "Daemon is started with PID : $dpid";
    cp $HOSTLIST $RTEMPDIR_D/.hosts.txt
    if [[ -n "$CELLIP" && -e "$CELLIP" ]] ; then cp $CELLIP $RTEMPDIR_D/.cells.txt; fi
    if [[ -n "$ZFSIP" && -e "$ZFSIP" ]] ; then cp $ZFSIP $RTEMPDIR_D/.zfs.txt; fi
    if [[ -n "${RTEMPDIR}/o_ibswitches.out" && -e "${RTEMPDIR}/o_ibswitches.out" ]] ; then cp ${RTEMPDIR}/o_ibswitches.out $RTEMPDIR_D/.ibs.txt; fi
    write_dnow_init

    run_args=$(echo $argsaved | sed 's/-d *start//' | sed 's/^ *//' | sed 's/ *$//')
    if [ -n "$run_args" ] ; then
      argsaved=$run_args
      cleanup
      $0 $run_args
      exit
    else
      exit;
    fi
  fi

    if [ $SILENT -eq 0 ]
    then
       no_patch_rollup=0 
       no_patch_rollup=`grep -ic "NO Patch rollup selected" $REFFIL1`
      
    #read -p "TYP=$TYP no_patch_rollup=$no_patch_rollup REFFIL1=$REFFIL1"
    fi
    if [[ $TYP != "-b" && $no_patch_rollup -gt 0 ]]
    then
        no_patches=1
       echo -e $RED"\nThe driver file does not have information about either OS or database patches. Therefore it will check `uname` best practices only. $NORM \n"
       echo -e "\nThe script does not have information about either OS or database patches.  Therefore it will check `uname` best practices only.\n" >>$LOGFIL
       TYP="-b" 
    fi

  if [ $upgrade_mode -eq 2 ]
  then 
      echo -e "\nChecking Grid Infrastructure and RDBMS upgrade readiness to version ${targetversion}\n"
      #if [[ -n "$NOQUESTION" && $NOQUESTION -eq 0 ]]; then read -p "Press enter to  continue.....";fi
  else
      if [ $TYP != "-p" ] 
      then
	  echo -e "\n*** Checking Best Practice Recommendations ("$GREEN"PASS"$NORM"/"$ORANGE"WARNING"$NORM"/"$RED"FAIL"$NORM") ***\n"
	  echo "*** Checking Best Practice Recommendations ***\n" >>$LOGFIL
      fi
  fi
    #echo -e $GREEN"Beginning data collection for RAC using current environment settings...\n"$NORM
    #echo "Beginning data collection for RACusing current environment settings...\n" >>$LOGFIL
#CODE TO CHECK THAT CLUSTER IS UP ON LOCAL NODE AND IF NOT,SCRIPT WILL TERMINATE
    #is_crs_up
    if [ $TYP != "-p" ]
    then
        if [ ${crs_up} -eq 1  ]
        then
           #echo -e $GREEN"CRS appears to be up on `hostname`.\n"$NORM
           echo "CRS appears to be up.\n" >>$LOGFIL
        else
            if [ $crs_installed -eq 1 ] 
            then
                #echo -e $RED"CRS appears to be down.  Skipping all CRS related audit checks. $NORM \n"
                echo "CRS appears to be down.  Skipping all CRS related audit checks.\n" >>$LOGFIL
            fi
        fi
    fi
    
    #echo "SQLNUM = $SQLNUM"
#   echo "DEBUG just before grepping for DB_VERSION"
   #### Create a master file to store database about a run and store in master table
   #SCRIPTVER=`grep DB_VERSION $REFFIL |awk {'print $3'} |sed -n 's/^M//p'`
   #SCRIPTVER=`grep DB_VERSION $REFFIL |awk {'print $3'}` 
   #### Create a master file to store database about a run and store in master table
   #FILEDATE=`grep FILE_DATE $REFFIL|sed -n 's/^M//p'`
    if [ $op_mode -eq 0 ]
    then
        FILEID=`$GREP FILE_ID $REFFIL`
        FILEDATE=`$GREP FILE_DATE $REFFIL`
        FILESIG=`$GREP FILE_SIG $REFFIL`
        DBPLATFORM=`$GREP DB_PLATFORM $REFFIL`
        OSDISTRO=`$GREP OS_DISTRO $REFFIL`
        OSVERSION=`GREP OS_VERSION $REFFIL`
        OSKERNEL=`GREP OS_KERNEL $REFFIL`
    elif [ $op_mode -eq 1 ]
    then
        FILEID=`$GREP FILE_ID $reffil_old`
        FILEDATE=`$GREP FILE_DATE $reffil_old`
        FILESIG=`$GREP FILE_SIG $reffil_old`
        if [ `uname -s` = "HP-UX" ]
        then
            DBPLATFORM=$(echo DB_PLATFORM = $os_arch_env_file)
        else
            DBPLATFORM=$(echo DB_PLATFORM = $os_name $os_arch_env_file|tr "[a-z]" "[A-Z]")
        fi
        OSDISTRO=$(echo OS_DISTRO = $os_type_full)
        OSVERSION=$(echo OS_VERSION = $os_version)
        OSKERNEL=$(echo OS_KERNEL = `uname -r`)
    fi
    echo $FILEID>>$MASTERFIL
    echo $FILEDATE>>$MASTERFIL
    echo $FILESIG>>$MASTERFIL
    #DBVERSION=`grep DB_VERSION $REFFIL`
    #echo "DB_VERSION=$DBVERSION">>$MASTERFIL
    echo $DBPLATFORM>>$MASTERFIL
    upload_dbplatform=$(echo $DBPLATFORM|cut -d= -f2)
    echo $OSDISTRO>>$MASTERFIL
    upload_osdistro=$(echo $OSDISTRO|cut -d= -f2)
    echo $OSVERSION>>$MASTERFIL
    upload_osversion=$(echo $OSVERSION|cut -d= -f2)
    echo $OSKERNEL>>$MASTERFIL
    upload_oskernel=$(echo $OSKERNEL|cut -d= -f2)
    echo "COLLECTION DATE = `date '+%d-%b-%Y %H:%M:%S'`">>$MASTERFIL
    collection_date=`date '+%d-%b-%Y %H:%M:%S'` 
    echo "SILENT = $SILENT" >>$MASTERFIL
    echo "SWITCH = $TYP">>$MASTERFIL
    echo "ASM_HOME = $ASM_HOME">>$MASTERFIL
    echo "${ORACLE_SID}_UP = $db_up">>$MASTERFIL
    echo "SOMEDB_UP = $somedb_up">>$MASTERFIL
    echo "LOCALNODE = $localnode">>$MASTERFIL
    if [ -n $cluster_name ]
    then
         echo "CLUSTER_NAME = $cluster_name">>$MASTERFIL
    fi 
   
#    put in the OS specific code in following block 


   #the database instance needs to be running in order to do the database checks
    if [[ $TYP != "-p" && $multiple_db -eq 0 ]]
    then
       if [ ${stack_dbinst_up[$stack_counter]} -ne 0 ] 
       then
           echo -e $GREEN"Database instance $ORACLE_SID appears to be up on `hostname`.  Running audit checks on $ORACLE_SID instance"$NORM>>$LOGFIL
           echo "Database instance $ORACLE_SID appears to be up on `hostname`.  Running audit checks on $ORACLE_SID instance" >>$LOGFIL
           echo ""
           singleSqlValue "version" "instance" "v"
	   VERSION=$sqlValue
	   VERSION=$(echo $VERSION|awk '{print $3}')
	   if [ "$VERSION" != "$DBVERSION" ]
	   then
	       #echo -e $RED"Audit script version ($DBVERSION) and database version ($VERSION) do not match"$NORM
	       echo "Audit script version ($DBVERSION) and database version ($VERSION) do not match" >>$LOGFIL
	       #echo ""
	       #echo -e $RED"terminating audit check..."$NORM
	       #echo "terminating audit check..." >>$LOGFIL
	       #exit 1
	   fi
       else
           if [ ${rdbms_installed[$stack_counter]} -eq 1 ]
           then
               #echo -e $RED"Database $db_name_to_check appears to be down. Skipping database related audit checks.$NORM \n"
               echo "Database instance $db_name_to_check appears to be down.  Skipping database related audit cheks.\n">>$LOGFIL
           fi
       fi
       
    fi
        
  


    #read -p "$SQLNUM $db_up"
    SQLNUM=`grep -c SQL_COMMAND $REFFIL`
   # for loop for muliple database sql collect to start here
    mb_db_counter=0
    for db_name_to_check in "${mb_db_names[@]}"
    do 
        
      echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Initial SQL COllections started for $db_name_to_check\n">>$RACCHECK_TIMING
      #echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Initial SQL COllections started for $db_name_to_check\n"
      sql_return_status=0
      SQLFIL=$OUTPUTDIR/d_check_${db_name_to_check}.sql
      UPDATEFIL=$OUTPUTDIR/db_update_${db_name_to_check}_$FDS.sql
      SPOOLFIL=$OUTPUTDIR/d_check_${db_name_to_check}.out      
      export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
      export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
      DBUSR=${mb_sysdba_user[$mb_db_counter]}
      DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
      #if [[ "$SQLNUM" -gt 0 && $TYP != "-p" ]] && [[ ${stack_db_status[$mb_db_counter]} -ne 0 || ${stack_dbinst_up[$stack_counter]} -ne 0 ]]
      if [[ "$SQLNUM" -gt 0 && $TYP != "-p" ]]
      then 
	 # Collecting stuff fro MAA
	  singleSqlValue "open_mode" "database" "v"
	  openMode=$sqlValue
	  singleSqlValue "database_role" "database" "v"
	  dbRole=$sqlValue
	  singleSqlValue "version" "instance" "v"
	  VERSION=$sqlValue
	  VERSION=$(echo "$VERSION"|awk '{print $3}')
          echo "DB_NAME = $db_name_to_check|$VERSION|$ORACLE_HOME">>$MASTERFIL
	  #read -p " see DB_VERSION $VERSION in $MASTERFIL"
	  DB=$db_name_to_check
          #mb_database_role[$mb_db_counter]=$(echo "$dbRole"|$AWK 'BEGIN { FS = "= " };{print $2}'|sed 's/ /_/')
          mb_database_role[$mb_db_counter]=$(echo "$dbRole"|$AWK -F"=" '{print $2}'|cut -d ' ' -f2-3|sed 's/ /_/')
          if [ -z "${mb_database_role[$mb_db_counter]}" ]; then mb_database_role[$mb_db_counter]=$(echo "$dbRole"|$AWK '{print $3}'|sed 's/ /_/');fi
          echo "${db_name_to_check}.DATABASE_ROLE = ${mb_database_role[$mb_db_counter]}">>$MASTERFIL
          echo "${db_name_to_check}.DATABASE_TYPE = ${mb_database_type[$mb_db_counter]}">>$MASTERFIL
          if [ ${mb_database_role[$mb_db_counter]} = "PRIMARY" ]
          then
	      singleSqlValue "global_name" "global_name" 
	      global_name=$sqlValue
              mb_database_global_name[$mb_db_counter]=$(echo "$global_name"|awk '{print $3}')
          else
	      singleSqlValue "db_unique_name" "database" "v"
	      db_unique_name=$sqlValue
              mb_database_global_name[$mb_db_counter]=$(echo "$db_unique_name"|awk '{print $3}')
          fi   
          #echo "GlobalName = ${mb_database_global_name[$mb_db_counter]}"
          #mb_database_role[$mb_db_counter]=STANDBY
	  #read -p " see $DB in $MASTERFIL"
       	  if [ ${mb_checksysdba[$mb_db_counter]} -eq 0 ]
	  then
            if [ $localnode = ${mb_running_host[$mb_db_counter]} ]
            then
	      echo "set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and   A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$ >>$MASTERFIL
	      echo "set feedback  off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0    end from gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and   A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$ >>$MASTERFIL
            else #remote_database_code
              mb_mode_line=$($SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF
                    export ORACLE_HOME=$ORACLE_HOME;
                    export ORACLE_SID=$ORACLE_SID; 
	            echo "set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and   A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$
	      echo "set feedback  off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0    end from gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and   A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s $DBUSR/$DBPWD as sysdba|grep -v ^$
EOF
)
              echo "$mb_mode_line" >> $MASTERFIL
            fi
	  else
       #following two lines were added to find out about standby like is there any logical or physical standby in use.
            if [ $localnode = ${mb_running_host[$mb_db_counter]} ]
            then
	      echo "set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and   A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$ >>$MASTERFIL
	      echo "set feedback  off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0    end from gv\$archive_dest_status a,gv\$database d where D.inst_id=a.inst_id and   A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$ >>$MASTERFIL
            else #remote_database_code
              mb_mode_line=$($SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF
                    export ORACLE_HOME=$ORACLE_HOME;
                    export ORACLE_SID=$ORACLE_SID; 
	      echo "set feedback  off heading off
   select distinct case when type = 'PHYSICAL' THEN D.NAME||'.PHYSICAL_STANDBY = '||1 ELSE D.NAME||'.PHYSICAL_STANDBY = '||0 end From gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and   A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$
	      echo "set feedback  off heading off
   select distinct case when type = 'LOGICAL' THEN D.NAME||'.LOGICAL_STANDBY = '||1 ELSE D.NAME||'.LOGICAL_STANDBY = '||0    end from gv\\\$archive_dest_status a,gv\\\$database d where D.inst_id=a.inst_id and   A.STATUS='VALID';"|$ORACLE_HOME/bin/sqlplus -s / as sysdba|grep -v ^$
EOF
)
              echo "$mb_mode_line" >> $MASTERFIL
            fi
	  fi
       fi
       #echo "database_mode : $mb_mode_line"
       mb_db_counter=$(expr $mb_db_counter + 1) 
    done
    mb_db_counter=0
# For loop for multiple database for sql collect to finish here
  echo -e "\nLog file for collections and audit checks are at\n${LOGFIL}\n"
fi #IF to check the offline mode ends here

#echo "%%%%%%%%%%%%%%%%%%%%%%$sqlValue%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"
# singleSqlValue "sysdate" "dual"
# singleSqlValue "count(instance_name)" "instance" "gv"
#---------------------------------------------------------------------
#for i in `$CRS/bin/olsnodes`

#this is test code to write database files for every run but not to overwrite for each node.
# it should work in offline as well as 
if [ "$TYP" != "-p" ]
then
   if [ -n "$DB" ]
   then
       DBACTUAL=$OUTPUTDIR/d_actual_${DB}.out
       ent_naming=$DB
       #echo "" > $DBACTUAL 
       if [ $OFFLINE -eq 0 ]
       then
           if [ $SILENT -eq 1 ]
           then
               UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_${DB}_collect)
           else
               UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_${DB})
           fi
           OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode}_${DB})
           UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_$FDS
           OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_$FDS
       fi 
   elif [ -n "${stack_asm_sid[0]}" ] 
   then
       if [ $OFFLINE -eq 0 ]
       then
           if [ $SILENT -eq 1 ]
           then
               UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_collect)
           else
               UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode})
           fi
           UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_$FDS
           OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
           OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_$FDS
       fi 
       #aName=$(echo ${stack_asm_sid[0]}|sed 's/[0-9]//g') 
       #DBACTUAL=$OUTPUTDIR/d_actual_${aName}.out
       #echo "" > $DBACTUAL 
   else
       DBACTUAL=/dev/null
     # To add hostname in collections name if database does not exists
       
       if [ $OFFLINE -eq 0 ]
       then
           if [ $SILENT -eq 1 ]
           then
              UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode}_collect)
           else
              UPLOADFIL_VAR=$(echo ${UPLOADFIL_VAR}_${localnode})
           fi
           OUTPUTDIR_VAR=$(echo ${OUTPUTDIR_VAR}_${localnode})
           OUTPUTDIR_NEW=$WRKDIR/${OUTPUTDIR_VAR}_$FDS
           UPLOADFIL=$WRKDIR/${UPLOADFIL_VAR}_$FDS
       fi
   fi
fi
#if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm $OUTPUTDIR/d_actual_*.out >/dev/null 2>&1;fi;
if [[ -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm $OUTPUTDIR/d_actual_*.out >/dev/null 2>&1;fi;
#if [[ -e $DBACTUAL &&  -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm $DBACTUAL >/dev/null 2>&1;fi;
#read -p "DB=$DB"
#read -p "UPLOADFIL=$UPLOADFIL OUTPUTDIR_NEW=$OUTPUTDIR_NEW"

#this is where xml for em plug gets initialized
xml_prefix1="$program_name"
xml_prefix2="$program_name"
xml_prefix3="$program_name"
if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
then
  rack_type=$EXALOGIC_RACK
  engs_machine="Exalogic"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq "1" ]]
then
  rack_type=N/A
  engs_machine="Exalytics"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] 
then
  rack_type=$EXADATA_RACK
  engs_machine="Exadata"
  xml_prefix1="Exacheck"
  xml_prefix2="ExaCheck"
  xml_prefix3="exacheck"
elif [[ -n "$oda_machine" && $oda_machine -eq 1 ]]
then
  rack_type=""
  engs_machine="Database Appliance"
else
  rack_type=""
  engs_machine=""
fi
echo "<${xml_prefix1}Results modelVersion=\"$modelVersion\" RackType=\"$rack_type\" EngineeredSystems=\"$engs_machine\" RackIdentifier=\"$RackIdentifier\" ExadataType=\"$EXADATA_VERSION\" xsi:noNamespaceSchemaLocation=\"${xml_prefix3}_result.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">" >$XMLREPFIL
echo "<${xml_prefix2}Exclusions modelVersion=\"$modelVersion\" RackType=\"$rack_type\" EngineeredSystems=\"$engs_machine\" RackIdentifier=\"$RackIdentifier\" ExadataType=\"$EXADATA_VERSION\" xsi:noNamespaceSchemaLocation=\"${xml_prefix3}_exclusion.xsd\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">" >$XMLSKIPFIL

if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]; then
  touch $COLLECT_TIMING
fi

if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]; then
  html_rack_type="System"
fi

if [ -z "$RAT_RUNMODE_INTERNAL" ] ; then
  RAT_RUNMODE_INTERNAL="master"
fi

parallel_run_feaible=0
if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]] || [[ -e "$EXPECT" ]] || [[ $rootYesNoint -eq "3" ]] || [[ "$usern" = "root" || $userid -eq 0 ]] ; then
  parallel_run_feaible=1
fi

#echo "parallel_run_feaible=$parallel_run_feaible"

if [[ -z "$RAT_COMPUTE_RUNMODE" ]] ; then RAT_COMPUTE_RUNMODE="parallel"; fi;
if [[ $RAT_RUNMODE_INTERNAL = "master" && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" && $parallel_run_feaible -eq "0" && $localonly -eq "0" ]] ; then
  RAT_COMPUTE_RUNMODE="serial"
  echo -e "${RED}Running ${program_name} in $RAT_COMPUTE_RUNMODE mode because expect($EXPECT) is not available to supply root passwords on remote nodes${NORM}" |tee -a $LOGFIL
  echo
  echo -e "${RED}NOTICE:  Installing the expect utility (/usr/bin/expect) will allow ${program_name} to gather root passwords at the beginning of the process and execute ${program_name} on all nodes in parallel speeding up the entire process. For more info - http://www.nist.gov/el/msid/expect.cfm.  Expect is available for all major platforms.  See User Guide for more details.${NORM}"
  echo;
fi

echo "Running in $RAT_COMPUTE_RUNMODE mode" >> $LOGFIL 

if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]] 
then
#echo "#### $INPUTDIR $OUTPUTDIR $DUMPDIR";
  OFFLINE=0
  TYP=$RUNSWITCH
  #outdir=`dirname $MASTERFIL`
  #indir=$INPUTDIR
  #INPUTDIR=$(ls -d `pwd`/.input_*|tail -1)
  #cp -R $INPUTDIR $indir
  #cp -R $OUTPUTDIR $outdir
  localnode=$RAT_LOCALNODE_INTERNAL
  echo $localnode  > $HOSTLIST
  #hostname |cut -d"." -f1 > $HOSTLIST
  #localnode=$(hostname |cut -d"." -f1)

  mb_db_counter=0
  for db_name_to_check in "${mb_db_names[@]}"
  do
    l_oh=$(grep -w "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
    mb_oracle_homes[$mb_db_counter]=$l_oh
    mb_db_counter=$(expr $mb_db_counter + 1)
  done
  cp $INPUTDIR/*.dat $DUMPDIR
  cp $INPUTDIR/*.sh $DUMPDIR
  REFFIL=$DUMPDIR/collections.dat
  REFFIL1=$DUMPDIR/rules.dat
  ORCLENVFIL=$DUMPDIR/set_orcl_env.sh
  #PROFILE="$HOME/.bash_profile"
  #if [ ! -f $PROFILE ]; then PROFILE="$HOME/.profile";fi
  #v_crs_home_bin=$(ps -ef |grep crsd.bin|grep -v grep|awk '{print $8}')
  #usern=`whoami`
  root_need_cell_ssh=0
  if [ $op_mode -eq 1 ]
  then  
    REQUIRE_ROOT=`grep  "REQUIRES_ROOT_COUNT" $REFFIL|sed  -n 's/.*REQUIRES_ROOT_COUNT //p'| sed 's/^ *\(.*\) *$/\1/'`
  else
    REQUIRE_ROOT=`grep -c "REQUIRES_ROOT 1" $REFFIL`
  fi

  compute_rootpassword="$root_pass";
  if [[ -n "$RAT_COMPUTEPASSWORD_INTERNAL" && $RAT_COMPUTEPASSWORD_INTERNAL -ne "3" ]] ; then
    samerootpassword=1
  fi

  final_components=$components

  ea_db_node="$RAT_EA_DB_NODE_INTERNAL"
  ea_ec1_node="$RAT_EA_EC1_NODE_INTERNAL"
  ea_ovmm_node="$RAT_EA_OVMM_NODE_INTERNAL"
  ea_pc1_node="$RAT_EA_PC1_NODE_INTERNAL"
  ea_pc2_node="$RAT_EA_PC2_NODE_INTERNAL"
  print_pass_on_screen=$RAT_PRINT_PASS_ON_SCREEN_INTERNAL
  cp $MASTERFIL $MASTERFIL.saved
fi


if [[ $OFFLINE -eq 0 && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
  stack_counter_l=1
  for i in `cat $HOSTLIST |grep -v $localnode`
  do
    if [[ -n "$samerootpassword" && $samerootpassword -eq 0 ]] ; then
      compute_rootpassword=${a_compute_rootpassword[$stack_counter_l]}
      stack_counter_l=$(expr $stack_counter_l + 1)
    fi
    $SCOPY $SYSTEM_DESC_FIL $i:$RTEMPDIR/ > /dev/null 2>&1
    echo -e "\nStarting to run ${program_name} in background on $i\n"
    rm -f $RTEMPDIR/run.pid
    cr_file=$RTEMPDIR/${program_name}_compute_$i.sh
    run_file=$RTEMPDIR/${program_name}_run_slave_$i.sh
    echo "#!$bash_scr" > $cr_file
    echo "echo \$\$ > $RTEMPDIR/run.pid" >> $cr_file
    echo "$SSHELL $i $run_file" >> $cr_file
    chmod +x $cr_file

    echo "#!$bash_scr" > $run_file
    echo "cd $RTEMPDIR; export RAT_RUNMODE_INTERNAL=slave; " >> $run_file
    echo "export RAT_LOCALNODE_INTERNAL=\"$i\"; " >> $run_file
    echo "export RAT_FDS_INTERNAL=\"${FDS}\"; " >> $run_file
    echo "export RAT_COMPUTE_RUNMODE=\"parallel\"; " >> $run_file
    #if  [[ $rootYesNoint -ne "3" ]] ; then
    #  echo "read -s -p \"Enter root password:\" root_pass" >>$run_file
    #  echo "read -s -p \"Start the run:\" run_start" >>$run_file
    #fi
    echo "export RAT_COMPUTEPASSWORD_INTERNAL=\"$rootYesNoint\"; " >> $run_file
    #echo "echo \"root password is \$root_pass\"" >> $run_file
    #echo "export RAT_COMPUTEPASSWORD_INTERNAL=\"$compute_rootpassword\"; " >> $run_file
    echo "export RAT_PRINT_PASS_ON_SCREEN_INTERNAL=\"$print_pass_on_screen\"; " >> $run_file
    echo "export RAT_EA_DB_NODE_INTERNAL=$ea_db_node" >> $run_file
    echo "export RAT_EA_EC1_NODE_INTERNAL=$ea_ec1_node" >> $run_file
    echo "export RAT_EA_OVMM_NODE_INTERNAL=$ea_ovmm_node" >> $run_file
    echo "export RAT_EA_PC1_NODE_INTERNAL=$ea_pc1_node" >> $run_file
    echo "export RAT_EA_PC2_NODE_INTERNAL=$ea_pc2_node" >> $run_file
    # Set all RAT_ env in remote nodes also
    env | grep RAT_ | grep -wv RAT_OUTPUT > $OUTPUTDIR/rat_env.txt
    while read envs
    do
      e_key=$(echo $envs| cut -d"=" -f1)
      e_val=$(echo $envs| sed 's/[^=]*=//')
      echo "export $e_key=\"$e_val\"" >> $run_file
    done < $OUTPUTDIR/rat_env.txt
    echo "echo > $RTEMPDIR/empty.log" >> $run_file
    echo "echo > $RTEMPDIR/empty.log" >> $run_file
    echo "echo > $RTEMPDIR/empty.log" >> $run_file
    scr=$(basename $0)
    #echo "./$scr -f < $RTEMPDIR/empty.log" >> $run_file
    if [[ -n "$bash_path" ]] ; then
      echo "export PATH=$bash_path:$PATH" >> $run_file
    fi
    if [ -n "$options_components" ]; then
      echo "$bash_scr ./$scr -f -c $options_components" >> $run_file
    else
      echo "$bash_scr ./$scr -f" >> $run_file
    fi
    chmod +x $run_file
    $SCOPY -r $run_file $0 $SCRIPTPATH/collections.dat $SCRIPTPATH/rules.dat $SCRIPTPATH/.cgrep/ $INPUTDIR $OUTPUTDIR $i:$RTEMPDIR/ > /dev/null 2>&1
    if [ -e "$EXCLUDEFIL" ] ; then
      $SCOPY $EXCLUDEFIL $i:$RTEMPDIR/ > /dev/null 2>&1
    fi

    if  [[ $rootYesNoint -eq "3" ]] ; then
      $cr_file > $OUTPUTDIR/$i.slave.log 2>&1 &
      run_pid=$!
    else
      fixRootPassword "$compute_rootpassword"
      /usr/bin/expect -f - > $OUTPUTDIR/$i.slave.log 2>&1 << IBEOF &
        if { "$RAT_EXPECT_DEBUG" == "-d" } {
          exp_internal 1
        }
        set timeout $passwordcheck_timeout
	set le_compute_rootpassword "$fixedRootPassword"
        spawn -noecho $cr_file
        match_max 100000
        log_user 0
        expect "password:*";
	send -- "\$le_compute_rootpassword\n";
        expect "run:*";
        send -- "\n";
        set timeout -1
        log_user 1
        expect eof
        exit
IBEOF
    #run_pid=$(cat $RTEMPDIR/run.pid)
      run_pid=$!
    fi
    touch $RTEMPDIR/nowatch.pid
    echo "$run_pid" >>  $RTEMPDIR/nowatch.pid
    cpids[$run_pid]="$run_pid";
    cpid_names[$run_pid]="$i"
  done

  # Master runs only on local node
  mv $HOSTLIST $HOSTLIST.org
  echo $localnode > $HOSTLIST
fi

#echo "Using $REFFIL";

for i in `cat $HOSTLIST`
do
  echo "=============================================================" |tee -a $LOGFIL |tee -a $REPFIL_FAIL|tee -a $SREPFIL_FAIL|tee -a $SREPFIL_PASS|tee -a $REPFIL_PASS
  echo "                    Node name - $i                                " |tee -a $LOGFIL |tee -a $REPFIL_FAIL|tee -a $SREPFIL_FAIL|tee -a $SREPFIL_PASS|tee -a $REPFIL_PASS
  echo "=============================================================" |tee -a $LOGFIL |tee -a $REPFIL_FAIL|tee -a $SREPFIL_FAIL|tee -a $SREPFIL_PASS|tee -a $REPFIL_PASS
 #tried to fix not to execute opatch if another nodes does not have oracle binaries.
  if [[ ${crs_installed[$stack_counter]} -eq 0 && $single_instance_run -eq "0" ]]; then TYP="-b";fi;
  if [[ ${crs_installed[$stack_counter]} -eq 0 && ${rdbms_installed[$stack_counter]}  -eq 0 ]]; then TYP="-b";fi;
 #
 #calling Exa functions to re-assign modules for each not to support hybrid racks
 if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]; then  assign_exalogic_module "$i" ;fi
 if [[ "$i" != "$localnode" || $RAT_RUNMODE_INTERNAL = "slave" ]] ; then is_this_db_machine $i;add_maa_scorecard;add_hacheck; write_db_machine_info_to_envfile $i;fi 

  # assign the right status for stack variables
  assign_stack_status;

 ACREPCOUNT=0
 call_zfs_collection=1

 if [[ -n "$run_profile" && $run_profile -eq "1" && `echo "$profiles2run" | grep -icw zfs` -eq "0" ]] ; then
   call_zfs_collection=0
 fi # In profile run call zfs collection only if zfs profile is selected

 if [[ $call_zfs_collection -eq "1" ]] ; then
   if [ $is_ssc_machine -eq 2  ]
   then
       execute_zfs_collection "$ZFSIP" "$SCRIPTPATH/.cgrep/exalogic_zfs_checks.aksh"
   elif [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
   then
    execute_zfs_collection "$CELLIP" "$SCRIPTPATH/.cgrep/exalogic_zfs_checks.aksh"
   fi
 fi
 #this fucction will check either its a db machine or not for each node
 if [ $RUNSWITCH != "-p" ]
 then
  case $TYP in
  -a|-b|-f|-u)
   current_check=1
   CUR_LEVEL=1   
   #following if is to set L1 to 1 in offline if there are no OS_COLLECT in data file and osCheckIndexNo has value like -OSCOLLECTCOUNT 0. did this chage for Exalytics 
   if [[ $OFFLINE -eq 1 && `echo $osCheckIndexNo|grep -c [A-Z]` -ge 1 ]];then osCheckIndexNo=1;fi
   #this is to skip collections in offline
   if [ $OFFLINE -eq 0 ];then L1=1;else L1=$osCheckIndexNo;fi
   L2=0;L3=0;L4=0;L5=0;L6=0;L7=0;L8=0;L9=0;L10=0;
   ROW=$L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10
   OSSPOOLFIL="$OSOUTFIL"_"$i".out
   ROOTSCRPT="$INPUTDIR/root_${program_name}".sh
   IBSWITCHSCRPT="$INPUTDIR/${program_name}_ibswitch".sh
   CELLSSCRPT="$INPUTDIR/${program_name}_cells".sh
   if [ -f $ROOTSCRPT ];then rm -f $ROOTSCRPT; fi;
   if [ $op_mode -eq 1 ]
   then
       OSCOLLECTSUM=`grep  "OS_COLLECT_COUNT" $REFFIL|sed  -n 's/.*OS_COLLECT_COUNT //p'| sed 's/^ *\(.*\) *$/\1/'`
   else
       OSCOLLECTSUM=`grep -c "OS_COLLECT_COMMAND" $REFFIL`
   fi
   #read -p "OSCOLLECTSUM=$OSCOLLECTSUM"
   OSCOLLECTCNT=0
   OSCHECKRESULT=$OUTPUTDIR/o_audit_result_${i}.out
   OSPKGSILENT=$OUTPUTDIR/o_pkg_status_silent_${i}.out
   OSACTUAL=$OUTPUTDIR/o_actual_${i}.out
   AACTUAL=$OUTPUTDIR/a_actual_${i}.out
   if [[ -e $OSACTUAL &&  -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm $OSACTUAL >/dev/null 2>&1;fi;
   if [[ -e $AACTUAL &&  -n "$RUNMODE" && $RUNMODE -eq 1 && $OFFLINE -eq 1 ]]; then rm $AACTUAL >/dev/null 2>&1;fi;

   # store the old value for clusterware_check_count for previous compute node because if current node is control VM than clusterware_check_count will not increase
   if [[ -n "$clusterware_check_count" &&  $clusterware_check_count -gt 0 ]]; then clusterware_check_count_old=$clusterware_check_count;fi
   #read -p "clusterware_check_count=$clusterware_check_count clusterware_check_count_old=$clusterware_check_count_old"
   clusterware_check_count=0
   collect_file_counter=0
   cls_check_host_list[$stack_counter]=$i
   #echo "" >$OSACTUAL
   if  [ $OFFLINE -eq 0 ]
   then
       echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Execution started on $i\n">>$RACCHECK_TIMING
       if [[ $SUDOCMD != "/usr/bin/sudo" ]]
       then
          # A valid sudo command was set up, so I know this is being run by Oracle and I don't need the below environment variables.  I need the
          # root_raccheck.sh script to look exactly the same in every instance so that the Dell sudo command works and adding specific system
          # environment variables will mess that up!
          ORACLEENVVARS=SetOracleEnvVars
          echo "#!$bash_scr">>/tmp/$ORACLEENVVARS
          echo "$bash_source">>/tmp/$ORACLEENVVARS
          echo "export ORACLE_HOME=$ORACLE_HOME">>/tmp/$ORACLEENVVARS
          echo "export CRS_HOME=$CRS">>/tmp/$ORACLEENVVARS
          echo "export ORACLE_SID=$ORACLE_SID">>/tmp/$ORACLEENVVARS
          echo "">>$ROOTSCRPT
          echo ". /tmp/$ORACLEENVVARS">>$ROOTSCRPT
          echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\" >>${RTEMPDIR}/o_root_collect_timing.out" >>$ROOTSCRPT
       else
          ORACLEENVVARS=SetOracleEnvVarsPlaceHolder
          echo "#!$bash_scr">>$ROOTSCRPT
          echo "$bash_source">>$ROOTSCRPT
          echo "if [ -e $PROFILE ]; then . $PROFILE>/dev/null 2>&1;fi">>$ROOTSCRPT   
          echo "export ORACLE_HOME=$ORACLE_HOME">>$ROOTSCRPT
          echo "export CRS_HOME=$CRS">>$ROOTSCRPT
          #echo "export ORA_CRS_HOME=$CRS">>$ROOTSCRPT
          echo "export ORACLE_SID=$ORACLE_SID">>$ROOTSCRPT
          echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\\n\" >>${RTEMPDIR}/o_root_collect_timing.out" >>$ROOTSCRPT
          if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 ]]
          then 
              echo "export PATH=\$PATH:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:/opt/MegaRAID/MegaCli/:/opt/oracle/cell/cellsrv/bin">>$ROOTSCRPT
              echo "export OSS_BIN=/opt/oracle/cell/cellsrv/bin">>$ROOTSCRPT
          fi
       fi
       if [[ -n "$ibswitch_password_status" && $ibswitch_password_status -eq 1 ]]
       then 
           echo "#!/bin/env bash">>$IBSWITCHSCRPT
           echo "export RTEMPDIR=$RTEMPDIR">>$IBSWITCHSCRPT
           echo "export SWITCH_TYPE_FIL=${RTEMPDIR}/${SWITCH_TYPE_FIL_SHORT}">>$IBSWITCHSCRPT
           echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\\n\" >>${RTEMPDIR}/s_root_collect_timing.out" >>$IBSWITCHSCRPT
       fi
       if [[ $root_need_cell_ssh -eq 0 ]]
       then 
           echo "#!/bin/env bash">>$CELLSSCRPT
           echo "if [ -e $PROFILE ]; then . $PROFILE>/dev/null 2>&1;fi">>$CELLSSCRPT
           echo "export PATH=\$PATH:/usr/local/bin:/bin:/usr/bin:/sbin:/usr/sbin:/opt/MegaRAID/MegaCli/:/opt/oracle/cell/cellsrv/bin">>$CELLSSCRPT
           echo "export OSS_BIN=/opt/oracle/cell/cellsrv/bin">>$CELLSSCRPT
           echo "export RTEMPDIR=$RTEMPDIR">>$CELLSSCRPT
           echo "echo -e \"\\n\\n\`date '+%a %b %d %H:%M:%S %Y'\` - STARTED ON  \`hostname|cut -d. -f1\`\\n\" >>${RTEMPDIR}/c_root_collect_timing.out" >>$CELLSSCRPT
       fi
       chmod 755 $ORCLENVFIL
       if [ $i = $localnode ]
       then

           cp $ORCLENVFIL /tmp/ 2>/dev/null
           cp $MASTERFIL /tmp/ 2>/dev/null
       else
           #following code is to put the correct ORACLE_SID in ORAENVFIL which is used to set the environment on each host
           sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
           cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
           rm $INPUTDIR/tmp_env_file.out
           echo "export ORACLE_SID=${stack_dbinst_name[$stack_counter]}">>$ORCLENVFIL
           $SCOPY $ORCLENVFIL $i:/tmp/ >/dev/null
           $SCOPY $MASTERFIL $i:/tmp/ >/dev/null 
       fi
       TRGTORCLENV=/tmp/`basename $ORCLENVFIL`
#end here
   fi
   #ROOTFLG=0
   #no_of_checks_to_execute=$(grep -c "CHECK_ID" $REFFIL)
   #last_check_in_dat=$(cat $REFFIL|sed -n ''${no_of_checks_to_execute}'p'|cut -d\. -f1|cut -d_ -f2) 
   #read -p "no_of_checks_to_execute=$no_of_checks_to_execute last_check_in_dat=$last_check_in_dat"
#   db_name_to_check=$(cat $running_db_list|sed -n ''${db_to_check}'p') 
   while [ -n "$ROW" ]
   #while [ "$ROW" -le $last_check_in_dat ]
   do
   #  read -p "ROW=$ROW"
     while [[ -z "$LEVEL" && $CUR_LEVEL -gt 0 ]]
     do
       #LEVEL=`grep _$ROW\-LEVEL $REFFIL |awk {'print $2'}`
       LEVEL=`grep _$ROW\-LEVEL $REFFIL |cut -d- -f2|awk '{print $2}'`
       #LEVEL=`grep _$ROW $REFFIL |awk {'print $2'}`
       #echo "ROW=$ROW, LEVEL=$LEVEL"
       if [[ -z "$LEVEL" && $L1 -gt 0 ]]
       then
         #we didn't find anything for the current ROW
         #that being the case we need to traverse up a level and keep looking
         #until we have nowhere else to look
          case $CUR_LEVEL in
          10) L10=0; L9=$(($L9+1)); CUR_LEVEL=9 ;;
           9) L9=0; L8=$(($L8+1)); CUR_LEVEL=8 ;;
           8) L8=0; L7=$(($L7+1)); CUR_LEVEL=7 ;;
           7) L7=0; L6=$(($L6+1)); CUR_LEVEL=6 ;;
           6) L6=0; L5=$(($L5+1)); CUR_LEVEL=5 ;;
           5) L5=0; L4=$(($L4+1)); CUR_LEVEL=4 ;;
           4) L4=0; L3=$(($L3+1)); CUR_LEVEL=3 ;;
           3) L3=0; L2=$(($L2+1)); CUR_LEVEL=2 ;;
           2) L2=0; L1=$(($L1+1)); CUR_LEVEL=1 ;;
           1) L1=0; CUR_LEVEL=0 ;;
          esac

          if [ $L1 -gt 0 ]
          then
             ROW=$L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10
          else
             ROW=
          fi
          #echo "CURRENT LEVEL MAIN LOOP = $CUR_LEVEL"
       fi
       #echo "LOOP ROW = $ROW" 
     done
     unset execute_once COMTYPE PARAM_PATH ISBRANCH REQUIRES_ROOT_OS PARAM NEEDS_RUNNING OP COMP ALVL PMSG FMSG SF CAT SUBCAT COM_REPORT SOURCEFIL_REPORT SOURCEFIL_REPORT_NEW audit_check_name OPSTAT database_mode check_exadata_version check_database_role check_database_type


     
   # _1.0.0.0.0.0.0.0.0.0-LEVEL 1-CHECK_ID 5ADE41BF1E15571AE0401490CACF3E60 
   # gadiga added multiple version support whcih appends version to end
     if [ $op_mode -eq 1 ] 
     then
         CHECK_ID=`grep "_${ROW}-LEVEL ${LEVEL}-CHECK_ID" $REFFIL|sed  -n 's/.*CHECK_ID //p'| sed 's/^ *\(.*\) *$/\1/'`
     else
         CHECK_ID=`grep "_${ROW}-CHECK_ID" $REFFIL|sed  -n 's/.*CHECK_ID //p'| sed 's/^ *\(.*\) *$/\1/'`
     fi    
     run_in_multiple_versions=0
     versions_to_run=""
     if [ `echo "$CHECK_ID" | grep -c " "` -gt 0 ]
     then
       run_in_multiple_versions=1
       versions_to_run="$CHECK_ID";
       CHECK_ID=$(echo "$CHECK_ID" | awk '{print $1}')
       versions_to_run=$(echo $versions_to_run | sed 's/'$CHECK_ID' //')
       if [ -n "$RAT_DEBUG_V" ] ; then echo "$ROW $CHECK_ID runs only on $versions_to_run"; fi;
     else
       if [ -n "$RAT_DEBUG_V" ] ; then echo "$ROW $CHECK_ID is running"; fi;
     fi
     #run_in_multiple_versions=0
     #read -p "CHECK_ID=$CHECK_ID $REFFIL $REFFIL1 ROW=$ROW LEVEL=$LEVEL"
     CLUSTERCHECK_FIL=${OUTPUTDIR}/${CHECK_ID}.out
     if [ $op_mode -eq 0 ]
     then 
	  COMTYPE=`grep _$ROW\-TYPE $REFFIL |awk {'print $2'}` 
	  PARAM_PATH=`grep _$ROW\-PARAM_PATH $REFFIL |awk {'print $2'}` 
	  HOME_PATH=`grep _$ROW\-HOME_PATH $REFFIL |awk {'print $2'}` 
	  ISBRANCH=`grep _$ROW\-IS_BRANCH $REFFIL |awk {'print $2'} `
	  REQUIRES_ROOT_OS=`grep _$ROW\-REQUIRES_ROOT $REFFIL |awk {'print $2'}`
	  PARAM=`grep "_"$ROW"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
	  NEEDS_RUNNING=`grep "_"$ROW"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
	  execute_once=`grep "_"$ROW"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
	  SF=`grep "_"$ROW"-SF" $REFFIL |sed  -n 's/.*-SF //p'` 
	  check_components=`grep "_"$ROW"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
	  OP=`grep _$ROW\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
          if [[ -z "$OP && -e $REFFIL1 ]];then OP=`grep _$ROW\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
	  COMP=`grep "_"$ROW"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'` 
          if [[ -z "$COMP && -e $REFFIL1 ]];then COMP=`grep "_"$ROW"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
          check_exadata_version=$(grep "_"$ROW"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
          check_database_role=$(grep "_"$ROW"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
          check_database_type=$(grep "_"$ROW"-DATABASE_TYPE" $REFFIL |sed  -n 's/.*DATABASE_TYPE //p'| sed 's/^ *\(.*\) *$/\1/')
          check_database_mode=$(grep "_"$ROW"-DATABASE_MODE" $REFFIL |sed  -n 's/.*DATABASE_MODE //p'| sed 's/^ *\(.*\) *$/\1/')
     else
          COMTYPE=`grep _$CHECK_ID\-TYPE $REFFIL |awk {'print $2'}` 
          #read -p "COMTYPE =$COMTYPE"
	  PARAM_PATH=`grep _$CHECK_ID\-PARAM_PATH $REFFIL |awk {'print $2'}` 
	  HOME_PATH=`grep _$CHECK_ID\-HOME_PATH $REFFIL |awk {'print $2'}` 
	  ISBRANCH=`grep _$CHECK_ID\-IS_BRANCH $REFFIL |awk {'print $2'} `
	  REQUIRES_ROOT_OS=`grep _$CHECK_ID\-REQUIRES_ROOT $REFFIL |awk {'print $2'}`
	  PARAM=`grep "_"$CHECK_ID"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
	  NEEDS_RUNNING=`grep "_"$CHECK_ID"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
	  execute_once=`grep "_"$CHECK_ID"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
          check_exadata_version=$(grep "_"$CHECK_ID"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
          check_database_role=$(grep "_"$CHECK_ID"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
          check_database_type=$(grep "_"$CHECK_ID"-DATABASE_TYPE" $REFFIL |sed  -n 's/.*DATABASE_TYPE //p'| sed 's/^ *\(.*\) *$/\1/')
          check_database_mode=$(grep "_"$CHECK_ID"-DATABASE_MODE" $REFFIL |sed  -n 's/.*DATABASE_MODE //p'| sed 's/^ *\(.*\) *$/\1/')
	  SF=`grep "_"$CHECK_ID"-SF" $REFFIL |sed  -n 's/.*-SF //p'` 
	  check_components=`grep "_"$CHECK_ID"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
	  OP=`grep _$CHECK_ID\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
          if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$CHECK_ID\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
	  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'` 
          if [[ -z "$COMP" && -e $REFFIL1 ]];then  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
     fi
     
     if [[ -n "$LEVEL" &&  $LEVEL -eq "1" ]]
     then  # Unset array used for holding OPSTAT values in multi db case
       # $m_opstat[$CUR_LEVEL]=db1,db2,db3 where opstat=1
       unset m_opstat 
     fi 
 #code to handle mixed hardware storage cells   
     if [[ $mixed_hardware -gt 1 && "$COMTYPE" = "OS_OUT_CHECK" && "$NEEDS_RUNNING" = "STORAGE_CELL" && "$i" = "$localnode" && $RAT_RUNMODE_INTERNAL = "master" ]]
     then
         old_components=$components
         if [[ $mixed_hardware_v2 -ge 1 && `echo $check_components|grep -wc "DBM"` -ge 1 && `echo $components|grep -wc "EXADATA"` -eq 0 ]]
         then
             components=$(echo $components:EXADATA)
         fi   
         if [[ $mixed_hardware_x2_2 -ge 1 && `echo $check_components|grep -wc "X2-2"` -ge 1 && `echo $components|grep -wc "X2-2"` -eq 0 ]]
         then
             components=$(echo $components:X2-2)
         fi  
         if [[ $mixed_hardware_x3_2 -ge 1 && `echo $check_components|grep -wc "X3-2"` -ge 1 && `echo $components|grep -wc "X3-2"` -eq 0 ]]
         then
             components=$(echo $components:X3-2)
         fi  
     fi
 #code to handle mixed hardware storage cells   

     #if [ -n "$it_is_rac_old" ]; then it_is_rac=$it_is_rac_old;fi
     if [ `echo $components|grep -iwc EXADATA` -ge 1 ] && [[ `echo $check_components|grep -wc "DBM"` -ge 1 ]]; then check_components=$(echo $check_components|sed 's/:/ /g'|sed 's/\<DBM\>/EXADATA/g'|sed 's/ /:/g');fi
     if [ "$components" = "RDBMS" ] && [[ $old_check_components = "DBM:RDBMS" || $old_check_components = "DBM:RDBMS:UPGR" ]]; then check_components=RDBMS;fi 
     old_check_components=$check_components
     component_match_count=0 
     loop_check_components=$(echo $check_components|sed 's/:/ /g')
     for check_component in $loop_check_components
     do
        component_match_count1=$(echo $components|grep -icw $check_component)
        if [[ -n "$component_match_count1" && $component_match_count1 -ge 1 ]]; then component_match_count=$(expr $component_match_count + 1 );fi
     done  
    
     # Profiles
     if [[ -n "$run_profile" && $run_profile -eq "1" ]] ; then
       in_profile=0
       check_in_profiles
       if [[ $in_profile -eq "0" ]] ; then 
         component_match_count=0; 
         echo "Skipping check (id $CHECK_ID) because its not in profile $profiles2run"  >> $LOGFIL
       fi;
     fi
    #components=$saved_components

     # For multiple_version_support we add new checks at the end.
     # The new check may be a collection which can't run in offline
     if [[ $run_in_multiple_versions -eq 1 && $OFFLINE -eq "1" ]]
     then
       if [[ $COMTYPE = "OS_COLLECT" || $COMTYPE = "SQL_COLLECT" ]]
       then #bypass collections in offiline mode
         COMTYPE="NOCOLLECT"
         call_get_log_result=0;
       fi
     fi
#if check_exadat_version is null than set very high values so it will execute for any exadata version. this is temporary fix until we have version for all checks
     check_exadata_version=$(echo $check_exadata_version|sed 's/ //g')       
     check_exadata_version=$(echo $check_exadata_version|sed 's/\.//g')
     if [ -z "$check_exadata_version" ]; then check_exadata_version=912240;fi
     
     #To delete white space from check_databaes_Role and to handle old checks where database_role is not assigned so default is primary
     check_database_role=$(echo $check_database_role|sed 's/ //g')       
     if [ -z "$check_database_role" ]; then check_database_role=PRIMARY;fi

     #To delete white space from check_databaes_type and to handle old checks where database_type is not assigned so default is normal
     check_database_type=$(echo $check_database_type|sed 's/ //g')       
     if [ -z "$check_database_type" ]; then check_database_type="NORMAL:CDB";fi

     #To delete white space from check_databaes_mode and to handle old checks where database_mode is not assigned so default is open
     check_database_mode=$(echo $check_database_mode|sed 's/ //g')       
     if [ -z "$check_database_mode" ]; then check_database_mode=3;fi

     #echo  "check_components=$check_components and components=$components component_match_count=$component_match_count for $CHECK_ID"
     if [[ $COMTYPE = "OS" && $REQUIRES_ROOT_OS = 1 ]]
     then
         echo "$COMTYPE" >/dev/null 2>&1
     fi     
     if [ $SILENT -eq "0" ]
     then
         if [ $op_mode -eq 0 ]
         then
	      ALVL=`grep _$ROW\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
	      PMSG=`grep "_"$ROW"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
	      FMSG=`grep "_"$ROW"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
	      CAT=`grep "_"$ROW"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
	      SUBCAT=`grep "_"$ROW"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
         else
	      ALVL=`grep _$CHECK_ID\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
	      PMSG=`grep "_"$CHECK_ID"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
	      FMSG=`grep "_"$CHECK_ID"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
	      CAT=`grep "_"$CHECK_ID"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
	      SUBCAT=`grep "_"$CHECK_ID"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
         fi 
	 ALVL_CHECK=$ALVL
     fi
     case $COMTYPE in
     OS) 
       #read -p "$PARAM $crs_installed $rdbms_installed "
       #read -p "2=${stack_crs_up[$stack_counter]} and stack counter is $stack_counter"
       
      # read -p "1=$NEEDS_RUNNING  2=${stack_crs_up[$stack_counter]}this is   3=$NEEDS_RUNNING   4=${stack_dbinst_up[$stack_counter]} "
       if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
       then
           call_get_log_result=0
       elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
       then
           call_get_log_result=0
       elif [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
       then
           call_get_log_result=0 
           echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL 
       #elif  [[ -n "$it_is_rac" && $it_is_rac -eq 0 &&  $component_match_count  -lt 1 ]] 
       elif  [[ $component_match_count  -lt 1 ]]
       then
           echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
           call_get_log_result=0
       else    
         #echo "$SF and count=`echo $SF|grep -ic "GENERIC ORACLE PRE-UPGRADE COLLECTIONS AND AUDIT CHECKS"` and TYP=$TYP"
         call_get_log_result=1
         if [ $op_mode -eq 0 ]
         then 
             COM=`grep "_"$ROW"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
             COM_REPORT=`grep "_"$ROW"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
             audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
         else
             COM=`grep "_"$CHECK_ID"-OS_COMMAND" $REFFIL |sed  -n 's/.*OS_COMMAND //p'`
             COM_REPORT=`grep "_"$CHECK_ID"-OS_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COMMAND_REPORT //p'`
             audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
         fi
         audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
         if [[ "$NEEDS_RUNNING" = "ASM" || "$NEEDS_RUNNING" = "ACFS" ]] && [[ $OFFLINE -eq "0"  && ${stack_asm_up[$stack_counter]} -eq 1 ]]
         #if [[ $NEEDS_RUNNING = "ASM" && $OFFLINE -eq "0" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
         then
             OLD_ORACLE_SID=$(grep ORACLE_SID $ORCLENVFIL|cut -d= -f2)
             OLD_ORACLE_HOME=$(grep ORACLE_HOME $ORCLENVFIL|cut -d= -f2)
	     sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	     cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	     rm $INPUTDIR/tmp_env_file.out
	     sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	     cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	     rm $INPUTDIR/tmp_env_file.out
	     echo "export ORACLE_SID=${stack_asm_sid[$stack_counter]}">>$ORCLENVFIL
             if [[ -n "$crs112" && $crs112 -ge 1 ]]
             then
                 echo "export ORACLE_HOME=$CRS">>$ORCLENVFIL
             else
	         echo "export ORACLE_HOME=${stack_asm_home[$stack_counter]}">>$ORCLENVFIL
             fi
             if [ $i = $localnode ]; then cp $ORCLENVFIL /tmp; else  $SCOPY $ORCLENVFIL $i:/tmp/ >/dev/null;fi;
             TRGTORCLENV=/tmp/`basename $ORCLENVFIL`    
             #cat $TRGTORCLENV
             #read -p "OLD_ORACLE_SID=$OLD_ORACLE_SID OLD_ORACLE_HOME=$OLD_ORACLE_HOME ORACLE_HOME=$ORACLE_HOME ORACLE_SID=$ORACLE_SID"
         fi
	 if [[ -n "$os_check_needs_collect_file" && $os_check_needs_collect_file -eq 1 ]]
	   then 
	       if [ -f $OUTPUTDIR/$VAL_FIL ]
	       then
		   cp $OUTPUTDIR/$VAL_FIL . 
		   collect_files[$collect_file_counter]=${VAL_FIL}
		   collect_file_counter=$(expr $collect_file_counter + 1 )
	       fi
	 #read -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   
	 fi
         #echo  "needs_running=$NEEDS_RUNNING action=$COM"
         #echo "multiple_db=$multiple_db NEEDS_RUNNING=$NEEDS_RUNNING PARAM=$PARAM limits=`echo $COM|grep -ic "limits.conf"` usrlimit=`echo $COM|grep -ic "usrlimit"`"
         if [[ `echo $COM|grep -ic "limits.conf"` -ge 1 || `echo $COM|grep -ic "usrlimit"` -ge 1 ]]; then ulimit_cmd=1;else ulimit_cmd=0;fi
         #Not to call get_log_result for storage server cells in exalogic if its running on remote node
         if [[ $NEEDS_RUNNING = "ZFS" && -e $CELLIP && -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" && $i != $localnode ]]; then call_get_log_result=0;fi
         if [[ $NEEDS_RUNNING = "ZFS" && -e $ZFSIP && -n "$is_ssc_machine" && $is_ssc_machine -eq "1" && $i != $localnode ]]; then call_get_log_result=0;fi
         if [[ $NEEDS_RUNNING = "STORAGE_CELL" && $RAT_RUNMODE_INTERNAL = "slave" ]]; then call_get_log_result=0;fi
         if [[ $NEEDS_RUNNING = "ZFS" && $RAT_RUNMODE_INTERNAL = "slave" ]]; then call_get_log_result=0;fi
         # Dont call get_log_result if user selected skip cells
         if [[ $NEEDS_RUNNING = "STORAGE_CELL" && -n "$cell_password_status" && $cell_password_status -eq 3 ]]; then call_get_log_result=0;fi
         #read -p "ulimit_cmd=$ulimit_cmd in $COM"
         if [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "RDBMS" ]]
         then
             ORIG_PMSG=$PMSG
             ORIG_FMSG=$FMSG
             if [ $OFFLINE -eq 0 ];then cp $ORCLENVFIL $INPUTDIR/trgt_orcl_env.orig;fi;
             #cat $ORCLENVFIL
             #read -p "before mbd os"
             mb_db_counter=0
             mb_db_counter_log=0
             for db_name_to_check in "${mb_db_names[@]}"
             do
                 #read -p "current_oh_owner=$current_oh_owner"
                 if [ $OFFLINE -eq 0  ]
                 then
                     current_oh_owner=$(ls -l ${mb_oracle_homes[$mb_db_counter]}/bin/oracle|awk '{print $3}')
                 else
                     usern=$(grep "CURRENT_USER" $DUMPDIR/$CHKFIL|awk '{print $3}')
                     current_oracle_home=$(grep -w "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                     current_oh_owner=$(grep -w "RDBMS_ORACLE_HOME = $current_oracle_home" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                 fi
                 skip_this_version=0
                 set_skip_this_version "-"
                 if [ $skip_this_version -eq 1 ] ; then
                   echo "Skipping check($CHECK_ID) on version 1 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                 fi
                 if [[ $skip_this_version -eq 0 && $usern = $current_oh_owner ]]
                 then
                   skip_this_version=0
                 else
                   skip_this_version=1
                 fi
                 #read -p "current_oh_owner=$current_oh_owner"
                 #following if is to skip any audit checks which query files in ORALCE_HOME not owned by current user
		 call_get_log_result=0
                 if [ $skip_this_version -eq 0 ]
                 then
		     if [ $OFFLINE -eq 0  ]
		     then
			 inst_mode=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_MODE|awk '{print $3}')
		     else
			 inst_mode=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_MODE|awk '{print $3}')
		     fi
                     #read -p "inst_mode=$inst_mode for $db_name_to_check dbrole = ${mb_database_role[$mb_db_counter]} and check_database_role = $check_database_role"
                     match_database_role "${mb_database_role[$mb_db_counter]}"
                     match_database_type "${mb_database_type[$mb_db_counter]}"  
                     if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]]
                     #if [[ "${mb_database_role[$mb_db_counter]}" = "$check_database_role" ]]
                     then
			 if [[ $OFFLINE -eq "0"  && $inst_mode -eq 3 ]]
			 then
			     echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $db_name_to_check database\n">>$CHECKS_TIMING 
		 #read -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   
			     sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
			     cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
			     rm $INPUTDIR/tmp_env_file.out
			     sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
			     cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
			     rm $INPUTDIR/tmp_env_file.out
			     inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
			     echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
			     echo "export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}">>$ORCLENVFIL
			     if [ $i = $localnode ]; then cp $ORCLENVFIL /tmp; else  $SCOPY $ORCLENVFIL $i:/tmp/ >/dev/null;fi;
			     TRGTORCLENV=/tmp/`basename $ORCLENVFIL`  
			     #cat $ORCLENVFIL
			     #read -p "see changed file"
                             copy_env_files_to_tmp
                             localcmd=/tmp/localcmd.sh
                             echo "#!$bash_scr" >$localcmd
                             echo "$bash_source" >>$localcmd
                             echo ". $TRGTORCLENV">>$localcmd
                             if [ -n "$COM_REPORT" ]
                             then
                                 echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                             fi
			     if [ $i = $localnode ]
			     then
                                 chmod 755 $localcmd
				 echo "$COM">>$localcmd
                                 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
				 FILVAL=`$localcmd 2>>$ERRFIL`
				 if [ -e $localcmd ]; then rm $localcmd; fi;
			     else
                                echo "$COM">>$localcmd
                                if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
                                $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                                $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
                                $SSHELL $i "chmod 755 $RTEMPDIR/localcmd.sh"
                                FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
                                $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                                $SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
			     fi
			     echo "" >>$OSSPOOLFIL
			     printf "%s %s %s %s %s %s\n" "$db_name_to_check $PARAM_PATH $ROW $COM == $FILVAL" >>$OSSPOOLFIL
			     #echo " $db_name_to_check $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
			 fi 
			 if [ $inst_mode -eq 3 ]
			 then
			     if [ -n "$COM_REPORT" ]
			     then 
				 SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
				 if [ $OFFLINE -eq 0 ]
				 then
				     SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
				 else
				     SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
				 fi
			     fi   
			     #PMSG=$(echo $ORIG_PMSG for ${GREEN}${db_name_to_check}${NORM})
			     #FMSG=$(echo $ORIG_FMSG for ${ORANGE}${db_name_to_check}${NORM})
			     PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
			     FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
			     VAL=`grep "$db_name_to_check $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
			     if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
			     get_log_result "inloop" "-"
			     mb_db_counter_log=$(expr $mb_db_counter_log + 1)
			     if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $db_name_to_check database\n">>$CHECKS_TIMING;fi
    #			 if [[ $ISBRANCH -eq 0 &&  $OFFLINE -eq 0 ]]; then echo "${db_name_to_check}.${CHECK_ID}|${VAL}" >>$OSACTUAL ;fi;
			 fi
                     else
                         call_get_log_result=0    
                         echo "skipping $COM at $ROW for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL 
                     fi
                 fi
                 mb_db_counter=$(expr $mb_db_counter + 1)
             done
             mb_db_counter=0
             write_report_on_fail=1
             if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
             then 
                 cp $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
                 rm $INPUTDIR/trgt_orcl_env.orig
	         if [ $i = $localnode ]; then cp $ORCLENVFIL /tmp; else  $SCOPY $ORCLENVFIL $i:/tmp/ >/dev/null;fi;
             fi
             #cat $ORCLENVFIL
             #read -p "after mbd os"
         elif [[ -n "$multiple_oracle_homes" && $multiple_oracle_homes -ge 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" && -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]] 
         #elif [[ $multiple_db -eq 1 && "$NEEDS_RUNNING" = "UNSPECIFIED" && $PARAM = "RDBMS" ]]
         then
             ORIG_PMSG=$PMSG
             ORIG_FMSG=$FMSG
             if [ $OFFLINE -eq 0 ];then cp $ORCLENVFIL $INPUTDIR/trgt_orcl_env.orig;fi;
             #cat $ORCLENVFIL
             #read -p "before mbd os"
             mb_db_counter=0
             mb_db_counter_log=0
             for mb_db_homes in ${mb_oracle_homes_distinct[@]}
             do
                skip_this_version=0
                set_skip_this_version "$mb_db_homes"
                if [ $skip_this_version -eq 1 ]
                then #dont run
                  mb_db_counter=$(expr $mb_db_counter + 1)
                  echo "Skipping check($CHECK_ID) on version 2 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                  continue
                fi
                mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g')
                if [ $OFFLINE -eq "0"  ]
                then
                    echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING
                    sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                    cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                    rm $INPUTDIR/tmp_env_file.out
                    sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                    cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                    rm $INPUTDIR/tmp_env_file.out
                    inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
                    echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
                    echo "export ORACLE_HOME=${mb_db_homes}">>$ORCLENVFIL
                    if [ $i = $localnode ]; then cp $ORCLENVFIL /tmp; else  $SCOPY $ORCLENVFIL $i:/tmp/ >/dev/null;fi;
                    TRGTORCLENV=/tmp/`basename $ORCLENVFIL`       
		    copy_env_files_to_tmp
		    localcmd=/tmp/localcmd.sh
		    echo "#!$bash_scr" >$localcmd
		    echo "$bash_source" >>$localcmd
		    echo ". $TRGTORCLENV">>$localcmd
		    if [ -n "$COM_REPORT" ]
		    then
			echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $mb_db_homes|tr "[a-z]" "[A-Z]") DATABASE_HOME - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		    fi
		    if [ $i = $localnode ]
		    then
			chmod 755 $localcmd
			echo "$COM">>$localcmd
			if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
			FILVAL=`$localcmd 2>>$ERRFIL`
			if [ -e $localcmd ]; then rm $localcmd; fi;
		    else
		       echo "$COM">>$localcmd
		       if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
		       $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                       $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1 
		       $SSHELL $i "chmod 755 $RTEMPDIR/localcmd.sh"
		       FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
		       $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
		       $SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
		    fi
                    echo "" >>$OSSPOOLFIL
                    #echo " $mb_db_homes_without_slash $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
                    printf "%s %s %s %s %s %s\n" "$mb_db_homes_without_slash $PARAM_PATH $ROW $COM == $FILVAL" >>$OSSPOOLFIL
                fi
                call_get_log_result=0
                PMSG=$(echo $ORIG_PMSG for ${mb_db_homes})
                FMSG=$(echo $ORIG_FMSG for ${mb_db_homes})
                #RPT_PMSG=$(echo $ORIG_PMSG for ${mb_db_homes})
                #RPT_FMSG=$(echo $ORIG_FMSG for ${mb_db_homes})
                VAL=`grep "$mb_db_homes_without_slash $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                if [ -n "$COM_REPORT" ]
                then 
                    SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                    if [ $OFFLINE -eq 0 ]
                    then
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
                    else
                        SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                    fi
                fi   
                if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
                get_log_result "inloop" "$mb_db_homes"
		mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
                mb_db_counter=$(expr $mb_db_counter + 1)
#                if [[ $ISBRANCH -eq 0 &&  $OFFLINE -eq 0 ]]; then echo "${mb_db_homes_without_slash}.${CHECK_ID}|${VAL}" >>$OSACTUAL; fi    
                #mb_db_counter=$(expr $mb_db_counter + 1)
             done
             mb_db_counter=0 
             write_report_on_fail=1
             if [[ $OFFLINE -eq 0 && -e $INPUTDIR/trgt_orcl_env.orig ]]
             then
                 cp $INPUTDIR/trgt_orcl_env.orig $ORCLENVFIL
                 rm $INPUTDIR/trgt_orcl_env.orig
                 if [ $i = $localnode ]; then cp $ORCLENVFIL /tmp; else  $SCOPY $ORCLENVFIL $i:/tmp/ >/dev/null;fi;
             fi
         elif [[ $multiple_db -eq 0 && "$NEEDS_RUNNING" = "RDBMS" ]]
         #elif [[ -n "$ulimit_cmd" && $ulimit_cmd -eq 0 ]] && [[ "$NEEDS_RUNNING" = "RDBMS" || $PARAM = "RDBMS" ]]
         then
             ORIG_PMSG=$PMSG
             ORIG_FMSG=$FMSG
             mb_db_counter=0 
             mb_db_counter_log=0 
             if [ $OFFLINE -eq 0  ]
             then
                 current_oh_owner=$(ls -l ${mb_oracle_homes[$mb_db_counter]}/bin/oracle|awk '{print $3}')
		 inst_mode=$(grep "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_MODE|awk '{print $3}')
             else
		 inst_mode=$(grep "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_MODE|awk '{print $3}')
                 usern=$(grep "CURRENT_USER" $DUMPDIR/$CHKFIL|awk '{print $3}')
                 current_oracle_home=$(grep "DB_NAME = $db_name_to_check" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
                 current_oh_owner=$(grep "RDBMS_ORACLE_HOME = $current_oracle_home" $DUMPDIR/$CHKFIL|awk '{print $3}'|cut -d '|' -f3)
             fi
#             echo "current_oh_owner=$current_oh_owner all_homes=${mb_oracle_homes[@]} current_home=${mb_oracle_homes[$mb_db_counter]} usern=$usern"
	     call_get_log_result=0
             skip_this_version=0
             set_skip_this_version "-"
             if [ $skip_this_version -eq 1 ] ; then
               echo "Skipping check($CHECK_ID) on version 3 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
             fi
             if [[ $skip_this_version -eq 0 && $usern = $current_oh_owner ]]
             then
               skip_this_version=0
             else
               skip_this_version=1
             fi

             if [ $skip_this_version -eq 0 ]
             then
                 match_database_role "${mb_database_role[$mb_db_counter]}"
                 match_database_type "${mb_database_type[$mb_db_counter]}"
                 if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]]      
                 #if [[ "${mb_database_role[$mb_db_counter]}" = "$check_database_role" ]]
                 then
		     if [[ $OFFLINE -eq "0" && $inst_mode -eq 3 ]]
		     then
			 echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING
	    #read -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   
                    sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                    cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                    rm $INPUTDIR/tmp_env_file.out
                    sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
                    cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
                    rm $INPUTDIR/tmp_env_file.out
                    inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
                    echo "export ORACLE_SID=${inst_name}">>$ORCLENVFIL
                    echo "export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}">>$ORCLENVFIL
                    if [ $i = $localnode ]; then cp $ORCLENVFIL /tmp; else  $SCOPY $ORCLENVFIL $i:/tmp/ >/dev/null;fi;
                    TRGTORCLENV=/tmp/`basename $ORCLENVFIL`
			 copy_env_files_to_tmp
			 localcmd=/tmp/localcmd.sh
			 echo "#!$bash_scr" >$localcmd
			 echo "$bash_source" >>$localcmd
			 echo ". $TRGTORCLENV">>$localcmd
			 if [ -n "$COM_REPORT" ]
			 then 
			     #echo "echo -e $COM_REPORT \\n Above command was executed on $i for following output\\n >${OUTPUTDIR}/${CHECK_ID}_${i}_report.out">>$localcmd 
			     echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") DATABASE - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			 fi
			 if [ $i = $localnode ]
			 then
			    chmod 755 $localcmd
			    echo "$COM 2>>$ERRFIL">>$localcmd
			    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
			    FILVAL=`$localcmd 2>>$ERRFIL`
			    if [ -e $localcmd ]; then rm $localcmd; fi;
			 else
			    echo "$COM">>$localcmd
			    if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
			    $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
			    $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
			    $SSHELL $i "chmod 755 $RTEMPDIR/localcmd.sh"
			    FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
			    $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
			    $SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"
			 fi
			 echo "" >>$OSSPOOLFIL
			 #echo " $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
			 printf "%s %s %s %s %s\n" " $PARAM_PATH $ROW $COM == $FILVAL" >>$OSSPOOLFIL
		     fi
		     #PMSG=$(echo $ORIG_PMSG for ${GREEN}${db_name_to_check}${NORM})
		     #FMSG=$(echo $ORIG_FMSG for ${ORANGE}${db_name_to_check}${NORM})
		     PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
		     FMSG=$(echo $ORIG_FMSG for ${db_name_to_check}) 
		     if [ -n "$COM_REPORT" ]
		     then
			 SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 
			 if [ $OFFLINE -eq 0 ]
			 then
			     SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
			 else
			     SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			 fi                 
		     fi
		     if [ $inst_mode -eq 3 ]
		     then
			 call_get_log_result=0
			 VAL=`grep "$PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
			 #VAL=`grep "$mb_db_homes_without_slash $PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
			 if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
			 get_log_result "inloop" "-"
			 mb_db_counter_log=$(expr $mb_db_counter_log + 1)
			 if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
		     fi
                 else
                     call_get_log_result=0
                     echo "skipping $COM at $CHECK_ID for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL
                 fi
             fi
         elif [[ $NEEDS_RUNNING = "ZFS" && -n "$zfs_password_status" && $zfs_password_status -ne 3 && -e $ZFSIP ]] && [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" || $is_ssc_machine -eq 1 ]] && [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
         then 
             ORIG_PMSG=$PMSG
             ORIG_FMSG=$FMSG
             cell_count=0    
             COM_KEYWORK=$COM
             for cellname in `cat $ZFSIP|cut -d= -f2|sed 's/"//g'`
             do     
		 if [ $OFFLINE -eq "0" ]
		 then
		     echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${cellname}\n">>$CHECKS_TIMING
                     unset COM
                     check_begin_pattern_check=START_OF_AUDIT_CHECK_${COM_KEYWORK}.aksh
                     check_end_pattern_check=END_OF_AUDIT_CHECK_${COM_KEYWORK}.aksh
                     check_begin_pattern_report=START_OF_REPORT_${COM_KEYWORK}.aksh
                     check_end_pattern_report=END_OF_REPORT_${COM_KEYWORK}.aksh
                     COM="sed -n /$check_begin_pattern_check/,/$check_end_pattern_check/p $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out|sed '1d'|sed '\$d'|awk '{print \$NF}'"
                     COM_REPORT="sed -n /$check_begin_pattern_report/,/$check_end_pattern_report/p $OUTPUTDIR/${cellname}.exalogic_zfs_checks.out|sed '1d'|sed '\$d'"
		     copy_env_files_to_tmp
		     localcmd=/tmp/localcmd.sh
		     echo "#!$bash_scr" >$localcmd
		     echo "$bash_source" >>$localcmd
		     echo ". $TRGTORCLENV">>$localcmd
		     echo "$COM 2>>$ERRFIL">>$localcmd
		     if [ -n "$COM_REPORT" ]
		     then 
			 echo -e "TO REVIEW COLLECTED DATA FROM $(echo ${cellname}|tr "[a-z]" "[A-Z]") FOR $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
			 echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd
                     fi
		     chmod 755 $localcmd
		     FILVAL=`$localcmd 2>>$ERRFIL`
		     if [ -e $localcmd ]; then rm $localcmd; fi;
                     echo "" >>$OSSPOOLFIL
                     printf "%s %s %s %s %s\n" " $PARAM_PATH $ROW $COM == $FILVAL" >>$OSSPOOLFIL
		 fi
		 if [ -n "$COM_REPORT" ]
		 then
		      SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		      if [ $OFFLINE -eq 0 ]
		      then
			  SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
		      else
			  SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
		      fi
		 fi
                 #read -p "stop for cell check"
                 PMSG=$(echo $ORIG_PMSG for ${cellname})
                 FMSG=$(echo $ORIG_FMSG for ${cellname})
                 call_get_log_result=0
                 VAL=`grep "$PARAM_PATH $ROW " $OSSPOOLFIL|grep ${cellname} |sed  -n 's/.*== //p'`
                 if [ $cell_count -gt 0 ];then write_report_on_fail=0;fi
                 get_log_result
                 if [ $OFFLINE -eq 0 ]; then echo -e "end time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i} for $mb_db_homes\n">>$CHECKS_TIMING;fi
                 cell_count=$( expr $cell_count + 1 )
             done  
             cell_count=0 
         elif [[ -z "$NEEDS_RUNNING" || $NEEDS_RUNNING != "ZFS" ]]
         then
	     if [ $OFFLINE -eq "0" ]
	     then
                 echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING
                 copy_env_files_to_tmp;
                 localcmd=/tmp/localcmd.sh
                 echo "#!$bash_scr" >$localcmd
                 echo "$bash_source" >>$localcmd
                 echo ". $TRGTORCLENV">>$localcmd
                 if [ -n "$COM_REPORT" ]
                 then
                     echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                 fi 
		 #read -p "os_check_needs_collect_file=$os_check_needs_collect_file VAL_FIL=$VAL_FIL collect_file_counter=$collect_file_counter file_to_copy=$OUTPUTDIR/$VAL_FIL"   
		 if [ $i = $localnode ]
		 then
                     chmod 755 $localcmd
		     echo "$COM 2>>$ERRFIL">>$localcmd
                     if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi 
                     FILVAL=`$localcmd 2>>$ERRFIL`
                     if [ -e $localcmd ]; then rm $localcmd; fi;
		 else
                     if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
                     then
		         FILVAL=`$SSHELL_EL $i " . $TRGTORCLENV; $COM" 2>>$ERRFIL`
                         FILVAL=$(echo $FILVAL|sed 's///g')
                         if [ -n "$COM_REPORT" ]; then $SSHELL_EL $i " . $TRGTORCLENV; $COM_REPORT" 2>>$ERRFIL >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out;fi
                     else
                         echo "$COM">>$localcmd
                         if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >> $RTEMPDIR/${CHECK_ID}_${i}_report.out">>$localcmd;fi
                         $SCOPY $localcmd $i:$RTEMPDIR >/dev/null 2>&1
                         $SCOPY ${OUTPUTDIR}/${CHECK_ID}_${i}_report.out $i:$RTEMPDIR >/dev/null 2>&1
                         $SSHELL $i "chmod 755 $RTEMPDIR/localcmd.sh"
                         FILVAL=`$SSHELL $i "$RTEMPDIR/localcmd.sh" 2>>$ERRFIL`
                         $SCOPY $i:$RTEMPDIR/${CHECK_ID}_${i}_report.out $OUTPUTDIR >/dev/null 2>&1
                         $SSHELL $i "rm -f $RTEMPDIR/localcmd.sh $RTEMPDIR/${CHECK_ID}_${i}_report.out>/dev/null 2>&1"  
                     fi
                 fi
		 echo "" >>$OSSPOOLFIL
		 #echo " $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
		 printf "%s %s %s %s %s\n" " $PARAM_PATH $ROW $COM == $FILVAL" >>$OSSPOOLFIL
	     fi
	     VAL=`grep "$PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
             if [ -n "$COM_REPORT" ]
             then
                  SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                  if [ $OFFLINE -eq 0 ]
                  then
                      SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
                  else
                      SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
                  fi
             fi
#	     if [[ $ISBRANCH -eq 0 &&  $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL ; fi
         fi
         #if [[ $NEEDS_RUNNING = "ASM" && $OFFLINE -eq "0" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
         if [[ "$NEEDS_RUNNING" = "ASM" || "$NEEDS_RUNNING" = "ACFS" ]] && [[ $OFFLINE -eq "0"  && ${stack_asm_up[$stack_counter]} -eq 1 ]]
         then
	     sed  "/ORACLE_SID/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	     cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	     rm $INPUTDIR/tmp_env_file.out
	     sed  "/ORACLE_HOME/d" $ORCLENVFIL >$INPUTDIR/tmp_env_file.out
	     cp $INPUTDIR/tmp_env_file.out $ORCLENVFIL
	     rm $INPUTDIR/tmp_env_file.out
	     echo "export ORACLE_SID=$OLD_ORACLE_SID">>$ORCLENVFIL
	     echo "export ORACLE_HOME=$OLD_ORACLE_HOME">>$ORCLENVFIL
             if [ $i = $localnode ]; then cp $ORCLENVFIL /tmp; else  $SCOPY $ORCLENVFIL $i:/tmp/ >/dev/null;fi;
             TRGTORCLENV=/tmp/`basename $ORCLENVFIL`    
             #cat $TRGTORCLENV
         fi
       fi
       if [[ -n "$LEVEL" && $call_get_log_result -eq 1 ]]
       then
          #we don't want to call this function unless there's a valid
          #set of data for it to evaluate.  If there's no level then that
          #just means we've reached the end of the hierarchy and no more
          #rows to process.
          #
          #calling get_log_result() when in SILENT mode will only do logging
          #there won't be any comparison done and the "PASS" flag will be set
          get_log_result
          if [ $OFFLINE -eq 0 ]; then echo -e "end time -  `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING;fi
       fi
       ;;
     OS_COLLECT)
         #if [ $OFFLINE -eq "0" ]
         #then
        #read -p "PARAM=$PARAM CRS_I=${crs_installed[$stack_counter]} RDBMS_I=${rdbms_installed[$stack_counter]} SC=$stack_counter "
         if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
         then
             call_get_log_result=0
             OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
         elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
         then
             call_get_log_result=0
             OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1` 
         elif [[ $NEEDS_RUNNING = "ACFS" && $db_machine_compute -eq 1 ]] 
         then
            OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
            call_get_log_result=0
         elif [[ $execute_once -eq 1 && "$i" != "$localnode" ]]
         then
             OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
             call_get_log_result=0
         elif [[ $execute_once -eq 1 && "$RAT_RUNMODE_INTERNAL" = "slave" ]]
         then
             OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
             call_get_log_result=0
         #elif  [[ $components != "NONE" &&  $components != $check_components ]]
         elif  [[ $component_match_count  -lt 1 ]]
         #elif  [[ -n "$it_is_rac" && $it_is_rac -eq 0 &&  $component_match_count  -lt 1 ]]
         then
             echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
             OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
             call_get_log_result=0
         elif [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
         then
             OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
             call_get_log_result=0
             echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL
         else
            call_get_log_result=1
            if [ $op_mode -eq 0 ]
            then
                COM=`grep "_"$ROW"-OS_COLLECT_COMMAND" $REFFIL |sed  -n 's/.*OS_COLLECT_COMMAND //p'` 
                COM_REPORT=`grep "_"$ROW"-OS_COLLECT_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COLLECT_COMMAND_REPORT //p'` 
                REQUIEE_ROOT=`grep "_"$ROW"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
                COLLECTION_NAME=`grep "_"$ROW"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
            else
                COM=`grep "_"$CHECK_ID"-OS_COLLECT_COMMAND" $REFFIL |sed  -n 's/.*OS_COLLECT_COMMAND //p'` 
                COM_REPORT=`grep "_"$CHECK_ID"-OS_COLLECT_COMMAND_REPORT" $REFFIL |sed  -n 's/.*OS_COLLECT_COMMAND_REPORT //p'` 
                REQUIEE_ROOT=`grep "_"$CHECK_ID"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
                COLLECTION_NAME=`grep "_"$CHECK_ID"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
            fi
            OSCOLLECTCNT=`expr $OSCOLLECTCNT + 1`
            #echo "REQUIEE_ROOT =$REQUIEE_ROOT"
            #read -p "STOP"
            #OUTFILNAME is the name we set up in the app as the file name we want
            #the data redirected to when doing OS and SQL COLLECTs
            #we'll search this file for OS and SQL param valuesa
            #so SQL and OS COLLECT creates OUTFIL in the OUTPUTDIR
            #SQL and OS PARAM reads the values of the parameters from OUTFIL
            #OUTFIL will also be archived at the end
            #FIELDPOS is the position we define in the app to tell the script
            #which field to look in for the value as the position might vary from
            #command to command or OS to OS
            if [ $op_mode -eq 0 ]
            then
                OUTFILNAM=`grep _$ROW\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
            else
                OUTFILNAM=`grep _$CHECK_ID\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
            fi
            #note we do not append an extension here since the OS commands are 
            #executed on each node and for formatting purposes we append the host 
	    #and the .out in the OS_COLLECT case of log_result()
            
            copy_env_files_to_tmp;
            # Changes made by jrmullan 03/22/10
            # I am changing the file names on the remote nodes to be the same regardless of node.  I need to do this to keep pthe
            # root_raccheck.sh script generic so that the sudo command works from every node.  Once the files are copied back to
            # the local node I will append node information at that point.
            # ORIGINAL STATEMENT:
            #OUTFIL=/tmp/"o_"$OUTFILNAM"_"$i".out"
            #OUTFIL=/tmp/"o_"$OUTFILNAM".out"
            OUTFIL=$OUTPUTDIR/"o_"$OUTFILNAM"_"$i".out"
            OUTFIL_REPORT=$OUTPUTDIR/"o_"$OUTFILNAM"_"$i"_report.out"
            if [ $REQUIEE_ROOT -eq 0 ]
            then
                if [ $OFFLINE -eq 0 ]
                then
                    copy_env_files_to_tmp
                    localcmd=/tmp/localcmd.sh
                    echo "#!$bash_scr" >$localcmd
                    echo "$bash_source" >>$localcmd
                    chmod 755 $localcmd
                    echo ". $TRGTORCLENV">>$localcmd
                    echo $COM>>$localcmd
                    if [ -n "$COM_REPORT" ]
                    then
                        localcmd_report=/tmp/localcmd_report.sh
                        echo "#!$bash_scr" >$localcmd_report
                        echo "$bash_source" >>$localcmd_report
                        chmod 755 $localcmd_report
                        echo ". $TRGTORCLENV">>$localcmd_report
                        echo $COM_REPORT>>$localcmd_report
                    fi
                fi
            else
                 if [ $OFFLINE -eq 0 ]
                 then
                     # Changes made by jrmullan 03/22/10
                     # I am changing the file names on the remote nodes to be the same regardless of node.  I need to do this to keep pthe
                     # root_raccheck.sh script generic so that the sudo command works from every node.  Once the files are copied back to
                     # the local node I will append node information at that point.
                     # ORIGINAL STATEMENT:
                     #OUTFIL=/tmp/"o_"$OUTFILNAM"_"$i".out"
                     if [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]]
                     then
			 if [[ -n "$ibswitch_password_status" && $ibswitch_password_status -eq 1 && $i = $localnode  && $RAT_RUNMODE_INTERNAL = "master" ]]
			 then
			     OUTFIL=${RTEMPDIR}/"s_${OUTFILNAM}_\`hostname|cut -d. -f1\`.out"
	                     OUTFIL_REPORT=${RTEMPDIR}/"s_"$OUTFILNAM"_\`hostname|cut -d. -f1\`_report.out"
                             ROOT_COLLECT_TIMING=${RTEMPDIR}/s_root_collect_timing.out
			     COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}'|sed 's/\`//g' |sed 's/ //g'`
			     if [ -z "$COLLECTION_NAME" ] 
			     then
				 echo "echo \"Collecting - $COMSBSTR \"" >>$IBSWITCHSCRPT
			     else
				  echo "echo \"Collecting - $COLLECTION_NAME \"" >>$IBSWITCHSCRPT
			     fi
			     echo "$COM >>$OUTFIL" >> $IBSWITCHSCRPT 
                             if [ -n "$COM_REPORT" ]
                             then 
                                 echo "echo -e \"TO REVIEW COLLECTED DATA FROM \$(hostname|cut -d. -f1|tr "[a-z]" "[A-Z]") FOR $(echo $COLLECTION_NAME|tr "[a-z]" "[A-Z]") \\n\\n\\n\" >>$OUTFIL_REPORT" >>$IBSWITCHSCRPT
                                 echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >>$IBSWITCHSCRPT
                             fi
                             echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$IBSWITCHSCRPT
                             write_root_collections_log "$IBSWITCHSCRPT"
			 fi
                     elif [[ $NEEDS_RUNNING = "STORAGE_CELL" ]]
                     then
                         if [[ -n "$skip_in_silent" && $skip_in_silent -eq 0 && $current_exadata_version -lt $check_exadata_version ]]
                         then
			     if [ -z "$RAT_CELL_SSH_USER" ] || [[ -n "$DOROOT" && $DOROOT -eq 1 ]] || [ $RAT_CELL_SSH_USER = "cellmonitor" ]
			     then  
				 if [[ $root_need_cell_ssh -eq 0 && $i = $localnode  && $RAT_RUNMODE_INTERNAL = "master" ]]
				 then
				     OUTFIL=${RTEMPDIR}/"c_${OUTFILNAM}_\`hostname|cut -d. -f1\`.out"
				     ROOT_COLLECT_TIMING=${RTEMPDIR}/c_root_collect_timing.out
				     OUTFIL_REPORT=${RTEMPDIR}/"c_"$OUTFILNAM"_\`hostname|cut -d. -f1\`_report.out"
				     COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}'|sed 's/\`//g' |sed 's/ //g'`
				     if [ -z "$COLLECTION_NAME" ] 
				     then
					 echo "echo \"Collecting - $COMSBSTR \"" >>$CELLSSCRPT
				     else
					  echo "echo \"Collecting - $COLLECTION_NAME \"" >>$CELLSSCRPT
				     fi
				     echo "$COM >>$OUTFIL" >> $CELLSSCRPT
				     if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >>$CELLSSCRPT;fi
				     echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$CELLSSCRPT
				     write_root_collections_log "$CELLSSCRPT"
				 fi 
			     elif [[ -n "$RAT_CELL_SSH_USER" && $RAT_CELL_SSH_USER = "celladmin"  && $REQUIEE_ROOT -eq 2 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
			     then  
				 if [[ $root_need_cell_ssh -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master"  ]]
				 then
				     OUTFIL=${RTEMPDIR}/"c_${OUTFILNAM}_\`hostname|cut -d. -f1\`.out"
				     ROOT_COLLECT_TIMING=${RTEMPDIR}/c_root_collect_timing.out
				     OUTFIL_REPORT=${RTEMPDIR}/"c_"$OUTFILNAM"_\`hostname|cut -d. -f1\`_report.out"
				     COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}'|sed 's/\`//g' |sed 's/ //g'`
				     if [ -z "$COLLECTION_NAME" ] 
				     then
					 echo "echo \"Collecting - $COMSBSTR \"" >>$CELLSSCRPT
				     else
					  echo "echo \"Collecting - $COLLECTION_NAME \"" >>$CELLSSCRPT
				     fi
				     echo "$COM >>$OUTFIL" >> $CELLSSCRPT
				     if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >>$CELLSSCRPT;fi
				     echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$CELLSSCRPT
				     write_root_collections_log "$CELLSSCRPT"
				 fi
			     fi
                         fi  
                     else
			 OUTFIL=${RTEMPDIR}/"o_"$OUTFILNAM".out"
                         ROOT_COLLECT_TIMING=${RTEMPDIR}/o_root_collect_timing.out
			 OUTFIL_REPORT=${RTEMPDIR}/"o_"$OUTFILNAM"_report.out"
			 if [[ $i = $localnode ]]
			 then
			     touch $OUTFIL >/dev/null 2>&1
			     touch $ROOT_COLLECT_TIMING >/dev/null 2>&1
                             if [ -n "$COM_REPORT" ]; then  touch $OUTFIL_REPORT >/dev/null 2>&1;fi
			 else
			     $SSHELL $i touch $OUTFIL >/dev/null 2>&1
			     $SSHELL $i touch $ROOT_COLLECT_TIMING >/dev/null 2>&1
                             if [ -n "$COM_REPORT" ]; then   $SSHELL $i touch $OUTFIL_REPORT >/dev/null 2>&1;fi
                             #$SSHELL $i 'echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[:lower:]"  "[:upper:]") FOR $(echo $COLLECTION_NAME|tr "[:lower:]"  "[:upper:]") \n\n\n" >> $OUTFIL_REPORT'
                     
			 fi
                         echo "echo -e \"TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") FOR $(echo $COLLECTION_NAME|tr "[a-z]" "[A-Z]") \\n\\n\\n\" >>$OUTFIL_REPORT" >>$ROOTSCRPT
			 COMSBSTR=`echo $COM |awk '{print substr($0,0,60)}'|sed 's/\`//g' |sed 's/ //g'`
			 if [ -z "$COLLECTION_NAME" ] 
			 then
			     echo "echo \"Collecting - $COMSBSTR \"" >>$ROOTSCRPT
			 else
			      echo "echo \"Collecting - $COLLECTION_NAME \"" >>$ROOTSCRPT
			 fi
			 echo "$COM  >>$OUTFIL" >> $ROOTSCRPT
			 if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>$OUTFIL_REPORT 2>/dev/null " >> $ROOTSCRPT;fi
                         echo "echo -e \"\`date '+%a %b %d %H:%M:%S %Y'\` - $COLLECTION_NAME on \`hostname|cut -d. -f1\`\" >>$ROOT_COLLECT_TIMING" >>$ROOTSCRPT
                         write_root_collections_log "$ROOTSCRPT"
                     fi         
                 fi
            fi
            if [[ -n "$LEVEL" &&  $REQUIEE_ROOT -eq 0 && $call_get_log_result -eq 1 ]]
            then
                #we don't want to call this function unless there's a valid
                #set of data for it to evaluate.  If there's no level then that
                #just means we've reached the end of the hierarchy and no more
                #rows to process.
                #
                #in SILENT mode we'll execute the command derived here and do 
                #some logging but there is nothing to compare
                #echo " in get_log_result REQUIEE_ROOT=$REQUIEE_ROOT"
              get_log_result
            fi
         fi # OS collect without root ends here
         
         echo -e "OSCOLLECTCNT=$OSCOLLECTCNT OSCOLLECTSUM= $OSCOLLECTSUM rootYesNoint=$rootYesNoint root_need_cell_ssh=$root_need_cell_ssh REQUIRE_ROOT=$REQUIRE_ROOT" >>$LOGFIL
         #read -p "rootYesNoint=$rootYesNoint"
         if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && $REQUIRE_ROOT -gt 0  && $rootYesNoint -ne 3 && $root_need_cell_ssh -eq 0   ]]
         then
             #change permission of temporary raccheck files created by root to current user
             echo "chown $usern:$running_group ${RTEMPDIR}/o_*.out >/dev/null 2>&1">>$ROOTSCRPT
             chmod 755 $ROOTSCRPT
             cp $ROOTSCRPT /tmp/
             #read -p "STOP  $ROOTSCRPT /tmp/.racrx/"
             ROOTSCRPT=/tmp/root_${program_name}.sh
             if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
             noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $i)
             if [[ $i = $localnode && $noPasswordAvailable -eq 0 ]]
             then
                # Changes made by jrmullan 03/22/10
                unset FNAMEANDPATH
                unset FNAME
                 if [ $rootYesNoint -eq 2 ]
                 then
                     echo -e "\nPreparing to run root privileged commands ${print_compute_node} ${i}.\n"
                     # Changes made by jrmullan 03/22/10
                     #$SSHELL -t $i $SUDOCMD "$ROOTSCRPT"
                     $SUDOCMD "$ROOTSCRPT" 2>>$ERRFIL
                 elif [ $rootYesNoint -eq 1 ]
                 then
                     if [[ -n "$samerootpassword" && $samerootpassword -eq 1 ]]
                     then
                         if [ $userid -ne 0 ]
                         then
                              echo -e "Preparing to run root privileged commands ${print_compute_node} $i."
                              echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                          fi
                        if [ $userid -eq 0 ] ; then
                           $ROOTSCRPT
                        else
                          compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $i ls >/dev/null 2>&1;echo $?);
                          if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                          then
                              echo "root password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
                              $SSHELL root@$i "$ROOTSCRPT"
                          else   
			      checkUserPassword "$i" "root" "$compute_rootpassword" "1"
                              #has_dollar=$(echo $compute_rootpassword|grep -c "$");if [ $has_dollar -ge 1 ]; then compute_rootpassword=$(echo $compute_rootpassword|sed 's/\$/\\$/g');fi
			      if [ $passwordCheckStatus -eq 0 ]
			      then
				  fixRootPassword "$compute_rootpassword"
				  $EXPECT -f - 2>>$WATCHLOG << IBEOF
				  set timeout $passwordcheck_timeout
				  set le_compute_rootpassword "$fixedRootPassword"
                                  if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                    exp_internal 1
                                  }
				  spawn -noecho $SSHELL root@$i "$ROOTSCRPT"			
				  #spawn -noecho $SSHELL_EL $i "su - root -c $ROOTSCRPT"			
				  match_max 100000
				    expect {
				  "no)?" {
					send -- "yes\n"
					}
				  }
				  # Look for passwd prompt
				  expect "*?assword:*"
				  send -- "\$le_compute_rootpassword\n"
				  # Stop the on logon tests and if asked to connect to master switch choose no
				  set timeout $watchdog_wakeup_root
				  expect eof {
                                    exit
                                  } timeout {
                                    send_error "Timed out while running $ROOTSCRPT on $i\n";
                                    exit
                                  }
IBEOF
			      else
				  echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n" |tee -a $LOGFIL 
			      fi
                          fi 
                        fi
                     elif [[ -n "$samerootpassword" && $samerootpassword -eq 0 ]]
                     then
                        if [ $userid -ne 0 ]
                        then
                              echo -e "Preparing to run root privileged commands on ${print_compute_node} ${i}."
                              echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                        fi
                        if [ $userid -eq 0 ] ; then
                           $ROOTSCRPT
                        else

                          compute_rootpassword=${a_compute_rootpassword[$stack_counter]}
                          compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $i ls >/dev/null 2>&1;echo $?); 
                          if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                          then
                              echo "root password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
                              $SSHELL root@$i "$ROOTSCRPT" 
                          else
			      checkUserPassword "$i" "root" "$compute_rootpassword" "1"
			      if [ $passwordCheckStatus -eq 0 ]
			      then
				  fixRootPassword "$compute_rootpassword"
				  $EXPECT -f - 2>>$WATCHLOG << IBEOF
				  set timeout $passwordcheck_timeout 
				  set le_compute_rootpassword "$fixedRootPassword"
                                  if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                    exp_internal 1
                                  }   
				  spawn -noecho $SSHELL root@$i "$ROOTSCRPT"			
				  #spawn -noecho $SSHELL_EL $i "su - root -c $ROOTSCRPT"			
                                   
				  match_max 100000
				    expect {
				  "no)?" {
					send -- "yes\n"
					}
				  }
				  # Look for passwd prompt
				  expect "*?assword:*"
				  send -- "\$le_compute_rootpassword\n"
				  # Stop the on logon tests and if asked to connect to master switch choose no
				  set timeout $watchdog_wakeup_root
				  expect eof{
                                    exit
                                  } timeout {
                                    send_error "Timed out while running $ROOTSCRPT on $i\n";
                                    exit
                                  }
IBEOF
			      else
				  echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL
			      fi
                          fi   
                         fi
                     else 
                         if [ $userid -ne 0 ]
                         then
                              echo -e "Preparing to run root privileged commands ${print_compute_node} $i.  Please enter root password when prompted."
                              echo "Preparing to run root privileged commands on $i.  Please enter root password when prompted.">>$LOGFIL
                         fi
                         if [ $userid -ne 0 ] ; then
                           $SSHELL root@$i "$ROOTSCRPT"			
                         else
                           $ROOTSCRPT
                         fi
                         #Fix for bug 14336860 
                         #$SSHELL_EL $i "su - root -c $ROOTSCRPT"
                     fi
                 fi
                 # Changes made by jrmullan 03/22/10
                 for FNAMEANDPATH in `ls ${RTEMPDIR}/o_* 2>/dev/null`
                 do
                    # Strip off /tmp/ and .out and insert nodename and .out back in to filename
                    FNAME=`echo $FNAMEANDPATH |cut -d'/' -f4|sed 's/.out//g'`
                    if [[ -e $OUTPUTDIR/$FNAME"_"$i".out" && -e $FNAMEANDPATH ]]
                    then 
                        cat $FNAMEANDPATH  >>$OUTPUTDIR/$FNAME"_"$i".out"
                    elif [ -e $FNAMEANDPATH ]
                    then                   
                        cp -r $FNAMEANDPATH $OUTPUTDIR/$FNAME"_"$i".out" > /dev/null
                    fi
                    if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -lt 1 && "$FNAME" != "o_exadata_disk.out" && `echo $FNAME|grep -ic "ibswitches"` -lt 1 && `ls -l $FNAMEANDPATH|awk '{print $3}'` != root ]]; then rm $FNAMEANDPATH >/dev/null 2>&1;fi
                    if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -ge 1 && `ls -l $FNAMEANDPATH|awk '{print $3}'` != root ]]; then mv $FNAMEANDPATH /tmp  >/dev/null 2>&1; fi;
                 done
                 #rm -r /tmp/o_*.out >/dev/null 2>&1
                 if [[ -n "$ORACLEENVVARS" && $ORACLEENVVARS != "" ]];then  rm tmp/$ORACLEENVVARS >/dev/null 2>&1; fi;
                 rm -f $ROOTSCRPT >/dev/null 2>&1
                 if [ -f $ROOTSCRPT ]; then rm -f $ROOTSCRPT >/dev/null 2>&1;fi;
                 if [[ -e ${OUTPUTDIR}/o_root_collect_timing_${i}.out && -e $COLLECT_TIMING ]]
                 then
                     cat ${OUTPUTDIR}/o_root_collect_timing_${i}.out >> $COLLECT_TIMING
                     rm -f ${OUTPUTDIR}/o_root_collect_timing_${i}.out  >/dev/null 2>&1
                 fi
             elif [ $noPasswordAvailable -eq 0 ]
             then
                 unset FNAMEANDPATH
                 unset FNAME
                 $SCOPY /tmp/$ORACLEENVVARS $i:/tmp/ >/dev/null 2>&1
                 $SCOPY $ROOTSCRPT $i:/tmp/ >/dev/null 2>&1
                 $SSHELL $i "chmod 755 $ROOTSCRPT"
                 if [ $rootYesNoint -eq 2 ]
                 then
                     echo -e "\nPreparing to run root privileged commands ${print_compute_node} ${i}.\n"
                     $SSHELL -t $i $SUDOCMD "$ROOTSCRPT" 2>>$ERRFIL
                 elif [ $rootYesNoint -eq 1 ]
                 then
                     if [[ -n "$samerootpassword" && $samerootpassword -eq 1 ]]
                     then
                          if [ $userid -ne 0 ]
                          then
                               echo -e "Preparing to run root privileged commands ${print_compute_node} $i."
                               echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                          fi
                          compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $i ls >/dev/null 2>&1;echo $?);
                          if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                          then
                              echo "root password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
                              $SSHELL root@$i "$ROOTSCRPT"
                          else   
			      checkUserPassword "$i" "root" "$compute_rootpassword" "1"
			      if [ $passwordCheckStatus -eq 0 ]
			      then
				  fixRootPassword "$compute_rootpassword"
				  $EXPECT -f - 2>>$WATCHLOG << IBEOF
				  set timeout $passwordcheck_timeout
				  set le_compute_rootpassword "$fixedRootPassword"
                                  if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                    exp_internal 1
                                  }
				  spawn -noecho $SSHELL root@$i "$ROOTSCRPT"			
				  #spawn -noecho $SSHELL_EL $i "su - root -c $ROOTSCRPT"			
				  match_max 100000
				    expect {
				  "no)?" {
					send -- "yes\n"
					}
				  }
				  # Look for passwd prompt
				  expect "*?assword:*"
				  send -- "\$le_compute_rootpassword\n"
				  # Stop the on logon tests and if asked to connect to master switch choose no
				  set timeout $watchdog_wakeup_root
				  expect eof {
                                    exit
                                  } timeout {
                                    send_error "Timed out while running $ROOTSCRPT on $i\n";
                                    exit
                                  }
IBEOF
			      else
				  echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL
				  #echo -e "\n\n${RED}Still ${userToCheck} password for $nodeNameToCheck was wrong. $userToCheck priviledged check will not be executed on $nodeNameToCheck ${NORM}\n"
			      fi
                          fi
                     elif [[ -n "$samerootpassword" && $samerootpassword -eq 0 ]]
                     then
                         if [ $userid -ne 0 ]
                         then
                              echo -e "Preparing to run root privileged commands on ${print_compute_node} $i."
                              echo "Preparing to run root privileged commands on $i.">>$LOGFIL
                          fi
                          compute_rootpassword=${a_compute_rootpassword[$stack_counter]}
                          compute_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l root $i ls >/dev/null 2>&1;echo $?);
                          if [[ -n "$compute_ssh_status" && $compute_ssh_status -eq 0 ]]
                          then
                              echo "root password not checked on $root_hostname  because ssh user equivalence found for root">>$LOGFIL
                              $SSHELL root@$i "$ROOTSCRPT" 
                          else
			      checkUserPassword "$i" "root" "$compute_rootpassword" "1"
			      if [ $passwordCheckStatus -eq 0 ]
			      then
				  fixRootPassword "$compute_rootpassword"
				  $EXPECT -f - 2>>$WATCHLOG << IBEOF
				  set timeout $passwordcheck_timeout
				  set le_compute_rootpassword "$fixedRootPassword"
                                  if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                    exp_internal 1
                                  }
				  spawn -noecho $SSHELL root@$i "$ROOTSCRPT"			
				  #spawn -noecho $SSHELL_EL $i "su - root -c $ROOTSCRPT"			
				  match_max 100000
				    expect {
				  "no)?" {
					send -- "yes\n"
					}
				  }
				  # Look for passwd prompt
				  expect "*?assword:*"
				  send -- "\$le_compute_rootpassword\n"
				  # Stop the on logon tests and if asked to connect to master switch choose no
				  set timeout $watchdog_wakeup_root
				  expect eof {
                                    exit
                                  } timeout {
                                    send_error "Timed out while running $ROOTSCRPT on $i\n";
                                    exit
                                  }
IBEOF
			      else
				  #echo -e "\n\n${RED}Still ${userToCheck} password for $nodeNameToCheck was wrong. $userToCheck priviledged check will not be executed on $nodeNameToCheck ${NORM}\n"
				  echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
			      fi
                          fi
                     else  
                         if [ $userid -ne 0 ]
                         then
                              echo -e "Preparing to run root privileged commands ${print_compute_node} $i.  Please enter root password when prompted."
                              echo "Preparing to run root privileged commands on $i.  Please enter root password when prompted.">>$LOGFIL
                         fi
                         $SSHELL root@$i "$ROOTSCRPT"			
                         #Fix for bug 14336860 
                         #$SSHELL_EL $i "su - root -c $ROOTSCRPT 2>/dev/null"
                     fi
                 fi
                 for FNAMEANDPATH in `$SSHELL -n $i "ls ${RTEMPDIR}/o_* 2>/dev/null"`
                 do
                    FNAME=`echo $FNAMEANDPATH |cut -d'/' -f4|sed 's/.out//g'`
                    if [ -e $OUTPUTDIR/$FNAME"_"$i".out" ]
                    then
                        $SSHELL $i cat $FNAMEANDPATH  >>$OUTPUTDIR/$FNAME"_"$i".out"
                    else
                        $SCOPY -r $i:$FNAMEANDPATH $OUTPUTDIR/$FNAME"_"$i".out" > /dev/null 2>&1
                    fi
                    if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -lt 1 && "$FNAME" != "o_exadata_disk.out" ]]; then $SSHELL $i rm -f $FNAMEANDPATH >/dev/null 2>&1;fi
                    if [[ `echo $FNAME|grep -ic "root_clusterwide_check"` -ge 1 ]]; then $SSHELL $i mv $FNAMEANDPATH /tmp  >/dev/null 2>&1; fi;
                 done
                  # Changes made by jrmullan 03/22/10
                 #$SSHELL $i rm -f /tmp/o_*.out >/dev/null 2>&1
                 if [[ -n "$ORACLEENVVARS" && $ORACLEENVVARS != "" ]];then $SSHELL $i rm -r /tmp/$ORACLEENVVARS >/dev/null 2>&1;fi;
                 $SSHELL $i rm -f $ROOTSCRPT >/dev/null 2>&1
                 if [ -f $ROOTSCRPT ]; then rm -f $ROOTSCRPT >/dev/null 2>&1;fi;
                 if [[ -e ${OUTPUTDIR}/o_root_collect_timing_${i}.out && -e $COLLECT_TIMING ]]
                 then
                     cat ${OUTPUTDIR}/o_root_collect_timing_${i}.out >> $COLLECT_TIMING
                     rm -f ${OUTPUTDIR}/o_root_collect_timing_${i}.out  >/dev/null 2>&1
                 fi
             else
		 echo -e "\n${RED}Skipping root privileged commands ${print_compute_node} ${NORM} ${i}\n"|tee -a $LOGFIL
             fi
         fi #Finished here with executing command with root for each host
          
         if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && $cell_root_command -gt 0  && $cell_password_status -ne 3 ]]
         then
             if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
             if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $CELLIP ]]  
             then
                 #cat $IBSWITCHSCRPT
                 #read -p "good to run"
                 if [ ! -e $CELLDIR ];then mkdir $CELLDIR >/dev/null 2>&1;fi
                 cp $CELLIP $CELLDIR 2>/dev/null 2>&1
                 root_cell_counter=0
                 no_of_cells=$(wc -l $CELLIP |awk '{print $1}')
                 no_of_cells=$(expr $no_of_cells - 1);
                 in_last_cell=0
                 if [[ ! -n "$RAT_CELL_RUNMODE" ]] ; then RAT_CELL_RUNMODE="parallel"; fi;
                 for cellname in `cat $CELLIP|cut -d= -f2|sed 's/"//g'` 
                 do
                   cellPingStatus=$($PING -c 1 $PING_W_FLAG $cellname >/dev/null 2>&1;echo $?)
                   if [[ -n "$cellPingStatus" && $cellPingStatus -eq 0 ]]
                   then
		       noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $cellname)
		       if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq "1" ]]
                       then
                           cellname_full=$cellname
                       else
		           cellname_full=$(cat /etc/hosts|grep -w "$cellname"|awk '{print $NF}'|cut -d'-' -f1)
                       fi
		       #echo "$cellname = $cellname_full" >>$CELLDIR/cells.out
                       if [[ $no_of_cells -eq $root_cell_counter ]] ; then in_last_cell=1; fi
		       cell_ssh_status1=$($SSHELL -o NumberOfPasswordPrompts=0 -l $cell_ssh_user $cellname ls >/dev/null 2>&1;echo $?);
		       if [[ -n "$cell_password_status" && $cell_password_status -ne 3 ]] && [[ -n "$cell_ssh_status1" && $cell_ssh_status1 -eq 0 && $is_exalogic_machine -eq 0 ]]
		       then # ssh is setup on cells
                         if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
			   echo -e "\nStarting to run $cell_ssh_user privileged commands in background on ${BLINK}STORAGE SERVER${NORM} $cellname_full\n"
                           start_run_on_cell_in_background
		           cellnameFullActual=$($SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1")
		           echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out
                         else
			   echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} $cellname_full\n"
                           if [[ -n "$DOROOT" && $DOROOT -eq 1 && -n "$RAT_CELL_SSH_USER" && $RAT_CELL_SSH_USER = "celladmin" ]] || [[ -n "$RAT_CELL_SSH_USER" && "$RAT_CELL_SSH_USER" = "cellmonitor" ]]
                           then
                               $SCOPY  $CELLSSCRPT $cell_ssh_user@$cellname:/tmp >/dev/null 2>&1
			       $SSHELL $cell_ssh_user@$cellname chmod 755 /tmp/${program_name}_cells.sh >/dev/null 2>&1
                               $SSHELL $cell_ssh_user@$cellname mkdir ${RTEMPDIR} >/dev/null 2>&1
                               $SSHELL -t $cell_ssh_user@$cellname sudo "/tmp/${program_name}_cells.sh" 2>/dev/null
			       #$SSHELL -o StrictHostKeyChecking=no $cell_ssh_user@$cellname /tmp/${program_name}_cells.sh 2>/dev/null 
			       $SCOPY  $cell_ssh_user@$cellname:${RTEMPDIR}/c_*.out $CELLDIR >/dev/null 2>&1
			       $SSHELL $cell_ssh_user@$cellname rm -f /tmp/${program_name}_cells.sh  >/dev/null 2>&1
			       $SSHELL $cell_ssh_user@$cellname rm -f ${RTEMPDIR}/c_*.out >/dev/null 2>&1
			       $SSHELL $cell_ssh_user@$cellname rmdir  ${RTEMPDIR} >/dev/null 2>&1
		               cellnameFullActual=$($SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1")
		               echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out
                           else
			       $SCOPY  $CELLSSCRPT $cell_ssh_user@$cellname:/tmp >/dev/null 2>&1
			       $SSHELL $cell_ssh_user@$cellname chmod 755 /tmp/${program_name}_cells.sh >/dev/null 2>&1
                               $SSHELL $cell_ssh_user@$cellname mkdir ${RTEMPDIR} >/dev/null 2>&1
			       $SSHELL $cell_ssh_user@$cellname /tmp/${program_name}_cells.sh 2>/dev/null 
			       $SCOPY  $cell_ssh_user@$cellname:${RTEMPDIR}/c_*.out $CELLDIR >/dev/null 2>&1
			       $SSHELL $cell_ssh_user@$cellname rm -f /tmp/${program_name}_cells.sh  >/dev/null 2>&1
			       $SSHELL $cell_ssh_user@$cellname rm -f ${RTEMPDIR}/c_*.out ${RTEMPDIR}/o_*.out >/dev/null 2>&1
			       $SSHELL $cell_ssh_user@$cellname rmdir  ${RTEMPDIR} >/dev/null 2>&1
		               cellnameFullActual=$($SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1")
		               echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out
                           fi
                         fi
		       elif [ $noPasswordAvailable -eq 0 ]
		       then
                           if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
			     echo -e "\nStarting to run $cell_ssh_user privileged commands in background on ${BLINK}STORAGE SERVER${NORM} $cellname_full\n"
                           else
			     echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} $cellname_full\n"
                           fi
			   if [[ -n "$cell_samerootpassword" && $cell_samerootpassword -eq 0 ]]
			   then
			       #echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} ${cellname_full}."
			       #echo -e "\n"
			       #printf  "Enter $cell_ssh_user password for ${BLINK}STORAGE SERVER${NORM} ${cellname_full} :- "
			       #stty -echo
			       #read cell_rootpassword
			       #stty echo
			       #echo -e "\n" 
			       cell_rootpassword=${a_cell_rootpassword[$root_cell_counter]}
			       
			    #else
			      #echo -e "\nPreparing to run $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER${NORM} $cellname_full\n"
			   fi
			   cell_type="normal"
			   if [[ $passwordCheckStatus -eq 0 ]]
			   then # Normal exadata cell
			       fixRootPassword "$cell_rootpassword"
                               cellhostname=$($EXPECT -f - << IBEOF
                                              set timeout $passwordcheck_timeout
					      set le_cell_rootpassword "$fixedRootPassword"
                                              log_user 1
                                              if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                                exp_internal 1
                                              } 
                                              spawn -noecho $SSHELL $cell_ssh_user@$cellname "hostname|cut -d. -f1"
                                              match_max 100000
                                              expect {
                                            "no)?" {
                                               send -- "yes\n"
                                                     }
                                                   }
                                              expect "*?assword:*"
						send -- "\$le_cell_rootpassword\n"
                                              # Stop the on logon tests and if asked to connect to master switch choose no
                                              expect eof 
IBEOF
)
                              cellnameFullActual=$(echo "$cellhostname"|tail -1|sed 's/ //g'|sed 's///g')
                              #cellnameFullActual=$(echo $cellhostname|awk 'BEGIN { FS = "password:" };{print $2}'|sed 's/ //g'|sed 's///g')
                              echo "$cellname = $cellnameFullActual" >>$CELLDIR/cells.out

                              if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
                                start_run_on_cell_in_background
                              else
			       fixRootPassword "$cell_rootpassword"
			       $EXPECT -f - << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SCOPY $CELLSSCRPT $SCRIPTPATH/.cgrep/$ASREXACHK $cell_ssh_user@$cellname:/tmp
				match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			       }
			       # Look for passwd prompt
			       expect "*?assword:*"
			       send -- "\$le_cell_rootpassword\n"
			       # Stop the on logon tests and if asked to connect to master switch choose no
			       expect eof
IBEOF
                               #-- gadiga create ${RTEMPDIR}
                               $EXPECT -f - << IBEOF
                               set timeout $passwordcheck_timeout			
			       set le_cell_rootpassword "$fixedRootPassword"
                               log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
                               spawn $SSHELL $cell_ssh_user@$cellname mkdir ${RTEMPDIR}
                               match_max 100000
                                 expect {
                               "no)?" {
                                     send -- "yes\n"
                                     }
                              }
                             # Look for passwd prompt
                             expect "*?assword:*"
			     send -- "\$le_cell_rootpassword\n"
                             # Stop the on logon tests and if asked to connect to master switch choose no
                             expect eof
IBEOF

			       $EXPECT -f - << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }  
			       spawn $SSHELL $cell_ssh_user@$cellname chmod 755 /tmp/${program_name}_cells.sh /tmp/$ASREXACHK
			       match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			      }
			     # Look for passwd prompt
			     expect "*?assword:*"
			     send -- "\$le_cell_rootpassword\n"
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     expect eof
IBEOF
			       $EXPECT -f - 2>>$WATCHLOG << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn -noecho $SSHELL $cell_ssh_user@$cellname /tmp/${program_name}_cells.sh
			       match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			      }	
			     # Look for passwd prompt
			     expect "*?assword:*"
			     send -- "\$le_cell_rootpassword\n"
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     set timeout $watchdog_wakeup_root
			     expect eof {
                                    exit
                                  } timeout {
                                    send_error "Timed out while running /tmp/${program_name}_cells.sh on $cellname\n";
                                    exit
                                  }
IBEOF
			       $EXPECT -f - << IBEOF
			       #set timeout 5
                               set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                  exp_internal 1
                               }    
			       spawn $SCOPY $cell_ssh_user@$cellname:${RTEMPDIR}/c_*.out $CELLDIR
			       match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			      }
			     # Look for passwd prompt
			     expect "*?assword:*"
			     send -- "\$le_cell_rootpassword\n"	
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     expect eof
IBEOF
			       $EXPECT -f - << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SSHELL $cell_ssh_user@$cellname rm -f /tmp/${program_name}_cells.sh /tmp/$ASREXACHK 2>/dev/null
			       match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			      }
			     # Look for passwd prompt
			     expect "*?assword:*"
			     send -- "\$le_cell_rootpassword\n"
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     expect eof
IBEOF
			       $EXPECT -f - << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }   
			       spawn $SSHELL $cell_ssh_user@$cellname rm -f ${RTEMPDIR}/c_*.out ${RTEMPDIR}/o_*.out
			       match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			      }
			     # Look for passwd prompt
			     expect "*?assword:*"
			     send -- "\$le_cell_rootpassword\n"
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     expect eof
IBEOF
                               $EXPECT -f - << IBEOF
			       set timeout $passwordcheck_timeout
			       set le_cell_rootpassword "$fixedRootPassword"
			       log_user 0
                               if { "$RAT_EXPECT_DEBUG" == "-d" } {
                                 exp_internal 1
                               }
			       spawn $SSHELL $cell_ssh_user@$cellname rmdir  ${RTEMPDIR}
			       match_max 100000
				 expect {
			       "no)?" {
				     send -- "yes\n"
				     }
			      }
			     # Look for passwd prompt
			     expect "*?assword:*"
			     send -- "\$le_cell_rootpassword\n"
			     # Stop the on logon tests and if asked to connect to master switch choose no
			     expect eof
IBEOF
                            fi
			   else
			       #echo -e "\n\n${RED}Still ${userToCheck} password for $nodeNameToCheck was wrong. $userToCheck privileged check will not be executed on $nodeNameToCheck ${NORM}\n"
			       echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
			   fi 
		       else
			   echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${cellname}\n"|tee -a $LOGFIL
		       fi
		       if [[ -e $CELLDIR/c_root_collect_timing.out && -e $COLLECT_TIMING ]]
		       then
			   cat $CELLDIR/c_root_collect_timing.out >> $COLLECT_TIMING
			   rm -f $CELLDIR/c_root_collect_timing.out  >/dev/null 2>&1
		       fi
                   else
		       echo -e "\n${RED}Skipping $cell_ssh_user privileged commands on ${BLINK}STORAGE SERVER ${NORM} ${RED} ${cellname} because its not available.${NORM}\n"|tee -a $LOGFIL
		       #echo -e "\n${RED}Skipping $cellname to execute $cell_ssh_user privileged checks because $cellname is not reachable${NORM}\n"
		       add_to_skipped_nodes "${cellname}" "Storage Server is not available"
                   fi  
                   root_cell_counter=$(expr $root_cell_counter + 1)
                 done
                 if [[ -n "$RAT_CELL_RUNMODE" && $RAT_CELL_RUNMODE = "parallel" ]] ; then
                   wait_for_cell_completion
                 fi

             fi
             if [ -e $CELLDIR/cells.out ]; then cp $CELLDIR/cells.out $RTEMPDIR >/dev/null 2>&1;fi
             root_cell_counter=0 
             #function to discover mixed hardware cells
             mixed_hardware_cells_discovery 
         fi #Finished here with executing command with root for each infiniband switch 
         if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && $ibswitch_root_command -gt 0  && -n "$ibswitch_password_status" && $ibswitch_password_status -eq 1 ]]
         then
             if [[ $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e ${RTEMPDIR}/o_ibswitches.out ]]  
             then
                 if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi  
                 #cat $IBSWITCHSCRPT
                 #read -p "good to run"
                 #function to map ip address to switch name and find switch type for each(leaf or spine)
                 switch_ip_type_name_mapping 
                 ib_root_counter=0
                 no_of_ibs=$(wc -l ${RTEMPDIR}/o_ibswitches.out | awk '{print $1}')
                 no_of_ibs=$(expr $no_of_ibs - 1);
                 in_last_ib=0
                 if [[ ! -n "$RAT_IBSWITCH_RUNMODE" ]] ; then RAT_IBSWITCH_RUNMODE="parallel"; fi;
                 for switchname in `cat ${RTEMPDIR}/o_ibswitches.out` 
                 do
                   if [ $no_of_ibs -eq $ib_root_counter ] ; then
                     in_last_ib=1
                   fi
                   #Following code is to change switch ip address to fully qualified domain name so OS_OUT_CHECK dont get skipped
                   is_ibswitch_ip=$(echo $switchname|grep -c [A-Za-z])
                   if [[ -n $is_ibswitch_ip && $is_ibswitch_ip -eq 0 ]]
                   then
                       switchname=$(nslookup $switchname|grep -i name|awk '{print $NF}'|sed 's/\.$//')
                   fi
                   echo $switchname>>$INPUTDIR/o_ibswitches.out      
                   #read -p "after converting ip to name"
                   noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $switchname)  
                   switch_ssh_status=$($SSHELL -o NumberOfPasswordPrompts=0 -l $ibswitch_user $switchname ls >/dev/null 2>&1;echo $?);
                   if [[ -n "$switch_ssh_status" && $switch_ssh_status -eq 0 ]]
                   then
                     if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
		       echo -e "\nStarting to run $ibswitch_user privileged commands in background on ${BLINK}INFINIBAND SWITCH ${NORM} ${switchname}\n"
                         start_run_on_ib_in_background
                     else
		       echo -e "\nPreparing to run $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${switchname}\n"

                       $SSHELL $ibswitch_user@$switchname mkdir ${RTEMPDIR} >/dev/null 2>&1
                       $SCOPY  $IBSWITCHSCRPT $ibswitch_user@$switchname:/tmp >/dev/null 2>&1
                       $SCOPY  $SWITCH_TYPE_FIL $ibswitch_user@$switchname:${RTEMPDIR} >/dev/null 2>&1
                       $SSHELL $ibswitch_user@$switchname chmod 755 /tmp/${program_name}_ibswitch.sh >/dev/null 2>&1
                       $SSHELL $ibswitch_user@$switchname /tmp/${program_name}_ibswitch.sh 2>/dev/null 
                       $SCOPY  $ibswitch_user@$switchname:${RTEMPDIR}/s_*.out $OUTPUTDIR >/dev/null 2>&1
                       $SSHELL $ibswitch_user@$switchname rm -f /tmp/${program_name}_ibswitch.sh  >/dev/null 2>&1
                       $SSHELL $ibswitch_user@$switchname rm -f ${RTEMPDIR}/s_*.out ${RTEMPDIR}/o_*.out ${RTEMPDIR}/${SWITCH_TYPE_FIL_SHORT} >/dev/null 2>&1
                       $SSHELL $ibswitch_user@$switchname rmdir ${RTEMPDIR} >/dev/null 2>&1
                     fi
                   elif [ $noPasswordAvailable -eq 0 ]
                   then
                     if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
		       echo -e "\nStarting to run $ibswitch_user privileged commands in background on ${BLINK}INFINIBAND SWITCH${NORM} ${switchname}.\n"
                     else
		       echo -e "\nPreparing to run $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH${NORM} ${switchname}.\n"
                     fi
		       if [[ -n "$ib_samerootpassword" && $ib_samerootpassword -eq 0 ]]
		       then
			   #echo -e "\n"
		       #    printf  "Enter $ibswitch_user password for ${BLINK}INFINIBAND SWITCH${NORM} ${switchname} :- "
		       #    stty -echo
		       #    read switch_rootpassword
		       #    stty echo
		       #    echo -e "\n" 
		       # else
		       #   echo -e "\nPreparing to run $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH${NORM} $switchname\n"
			  switch_rootpassword=${a_ib_switch_root_password[$ib_root_counter]}
		       fi
                       #read -p "$switchname $ibswitch_user $switch_rootpassword"  
                       checkUserPassword "$switchname" "$ibswitch_user" "$switch_rootpassword" "1"  
                       if [ $passwordCheckStatus -eq 0 ]
                       then
                         if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
                             start_run_on_ib_in_background
                         else
                           # gadiga - create the /tmp/.program first
			   fixRootPassword "$switch_rootpassword"
			   $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout 
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }  
			   spawn $SSHELL $ibswitch_user@$switchname mkdir ${RTEMPDIR}
			   match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
i			 send -- "\$le_switch_rootpassword\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF
			   $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout 
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }   
			   spawn $SCOPY $IBSWITCHSCRPT $ibswitch_user@$switchname:/tmp
			    match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_switch_rootpassword\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF
			   $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }   
			   spawn $SCOPY $SWITCH_TYPE_FIL $ibswitch_user@$switchname:${RTEMPDIR}
			    match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_switch_rootpassword\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF

			   $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout 
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }  
			   spawn $SSHELL $ibswitch_user@$switchname chmod 755 /tmp/${program_name}_ibswitch.sh
			   match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_switch_rootpassword\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF
			   $EXPECT -f - 2>>$WATCHLOG << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   #log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           } 
			   spawn -noecho $SSHELL_EL $ibswitch_user@$switchname /tmp/${program_name}_ibswitch.sh
			   match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_switch_rootpassword\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 set timeout $watchdog_wakeup
			 expect eof {
                                    exit
                                  } timeout {
                                    send_error "Timed out while running /tmp/${program_name}_ibswitch.sh on $switchname\n";
                                    exit
                                  } 
IBEOF
			   $EXPECT -f - << IBEOF
			   #set timeout 5
                           set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }
			   spawn $SCOPY $ibswitch_user@$switchname:${RTEMPDIR}/s_*.out $OUTPUTDIR
			   match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_switch_rootpassword\n"											
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF
			   $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           }
			   spawn $SSHELL $ibswitch_user@$switchname rm -f /tmp/${program_name}_ibswitch.sh
			   match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_switch_rootpassword\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF
			   $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } {
                             exp_internal 1
                           } 
			   spawn $SSHELL $ibswitch_user@$switchname rm -f ${RTEMPDIR}/s_*.out ${RTEMPDIR}/o_*.out ${RTEMPDIR}/${SWITCH_TYPE_FIL_SHORT}
			   match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_switch_rootpassword\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF
                  	   $EXPECT -f - << IBEOF
			   set timeout $passwordcheck_timeout
			   set le_switch_rootpassword "$fixedRootPassword"
			   log_user 0
                           if { "$RAT_EXPECT_DEBUG" == "-d" } { 
                             exp_internal 1
                           } 
			   spawn $SSHELL $ibswitch_user@$switchname rmdir ${RTEMPDIR}
			   match_max 100000
			     expect {
			   "no)?" {
				 send -- "yes\n"
				 }
			  }
			 # Look for passwd prompt
			 expect "*?assword:*"
			 send -- "\$le_switch_rootpassword\n"
			 # Stop the on logon tests and if asked to connect to master switch choose no
			 expect eof
IBEOF
                         fi # endif RAT_RUNMODE
                       else
                           #echo -e "\n\n${RED}Still ${userToCheck} password for $nodeNameToCheck was wrong. $userToCheck privileged check will not be executed on $nodeNameToCheck ${NORM}\n"
                           echo -e "\n\n${RED}Skipping ${userToCheck} privileged checks for ${nodeNameToCheck}.\nThe $userToCheck password must have been changed since the passwords were validated at the beginning of tool execution ${NORM}\n"|tee -a $LOGFIL  
                           add_to_skipped_nodes "$switchname" "The $ibswitch_user password validation failed on Infiniband Switch"
                       fi  
                   else
		       echo -e "\n${RED}Skipping $ibswitch_user privileged commands on ${BLINK}INFINIBAND SWITCH ${NORM} ${switchname}\n"|tee -a $LOGFIL
		        add_to_skipped_nodes "${switchname}" "The $ibswitch_user password validation failed Infiniband Switch."
                   fi
                   if [[ -e $OUTPUTDIR/s_root_collect_timing.out && -e $COLLECT_TIMING ]]
		   then
		       cat $OUTPUTDIR/s_root_collect_timing.out >> $COLLECT_TIMING
		       rm -f $OUTPUTDIR/s_root_collect_timing.out  >/dev/null 2>&1
		   fi
                   ib_root_counter=$(expr $ib_root_counter + 1)
                 done
                 if [[ -n "$RAT_IBSWITCH_RUNMODE" && $RAT_IBSWITCH_RUNMODE = "parallel" ]] ; then
                   wait_for_ib_completion
                 fi
                 #This is to copy new switch names file after converting ip addresses to fully qualified domain name
                 if [ -e $INPUTDIR/o_ibswitches.out ]; then mv -f $INPUTDIR/o_ibswitches.out  ${RTEMPDIR}/o_ibswitches.out;fi  
                 #read -p "stop after mvoing file"
             fi
             #function to map ip address to switch name and find switch type for each(leaf or spine)
             #switch_ip_type_name_mapping 
         fi #Finished here with executing command with root for each infiniband switch 

         if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 ]] && [ $components != "OVM" ] 
         then 
            if [ $SILENT -eq 0 ]
            then
                 #commented following if because exalogic also has collections and want to print this on exalogic too 
                 #if [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 0 || $i = $localnode ]]
                 #then 
                     echo -e "\n\nData collections completed. Checking best practices on ${i}."
                     echo -e "--------------------------------------------------------------------------------------\n\n" 
                 #fi  
            else
                echo -e "\n\nNow collecting Oracle Patch inventory.Please standby."
            fi
         fi
         if  [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" ]] ; then
           if [[ $RAT_RUNMODE_INTERNAL = "master" ]] ; then # master.. scp the *v_parameter* to all nodes
             odir=$(basename $OUTPUTDIR)
             for rnode in `cat $HOSTLIST.org |grep -v $localnode`
             do
               $SCOPY $OUTPUTDIR/*v_parameter* $rnode:$RTEMPDIR/$odir > /dev/null 2>&1
               $SSHELL $rnode "touch $RTEMPDIR/master.collections.done "
             done
           elif [[ $is_exalogic_machine -eq "0" ]] ; then # wait for $RTEMPDIR/master.collections.done
             #echo "waiting for master collections. ";
             mc_done=0
             while [[ $mc_done -eq "0" ]] ; do
               if [[ -e "$RTEMPDIR/master.collections.done" ]] ; then mc_done=1; fi;
               if [[ $mc_done -eq "0" ]] ; then
                 #printf ". "
                 sleep 2
               fi
             done
             echo
           fi
         fi
         #if [[ $OSCOLLECTCNT -eq $OSCOLLECTSUM && $OFFLINE -eq 0 ]]; then cp -r $OUTPUTDIR/*vm_cfg_guid* $RTEMPDIR >/dev/null 2>&1; cp -r $OUTPUTDIR/*showvnics_guid* $RTEMPDIR >/dev/null 2>&1;fi
  ;;
     SQL|SQL_PARAM|SQL_COLLECT|SQL_OUT_CHECK|OS_PARAM|OS_PACKAGE|OS_PATCH|CLUSTERWIDE_CHECK|SYSTEMWIDE_CHECK|ORACLE_PATCH|CROSS_NODE_CHECK)
       case $COMTYPE in
         SQL)
           #if [ ${stack_asm_up[$stack_counter]} -eq 1 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ]
           if [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
           then
               call_get_log_result=0
               echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL
           #if  [[ -n "$it_is_rac" && $it_is_rac -eq 0 &&  $component_match_count  -lt 1 ]]
           elif  [[ $component_match_count  -lt 1 ]]
           then
               echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
               call_get_log_result=0
           else   
               call_get_log_result=1
               mb_db_counter=0
               mb_db_counter_log=0
	       if [[ -n "${stack_dbinst_up[$stack_counter]}" &&  ${stack_dbinst_up[$stack_counter]} -ne 0 ]]
	       then
		   if [ $op_mode -eq 0 ]
		    then
			COM=`grep "_"$ROW"-SQL_COMMAND" $REFFIL |sed  -n 's/.*SQL_COMMAND //p'`
			COM_REPORT=`grep "_"$ROW"-SQL_COMMAND_REPORT" $REFFIL |sed  -n 's/.*SQL_COMMAND_REPORT //p'`
			audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
		    else
			COM=`grep "_"$CHECK_ID"-SQL_COMMAND" $REFFIL |sed  -n 's/.*SQL_COMMAND //p'`
			COM_REPORT=`grep "_"$CHECK_ID"-SQL_COMMAND_REPORT" $REFFIL |sed  -n 's/.*SQL_COMMAND_REPORT //p'`
			audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
		    fi
		   audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
		   #in this case $SPOOLFILE already exists so we can lookup the value
		   #we're looking for now
		   #VAL=`grep $PARAM_PATH $SPOOLFIL |awk {'print $3'}`
                   ORIG_PMSG=$PMSG
                   ORIG_FMSG=$FMSG
                   for db_name_to_check in "${mb_db_names[@]}"
                   do
                     skip_this_version=0
                     set_skip_this_version "-"
                     if [ $skip_this_version -eq 1 ]
                     then #dont run
                            mb_db_counter=$(expr $mb_db_counter + 1)
                            echo "Skipping check($CHECK_ID) on version 4 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                            continue
                     fi
                        match_database_role "${mb_database_role[$mb_db_counter]}"
                        match_database_type "${mb_database_type[$mb_db_counter]}"
                        if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]]
                        #if [[ "${mb_database_role[$mb_db_counter]}" = "$check_database_role" ]]
                        then 
			    DBACTUAL=$OUTPUTDIR/d_actual_${db_name_to_check}.out
			    if [[ $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]] #remote_database_code && $i = $localnode ]]
			    then
				export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
				export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
				INFIL=${INPUTDIR}/${CHECK_ID}_${db_name_to_check}.sql
				echo "$COM">$INFIL
				OUTFIL=$OUTPUTDIR/d_check_${db_name_to_check}.out
				#read -p "ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID infile is $INFIL and query is $COM"
                                
                                #if its PDB then will connect to database using user name and password
                                if [ "${mb_database_type[$mb_db_counter]}" = "PDB" ]
                                then 
                                    #IS_SYSDBA=0
                                    dbConnectString="${RAT_PDB_USER}/${mb_db_sys_password[$mb_db_counter]}@"${mb_db_connect_string[$mb_db_counter]}" as sysdba"  
                                else
                                    DBUSR=${mb_sysdba_user[$mb_db_counter]}
                                    DBPWD=${mb_sysdba_pswd[$mb_db_counter]}
                                    dbConnectString="$DBUSR/$DBPWD as sysdba"  
                                fi
                                #read -p "running for $db_name_to_check" 
				if [[ -n "${mb_checksysdba[$mb_db_counter]}" && ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
				then
                                  
				  if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
				  then
				    $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
				    set head off
				    set lines 80
				    set feedback off
				    set serveroutput on
				    spool $OUTFIL append
				    @@$INFIL
				    spool off
				    exit
EOF
				  else #remote_database_code
				    $SCOPY $INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                      export ORACLE_HOME=$ORACLE_HOME;
                                      export ORACLE_SID=$ORACLE_SID;
				    $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
				    set head off
				    set lines 80
				    set feedback off
				    set serveroutput on
				    spool $RTEMPDIR/sqltorun.out
				    @@$RTEMPDIR/sqltorun.sql
				    spool off
				    exit
EOF
EOF2
				    $SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
                                    cat $RTEMPDIR/sqltorun.out >> $OUTFIL
#echo "Output from sql collection $INFIL"; cat $RTEMPDIR/sqltorun.out
				  fi
				else
				  if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
				  then
				    #read -p "before asm collection"
				    $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
				    set head off
				    set lines 80
				    set feedback off
				    set serveroutput on
				    spool $OUTFIL append
				    @@$INFIL
				    spool off
				    exit
EOF
				  else #remote_database_code
				    $SCOPY $INFIL ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                      export ORACLE_HOME=$ORACLE_HOME;
                                      export ORACLE_SID=$ORACLE_SID;
				    $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
				    set head off
				    set lines 80
				    set feedback off
				    set serveroutput on
				    spool $RTEMPDIR/sqltorun.out
				    @@$RTEMPDIR/sqltorun.sql
				    spool off
				    exit
EOF
EOF2
				    $SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
                                    cat $RTEMPDIR/sqltorun.out >> $OUTFIL
#echo "Output from sql collection $INFIL"; cat $RTEMPDIR/sqltorun.out
				  fi
				 #read -p "check asm collection $ORACLE_SID and $ORACLE_HOME $OUTFIL and infile=$INFIL"
			       fi
			   else
                               if [[ `uname -s` = "HP-UX" ]] ; then
                                 PARAM_PATH_GRP=$(echo "$PARAM_PATH"| sed s'/\$/\\\$/g')
			         VAL=`grep -w $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
			         VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
			       else
			         VAL=`grep -w $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
			         VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
			       fi
			   fi 
                           #read -p "stop here for db_create_online_log_dest_1_and_log_file_name_convert"
			   if [[ -n "$COM_REPORT" && $OFFLINE -eq 0 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" ]]
			   then
				export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
				export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
				INFIL_REPORT=${INPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.sql
				echo "$COM_REPORT">$INFIL_REPORT
				SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
				if [ $OFFLINE -eq 0 ]
				then
				    SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${db_name_to_check}_report.out
				else
				    SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
				fi
				echo -e "TO REVIEW COLLECTED DATA FOR $(echo $db_name_to_check|tr "[a-z]" "[A-Z]") FOR $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>$SOURCEFIL_REPORT
				#read -p "ORACLE_HOME=$ORACLE_HOME and ORACLE_SID=$ORACLE_SID infile is $INFIL and query is $COM"
				if [[ -n "${mb_checksysdba[$mb_db_counter]}" && ${mb_checksysdba[$mb_db_counter]} -eq 0 ]]
				then
				  if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
				  then
				    $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
				    set head off
				    set lines 80
				    set feedback off
				    set serveroutput on
				    spool $SOURCEFIL_REPORT append
				    @@$INFIL_REPORT
				    spool off
				    exit
EOF
				  else #remote_database_code
				    $SCOPY $INFIL_REPORT ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                      export ORACLE_HOME=$ORACLE_HOME;
                                      export ORACLE_SID=$ORACLE_SID;
				    $ORACLE_HOME/bin/sqlplus -s "$dbConnectString" >/dev/null 2>&1 <<EOF
				    set head off
				    set lines 80
				    set feedback off
				    set serveroutput on
				    spool $RTEMPDIR/sqltorun.out
				    @@$RTEMPDIR/sqltorun.sql
				    spool off
				    exit
EOF
EOF2
				    $SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
                                    cat $RTEMPDIR/sqltorun.out >> $SOURCEFIL_REPORT
				  fi
				else
				    #read -p "before asm collection"
				  if [ ${mb_running_host[$mb_db_counter]} = $localnode ]
				  then
				    $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
				    set head off
				    set lines 80
				    set feedback off
				    set serveroutput on
				    spool $SOURCEFIL_REPORT append
				    @@$INFIL_REPORT
				    spool off
				    exit
EOF
				  else #remote_database_code
				    $SCOPY $INFIL_REPORT ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.sql
                                    $SSHELL ${mb_running_host[$mb_db_counter]} bash <<EOF2
                                      export ORACLE_HOME=$ORACLE_HOME;
                                      export ORACLE_SID=$ORACLE_SID;
				    $ORACLE_HOME/bin/sqlplus -s / as sysdba >/dev/null 2>&1 <<EOF
				    set head off
				    set lines 80
				    set feedback off
				    set serveroutput on
				    spool $RTEMPDIR/sqltorun.out
				    @@$RTEMPDIR/sqltorun.sql
				    spool off
				    exit
EOF
EOF2
				    $SCOPY ${mb_running_host[$mb_db_counter]}:$RTEMPDIR/sqltorun.out $RTEMPDIR
                                    cat $RTEMPDIR/sqltorun.out >> $SOURCEFIL_REPORT
				  fi
				 #read -p "check asm collection $ORACLE_SID and $ORACLE_HOME $OUTFIL and infile=$INFIL"
			       fi
			   else
				SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
				if [ $OFFLINE -eq 0 ]
				then
				    SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${db_name_to_check}_report.out
				else
				    SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${db_name_to_check}_report.out
				fi
			   fi
                           if [[ `uname -s` = "HP-UX" ]] ; then
                             PARAM_PATH_GRP=$(echo "$PARAM_PATH"| sed s'/\$/\\\$/g')
			     VAL=`grep -w $PARAM_PATH_GRP $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
			     VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
			   else
			     VAL=`grep -w $PARAM_PATH $OUTPUTDIR/d_check_${db_name_to_check}.out|cut -d= -f2`
			     VAL=`echo $VAL|sed 's/^ *\(.*\) *$/\1/'`
			   fi
			   call_get_log_result=0
			   #PMSG=$(echo $ORIG_PMSG for ${GREEN}${db_name_to_check}${NORM})
			   #FMSG=$(echo $ORIG_FMSG for ${ORANGE}${db_name_to_check}${NORM})
			   PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
			   FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
			   #if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
			   get_log_result "inloop" "-"
			   mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                           #read -p "stop for pass/fail $db_name_to_check"
                       else
                           call_get_log_result=0    
                           echo "skipping $COM at $ROW for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL
                       fi
                       mb_db_counter=$(expr $mb_db_counter + 1)
                   done
                   write_report_on_fail=1
               else
                   call_get_log_result=0
                   echo -e "\n\nskipping $COM at $ROW ($audit_check_name) because either no database was running or user selected None from database select list\n\n">>$LOGFIL
	       fi
           fi
         #      read -p "COM=$COM param path=$PARAM_PATH at $ROW recommended value=$COMP operator=$OP alert level=$ALVL actual value=$VAL" 
           ;;
         SQL_COLLECT)
           #echo "${stack_asm_up[$stack_counter]}  ${stack_dbinst_up[$stack_counter]} ${stack_db_status[$stack_counter]}"
           mb_db_counter=0
           if [ $OFFLINE -eq "0" ] &&  [ ${stack_asm_up[$stack_counter]} -eq 1 -o ${stack_db_status[$mb_db_counter]} -ne 0 -o ${stack_dbinst_up[$stack_counter]} -ne 0 ] 
           then
              call_get_log_result=1
               if [ $op_mode -eq 0 ]
                then
                    COM=`grep "_"$ROW"-SQL_COLLECT_COMMAND" $REFFIL |sed  -n 's/.*SQL_COLLECT_COMMAND //p'`
                    COLLECTION_NAME=`grep "_"$ROW"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
                else
                    COM=`grep "_"$CHECK_ID"-SQL_COLLECT_COMMAND" $REFFIL |sed  -n 's/.*SQL_COLLECT_COMMAND //p'`
                    COLLECTION_NAME=`grep "_"$CHECK_ID"-COLLECTION_NAME" $REFFIL |sed  -n 's/.*COLLECTION_NAME //p'`
                fi
                #OUTFILNAME is the name we set up in the app as the file name we want
                #the data redirected to when doing OS and SQL COLLECTs
                #we'll search this file for OS and SQL param values
                #so SQL and OS COLLECT creates OUTFIL in the OUTPUTDIR
                #SQL and OS PARAM reads the values of the parameters from OUTFIL
                #OUTFIL will also be archived at the end
                #FIELDPOS is the position we define in the app to tell the script
                #which field to look in for the value as the position might vary from
                #command to command or OS to OS
                if [ $op_mode -eq 0 ]
		then
	            OUTFILNAM=`grep _$ROW\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
		else
		    OUTFILNAM=`grep _$CHECK_ID\-OUTPUT_FILE $REFFIL |awk {'print $2'}`
		fi
                if [ "$NEEDS_RUNNING" = "ASM" ]
                then
                    OUTFIL=$OUTPUTDIR/"a_"$OUTFILNAM".out"
		    INFIL=$INPUTDIR/"d_"$OUTFILNAM"_"$DB".sql"
                else
                    mb_db_counter=0
                    mb_db_counter_log=0
		    for db_name_to_check in "${mb_db_names[@]}"
		    do
		      skip_this_version=0
                      set_skip_this_version "-"
                      if [ $skip_this_version -eq 1 ]
                      then
                            mb_db_counter=$(expr $mb_db_counter + 1)
                            echo "Skipping check($CHECK_ID) on version 5 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                            continue
                      fi

		        OUTFIL=$OUTPUTDIR/"d_"$OUTFILNAM"_"$db_name_to_check".out"
			INFIL=$INPUTDIR/"d_"$OUTFILNAM"_"$db_name_to_check".sql"
                        export ORACLE_SID=${mb_oracle_sids[$mb_db_counter]}
                        export ORACLE_HOME=${mb_oracle_homes[$mb_db_counter]}
                        match_database_role "${mb_database_role[$mb_db_counter]}"
                        match_database_type "${mb_database_type[$mb_db_counter]}"
                        if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]]
                        then
                            call_get_log_result=0
                             get_log_result "inloop" "-"
			     mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                        else
                            echo "skipping $COM at $ROW for $db_name_to_check because database role does not(${mb_database_role[$mb_db_counter]}) match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL                                   
                        fi
                        mb_db_counter=$(expr $mb_db_counter + 1)
			#note that since each sql command is run only once, unlike OS commands
			#and there's no host name to account for, we'll go ahead and append the
			#.out extension here rather than in log_result()
		 	#if [ "$NEEDS_RUNNING" = "ASM" ]
			#then
			#    OUTFIL=$OUTPUTDIR/"a_"$OUTFILNAM"_"$DB".out"
			#else
			#fi
			#OUTFIL=$OUTPUTDIR/"d_"$OUTFILNAM".out"

			#in the case of SQL_COLLECT we need both an OUTFIL (spool file)
			#and an INFIL (a script file) which will be executed by SQL*Plus
			#it is named the same but with a .sql extension
			#and will be stored in INPUTDIR instead of OUTPUTDIR
		    done
                    mb_db_counter=0
                fi
           fi
           ;;
         SQL_PARAM)
           mb_db_counter=0
           mb_db_counter_log=0
           if [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
           then
               call_get_log_result=0
               echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL
           #elif  [[ -n "$it_is_rac" && $it_is_rac -eq 0 &&  $component_match_count  -lt 1 ]]
           elif  [[ $component_match_count  -lt 1 ]]
           then
               echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
               call_get_log_result=0
           else   
               call_get_log_result=1
	       if [[ -n "${stack_dbinst_up[$stack_counter]}" && ${stack_dbinst_up[$stack_counter]} -ne 0 ]] || [ ${stack_asm_up[$stack_counter]} -eq 1 ]
	       then
		   COM=`echo "SQL PARAMETER $PARAM_PATH  $OP  $COMP"`
		   if [ $op_mode -eq 0 ]
		    then
			SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		    else
			SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		    fi
		   SOURCEFILENAME=$SOURCEFIL
                   if [[ "$SOURCEFILENAME" = "v_parameter_asm" && ${stack_asm_up[$stack_counter]} -eq 1 ]]
		   then
                       SOURCEFIL_REPORT=$OUTPUTDIR/"a_"$SOURCEFIL".out"
                       if [ $OFFLINE -eq 0 ]
                       then
                           SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"a_"$SOURCEFIL".out"
                       else
                           SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"a_"$SOURCEFIL".out"
                       fi
		       SOURCEFIL=$OUTPUTDIR/"a_"$SOURCEFIL".out"
                       if [ -e $SOURCEFIL ]
                       then
			   if [ $op_mode -eq 0 ]
			   then
			       FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
			   else
			       FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
			   fi       
			   inst_name=${stack_asm_sid[$stack_counter]}
			   case $FIELDPOS in
			      1) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $1'}`
			      ;;
			      2) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $2'}`
			      ;;
			      3) 
                                 # removed + from ASM instnace in hp-ux to avoid rep: ?, *, or + not preceded by valid regular expression
                                 if [ `uname -s` = "HP-UX" ]
                                 then 
                                     inst_name_trimmed=$(echo $inst_name|sed 's/\+//g')
                                     VAL=`grep -wi "${inst_name_trimmed}.${PARAM_PATH}" $SOURCEFIL |awk {'print $3'}`
                                 else
                                     VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $3'}`  
                                 fi
			      ;;
			      4) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $4'}`
			      ;;
			      5) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |awk {'print $5'}`
			      ;;
			      99) VAL=`grep -wi "${stack_asm_sid[$stack_counter]}.${PARAM_PATH}" $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
			      ;;
			   esac          
                       fi
			#if [ $ISBRANCH -eq 0 ]; then echo "$inst_name|$CHECK_ID|$VAL">>$AACTUAL; fi 
                   else  
                       ORIG_PMSG=$PMSG
                       ORIG_FMSG=$FMSG
		       for db_name_to_check in "${mb_db_names[@]}"
		       do
		         skip_this_version=0
		         set_skip_this_version "-"
                         if [ $skip_this_version -eq 1 ]
                         then
                            mb_db_counter=$(expr $mb_db_counter + 1)
                            echo "Skipping check($CHECK_ID) on version 6 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                            continue
                        fi
                           source_file_exists=0
			   if [ $OFFLINE -eq 0 ]
                           then
                               inst_name=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_NAME|awk '{print $3}')
                               inst_mode=$(grep -w "$i.$db_name_to_check" $MASTERFIL|grep INSTANCE_MODE|awk '{print $3}')
                           else
                               inst_name=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_NAME|awk '{print $3}')
                               inst_mode=$(grep -w "$i.$db_name_to_check" $DUMPDIR/$CHKFIL|grep INSTANCE_MODE|awk '{print $3}')
                           fi
                           match_database_role "${mb_database_role[$mb_db_counter]}"
                           match_database_type "${mb_database_type[$mb_db_counter]}"  
                           if [[ $dbrole_match_count -ge 1 && $dbtype_match_count -ge 1 ]] 
			   then
			       DBACTUAL=$OUTPUTDIR/d_actual_${db_name_to_check}.out
			       #if [[ "$SOURCEFILENAME" = "v_parameter" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
			       if [[ "$SOURCEFILENAME" = "v_parameter" && $inst_mode -ne 0 ]]
			       then
				   SOURCEFIL_REPORT=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
				   if [ $OFFLINE -eq 0 ]
				   then
				       SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
				   else
				       SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
				   fi
				   SOURCEFIL=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
                                   instance_exists=0
                                   if [ -e $SOURCEFIL ] ;then instance_exists=$(grep -wc $inst_name $SOURCEFIL);fi  
				   if [[ -e $SOURCEFIL && $instance_exists -gt 0 ]]
				   then
				       source_file_exists=1
				       if [ $op_mode -eq 0 ]
				       then
					   FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
				       else
					   FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
				       fi
				       case $FIELDPOS in
					  1) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $1'}`
					  ;;
					  2) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $2'}`
					  ;;
					  3) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $3'}`
					  ;;
					  4) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $4'}`
					  ;;
					  5) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |awk {'print $5'}`
					  ;;
					  99) VAL=`grep -wi "${inst_name}.${PARAM_PATH}" $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
					  ;;
				       esac
				   fi
			       #elif [[ "$SOURCEFILENAME" = "v_parameter_u" && ${stack_db_status[$mb_db_counter]} -ne 0 ]]
			       elif [[ "$SOURCEFILENAME" = "v_parameter_u" && ${inst_mode} -ne 0 ]]
			       then
				   SOURCEFIL_REPORT=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
				   if [ $OFFLINE -eq 0 ]
				   then
				       SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
				   else
				       SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
				   fi
				   SOURCEFIL=$OUTPUTDIR/"d_"$SOURCEFILENAME"_"${db_name_to_check}".out"
				   if [ -e $SOURCEFIL ]
				   then
				       source_file_exists=1
				       if [ $op_mode -eq 0 ]
				       then
					   FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
				       else
					   FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
				       fi
				       case $FIELDPOS in
					  1) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
					  ;;
					  2) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
					  ;;
					  3) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
					  ;;
					  4) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
					  ;;
					  5) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
					  ;;
					  99) VAL=`grep -w $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
					  ;;
				       esac
				   fi  
			       fi
                               if [[ $inst_mode -eq 0 || $source_file_exists -eq 0 || $instance_exists -eq 0 ]]; then call_get_log_result=0;fi
			       if [[ $inst_mode -ne 0 && $source_file_exists -eq 1 && $instance_exists -gt 0 ]]
			       then
				   #if [ $ISBRANCH -eq 0 ]; then echo "$inst_name|$CHECK_ID|$VAL">>$DBACTUAL; fi 
				   call_get_log_result=0
				   #PMSG=$(echo $ORIG_PMSG on ${GREEN}${inst_name}${NORM} instance) 
				   #FMSG=$(echo $ORIG_FMSG on ${ORANGE}${inst_name}${NORM} instance)
				   PMSG=$(echo $ORIG_PMSG on ${inst_name} instance) 
				   FMSG=$(echo $ORIG_FMSG on ${inst_name} instance)
				   #read -p "inst_name=$inst_name"
				   if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
				   get_log_result "inloop" "-"
			           mb_db_counter_log=$(expr $mb_db_counter_log + 1)
                               else
                                   echo "skipping $PARAM_PATH at $ROW for $db_name_to_check because inst_mode=$inst_mode and source_file_exists=$source_file_exists \
                                         and instance_exists=$instance_exists">>$LOGFIL
                                   if [[ $inst_mode -ne 0 && $source_file_exists -eq 1 && $instance_exists -eq 0 ]]
                                   then
                                       echo "skipping SQL Parameter $PARAM_PATH checking (checkid:-$CHECK_ID) because $inst_name not found in $SOURCEFIL" >>$SKIPFIL 
                                   fi
			       fi
                           else
                               call_get_log_result=0    
                               echo "skipping $PARAM_PATH at $ROW for $db_name_to_check because database role (${mb_database_role[$mb_db_counter]}) does not match to check role ($check_database_role) or database type(${mb_database_type[$mb_db_counter]}) does not match to ${check_database_type}">>$LOGFIL
                           fi
			   mb_db_counter=$(expr $mb_db_counter + 1)
		       done
                   mb_db_counter=0
                   write_report_on_fail=1
                   fi
	       fi
           fi
           ;;
         OS_PARAM)
           if  [[  $component_match_count  -lt 1 ]]
           then
               echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
               call_get_log_result=0
           elif [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
           then
               call_get_log_result=0
               echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL
           else   
               call_get_log_result=1
	       COM=`echo "OS PARAMETER $PARAM_PATH  $OP  $COMP"`
	       if [ $op_mode -eq 0 ]
	       then
		   SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	       else
		   SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	       fi
	       SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
               if [ $OFFLINE -eq 0 ]
               then
	           SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
               else
	           SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
               fi
	       SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
	       if [ $op_mode -eq 0 ]
	       then
		   FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	       else
		   FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`
	       fi 
           fi
           ;;
         CROSS_NODE_CHECK)
           #Following code is to store CROSS_NODE_CHECK check_ids. later based on this list, checks will be executed.
	   call_get_log_result=0
           if [ "$i" = "$localnode" ]
           then
	       #call_get_log_result=1
	       if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
	       noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $i)       
	       if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
	       then
		   call_get_log_result=0
	       elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	       then
		   call_get_log_result=0
	       elif [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
	       then
		   call_get_log_result=0
		   echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL
	       elif  [[ $component_match_count  -lt 1 ]]
	       then
		   echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
		   call_get_log_result=0
	       else    
		   call_get_log_result=0
                   process_cross_node_checks=1
                   cross_node_checkids[$cross_node_checkids_counter]=$CHECK_ID
		   cross_node_checkids_counter=$(expr $cross_node_checkids_counter + 1 ) 
                   echo $CHECK_ID >> $OUTPUTDIR/cross_node_checkids.out
	       fi
           fi   
           #read -p "stop for cross node check"  
           ;;  
         CLUSTERWIDE_CHECK|SYSTEMWIDE_CHECK)
           call_get_log_result=1
           #read -p "PARAM=$PARAM asm_installed=${asm_installed[$stack_counter]} needs_running=$NEEDS_RUNNING asm_up= ${stack_asm_up[$stack_counter]} "
               #read -p "PARAM=$PARAM asm_installed=${asm_installed[$stack_counter]} needs_running=$NEEDS_RUNNING asm_up= ${stack_asm_up[$stack_counter]} "
           if [ -z "$noRootScriptNode" ];then noPasswordAvailable=0;fi
           noPasswordAvailable=$(echo ${noRootScriptNode[*]}|grep -c $i)       
           if [[ $PARAM = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $PARAM = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $PARAM = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
	   then
	       call_get_log_result=0
	   #elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	   elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	   then
	       call_get_log_result=0
	   elif [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
           then
               call_get_log_result=0
               echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL
           elif  [[ $component_match_count  -lt 1 ]]
           then
               echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
               call_get_log_result=0
           #elif [[ -n "$noPasswordAvailable" && $noPasswordAvailable -ge 1 ]]
           #then
           #    call_get_log_result=0
	   else    
	       call_get_log_result=1 
               if [ $op_mode -eq 0 ]
               then
                   if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ]
                   then
	               COM=`grep "_"$ROW"-CLUSTERWIDE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*CLUSTERWIDE_CHECK_COMMAND //p'`
                   else
	               COM=`grep "_"$ROW"-SYSTEMWIDE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*SYSTEMWIDE_CHECK_COMMAND //p'`
                   fi
	           audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                   REQUIEE_ROOT=`grep "_"$ROW"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
               else
                   if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ]
                   then
	               COM=`grep "_"$CHECK_ID"-CLUSTERWIDE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*CLUSTERWIDE_CHECK_COMMAND //p'`
                   else
	               COM=`grep "_"$CHECK_ID"-SYSTEMWIDE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*SYSTEMWIDE_CHECK_COMMAND //p'`
                   fi
	           audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
                   REQUIEE_ROOT=`grep "_"$CHECK_ID"-REQUIRES_ROOT" $REFFIL |sed  -n 's/.*REQUIRES_ROOT //p'`
               fi
	       audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
#               read -p "rootYesNoint=$rootYesNoint"
               if [[ $REQUIEE_ROOT -eq 1 && $rootYesNoint -eq 3 ]]
               then
                  echo "">/dev/null 
	          call_get_log_result=0
               else
 #                  echo "audit_check_name=$audit_check_name executed"
		   if [ $OFFLINE -eq "0" ]
		   then
		       if [ $i = $localnode ]
		       then
			   copy_env_files_to_tmp
			   localcmd=/tmp/localcmd.sh
			   echo "#!$bash_scr" >$localcmd
			   echo "$bash_source" >>$localcmd
			   echo ". $TRGTORCLENV">>$localcmd
			   echo "$COM 2>>$ERRFIL">>$localcmd
			   chmod 755 $localcmd
			   FILVAL=`$localcmd 2>>$ERRFIL`
			   if [ -e $localcmd ]; then rm $localcmd; fi;
		       else
			   copy_env_files_to_tmp
			   FILVAL=`$SSHELL $i " . $TRGTORCLENV; $COM" 2>>$ERRFIL`
		       fi
		       echo "" >>$OSSPOOLFIL
		       #echo " $PARAM_PATH $ROW  $COM == $FILVAL" >>$OSSPOOLFIL
		       printf "%s %s %s %s %s\n" " $PARAM_PATH $ROW $COM == $FILVAL" >>$OSSPOOLFIL
		   fi 
		   VAL=`grep "$PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
                   if [ -n "$VAL" ]
                   then  
                       echo $CHECK_ID >> $OUTPUTDIR/crs_checkids.out
		       if [  ! -f $CLUSTERCHECK_FIL ]
		       then
			   crs_check_id[$clusterware_check_count]=$CHECK_ID
			   clusterware_check_count=`expr $clusterware_check_count + 1`
			   if [ $OFFLINE -eq "0" ]; then echo "$i $ROW $COM == $FILVAL" >$CLUSTERCHECK_FIL; fi;
		       else
			   crs_check_id[$clusterware_check_count]=$CHECK_ID
			   clusterware_check_count=`expr $clusterware_check_count + 1`
			   if [ $OFFLINE -eq "0" ]; then echo "$i $ROW $COM == $FILVAL" >>$CLUSTERCHECK_FIL; fi;
		       fi
                   fi 
                   if [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $CELLIP  && cell_password_status -ne 3 && "$COMTYPE" = "SYSTEMWIDE_CHECK" && -n "$skip_in_silent" && $skip_in_silent -eq 0 ]]
                   then
                       cellFilePlaceHolder=$(echo $COM|sed  -n 's/.*cat //p'|awk -F. '{print $1}'|sed 's/\/tmp\/o_//g')
                       #echo "cellFilePlaceHolder=$cellFilePlaceHolder"
                       for cellname in `cat $CELLIP|cut -d= -f2|sed 's/"//g'`
                       do
                         cellname=$(cat $CELLDIR/cells.out|grep "$cellname"|awk '{print $NF}')
                         if [ -e $CELLDIR/c_cwc_${cellFilePlaceHolder}_${cellname}.out ]; then FILVAL=$(cat $CELLDIR/c_cwc_${cellFilePlaceHolder}_${cellname}.out);fi
			 if [ $OFFLINE -eq "0" ]; then echo "$cellname $ROW $COM == $FILVAL" >>$CLUSTERCHECK_FIL; fi;
                       done
                   fi
                   
                   #making to CLUSTERWIDE_CHECK so log_fail and log_pass can work as before
                   if [ "$COMTYPE" = "SYSTEMWIDE_CHECK" ]; then COMTYPE=CLUSTERWIDE_CHECK;fi
		   #read -p "CLUSTERCHECK_FIL=$CLUSTERCHECK_FIL"
    #	       if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL ;fi 
	       #    fi
	       fi
           fi
          ;;
         OS_PATCH)
           if [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
           then
               call_get_log_result=0
               echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL
           elif  [[ $component_match_count  -lt 1 ]]
           then
               echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL  
               call_get_log_result=0
           else
               call_get_log_result=1
	       if [ $OFFLINE -eq 0 ]
	       then
		   if [ $op_mode -eq 0 ]
		   then
		       SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		   else
		       SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		   fi 
		   call_get_log_result=1 
                   SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                   if [ $OFFLINE -eq 0 ]
                   then
                       SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
                   else
                       SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
                   fi
		   SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
		   case `uname -s` in 
		   SunOS)
			os_patch_count=0
			os_patch_base=0
			os_patch_rls=0
			os_patch_rls_actual=0 
			os_patch_base=$(echo $PARAM_PATH|cut -d- -f1)
			os_patch_rls=$(echo $PARAM_PATH|cut -d- -f2)
			#os_patch_count=$(grep -c $os_patch_base $SOURCEFIL)
			os_patch_count=$(cat $SOURCEFIL|cut -d: -f2|awk '{print $1}'|grep -c $os_patch_base)
			# read -p "os_patch_count=$os_patch_count"
			if [ $os_patch_count -ge 1 ]
			then 
			    if [ $i = $localnode ]
			    then
				os_patch_rls_actual=$(showrev -p |cut -d: -f2|awk '{print $1}'|grep ${os_patch_base}|cut -d- -f2)
			    else
				os_patch_rls_actual=$($SSHELL $i showrev -p |cut -d: -f2|awk '{print $1}'|grep ${os_patch_base}|cut -d- -f2)
			    fi
			    #read -p "os_patch_rls_actual=$os_patch_rls_actual"
			    if [ $os_patch_rls_actual -ge $os_patch_rls ]
			    then
				os_patch_status=1
			    else
				os_patch_status=2
			    fi
			else
			    os_patch_status=0
			fi 
			echo "${ROW}_${PARAM_PATH}_os_patch_status == $os_patch_status">>$OSSPOOLFIL
		   ;;
		   AIX|HP-UX)
			os_patch_count=0
			os_patch_count=$(grep $PARAM_PATH $SOURCEFIL|wc -l)
			if [ $os_patch_count -gt 0 ]
			then
			   os_patch_status=1
			else
			   os_patch_status=0
			fi     
			echo "${ROW}_${PARAM_PATH}_os_patch_status == $os_patch_status">>$OSSPOOLFIL
		   ;;
		   *)
		   ;;
		   esac #patch OS case ends here
		   echo "OS PATCH status variable are os_patch_count=$os_patch_count,os_patch_base=$os_patch_base,os_patch_rls=$os_patch_rls and os_patch_rls_actual=$os_patch_rls_actual" os_patch_status=$os_patch_status >>$LOGFIL
	       else # this else is for offline patch 
                   call_get_log_result=1
		   os_patch_status=$(grep "${ROW}_${PARAM_PATH}_os_patch_status" $OSSPOOLFIL|sed  -n 's/.*== //p')
	       fi
	       #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${os_patch_status}@$os_patch_rls_actual" >>$OSACTUAL; fi
           fi
          ;;
          ORACLE_PATCH)
           if [[ $HOME_PATH = "CRS" &&  ${crs_installed[$stack_counter]} -eq 0 ]] ||  [[ $HOME_PATH = "RDBMS" &&  ${rdbms_installed[$stack_counter]} -eq 0 ]] || [[ $HOME_PATH = "ASM" &&  ${asm_installed[$stack_counter]} -eq 0 ]] 
	   then
	       call_get_log_result=0
	   elif [[ $NEEDS_RUNNING = "CRS" &&  ${stack_crs_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "RDBMS" &&  ${stack_dbinst_up[$stack_counter]} -eq 0 ]] ||  [[ $NEEDS_RUNNING = "ASM" &&  ${stack_asm_up[$stack_counter]} -eq 0 ]] || [[ $NEEDS_RUNNING = "ACFS" &&  ${stack_acfs_up[$stack_counter]} -eq 0  ]]
	   then
	       call_get_log_result=0
           elif [[ $NEEDS_RUNNING = "ACFS" && $db_machine_compute -eq 1 ]] 
           then
               call_get_log_result=0
           elif [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
           then
               call_get_log_result=0
               echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL
           elif  [[  $component_match_count  -lt 1 ]]
           then
               echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
               call_get_log_result=0
	   else    
	       call_get_log_result=1 
               ORIG_PMSG=$PMSG
               ORIG_FMSG=$FMSG  
               if [[ $HOME_PATH = "CRS" || $HOME_PATH = "ASM" ]]
               then
                   if [ $op_mode -eq 0 ]
		   then
		       SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		   else
		       SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		   fi
                   if [ $OFFLINE -eq 0 ]
		   then
			SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/o_${SOURCEFIL}_${i}_report.out
		   else
			SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/o_${SOURCEFIL}_${i}_report.out
		   fi
                   SOURCEFIL_REPORT=$OUTPUTDIR/o_${SOURCEFIL}_${i}_report.out
		   SOURCEFIL=$OUTPUTDIR/o_${SOURCEFIL}_${i}.out
                   if [[ -e $SOURCEFIL && `ls -l $SOURCEFIL|awk '{print $5}'` -gt 1 ]]
                   then
                       PARAM_PATH=$(echo $PARAM_PATH|sed 's/,/ /g')
                       VAL=0
                       for each_oracle_patch in $PARAM_PATH
                       do
                          oracle_patch_count=$(grep -icw $each_oracle_patch $SOURCEFIL)
                          if [ $oracle_patch_count -ge 1 ]; then VAL=$oracle_patch_count;break;fi
                       done 
                       if [ $HOME_PATH = "CRS" ] ;then message4Home=$CRS;elif [ $HOME_PATH = "ASM" ]; then  message4Home=$ASM_HOME;fi
                       PMSG=$(echo $ORIG_PMSG $message4Home)
                       FMSG=$(echo $ORIG_FMSG $message4Home) 
                       if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
                       then
                           get_log_result
                           call_get_log_result=0
                       fi 
                   else 
			echo "skipping Oracle Patch $PARAM_NAME checking (checkid:-$CHECK_ID) because `basename $SOURCEFIL` not found" >>$SKIPFIL
			generate_exceptions_xml "skipping Oracle Patch $PARAM_NAME checking because `basename $SOURCEFIL` not found"
                        call_get_log_result=0
                   fi
               elif [ $HOME_PATH = "RDBMS" ]
               then
                   mb_db_counter_log=0
                   for mb_db_homes in ${mb_oracle_homes_distinct[@]}
                   do
                     skip_this_version=0
                     set_skip_this_version "$mb_db_homes"
                     if [ $skip_this_version -eq 1 ]
                     then #dont run
                          mb_db_counter=$(expr $mb_db_counter + 1)
                          echo "Skipping check($CHECK_ID) on version 7 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
                          continue
                     fi
                       mb_db_homes_without_slash=$(echo $mb_db_homes|sed 's/\///g')
                       mb_db_homes_without_slash=$(echo $mb_db_homes_without_slash|sed 's/\.//g') 
		       if [ $op_mode -eq 0 ]
		       then
			   SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		       else
			   SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		       fi	     
                       if [ $OFFLINE -eq 0 ]
		       then
			    SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}_report.out
		       else
			    SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}_report.out
		       fi
		       SOURCEFIL_REPORT=$OUTPUTDIR/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}_report.out
                       SOURCEFIL=$OUTPUTDIR/o_${SOURCEFIL}_${mb_db_homes_without_slash}_${i}.out
		       if [[ -e $SOURCEFIL && `ls -l $SOURCEFIL|awk '{print $5}'` -gt 1 ]]
		       then
                           PARAM_PATH=$(echo $PARAM_PATH|sed 's/,/ /g')
			   VAL=0
			   for each_oracle_patch in $PARAM_PATH
			   do
			      oracle_patch_count=$(grep -icw $each_oracle_patch $SOURCEFIL)
			      if [ $oracle_patch_count -ge 1 ]; then VAL=$oracle_patch_count;break;fi
			   done
			   PMSG=$(echo $ORIG_PMSG $mb_db_homes)
			   FMSG=$(echo $ORIG_FMSG $mb_db_homes) 
                           if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
			   then
			       get_log_result "inloop" "$mb_db_homes"
			       mb_db_counter_log=$(expr $mb_db_counter_log + 1)
			   fi
		       else 
			    echo "skipping Oracle Patch $PARAM_NAME checking (checkid:-$CHECK_ID) because `basename $SOURCEFIL` not found" >>$SKIPFIL
			    generate_exceptions_xml "skipping Oracle Patch $PARAM_NAME checking because `basename $SOURCEFIL` not found"
			    call_get_log_result=0
		       fi   
                   done  
                   call_get_log_result=0
               fi 
           fi
          ;;   
         OS_PACKAGE)
           #be available via an OS_COLLECT, so we'll check each node's output
           #OS PAckages are kind of a special case, so doing some trickery here
           #we first want to check to see if the package is installed
           #then if it is we want to check to see if the package version is
           #a known bad version
           #
           #we manipulate FMSG,PMSG,OP and COMP to get the desired effect
           #when get_log_result() is called, those don't come from the data file
           #as they do for other checks, or if they do we're over-riding them
         if [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
         then
             call_get_log_result=0
             echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL    
         #elif  [[ $components != "NONE" &&  $components != $check_components ]]
         #elif  [[ $components != "NONE" &&  $component_match_count  -lt 1 ]]
         elif  [[ $component_match_count  -lt 1 ]]
         then
             echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
             call_get_log_result=0
         else
             call_get_log_result=1
	     if [ $OFFLINE -eq "0" ]
	     then
	       #if running in SILENT mode then we don't want to do any of this
	       #we'll have all we need from the output of the OS command which 
	       #outputs the packages, eg., rpm -qa in linux
	       # HERE we are in NON SILENT mode
	       if [ $op_mode -eq 0 ]
	       then
		   SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	       else
		   SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	       fi
	       #each node could potentially have a different listing of packages
	       #so use the node specific listing to check
	       #RPM STATUS
	       # 0=exact version is installed
	       # 1=higher version of same package is installed
	       # 2=package is installed but version is lower than recommended
	       # 3=package not instaleld
	       #sed 's/|/-/g'
	       SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
               if [ $OFFLINE -eq 0 ]
               then
	           SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
               else
	           SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
               fi
	       SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
	       call_get_log_result=1 
	       rpm_arch=99
	       case `uname -s` in 
	       Linux)
		   rpm_match=$(grep -c $PARAM_PATH $SOURCEFIL)
		   unset rpm_arr1
		   unset rpm_arr2
		   unset rpm_name
		   unset rpm_status
		   func_rpm_status=0
		   ir_counter=0
		   how_many_name_r=1
		   how_many_no_r=0
		   if [ $rpm_match -eq 1 ]
		   then
		       rpm_status=0
		   else
                       #if [ -z "$IFS ]
                       #then
                       old_ifs=$IFS
                       #fi
		       IFS=$'|'
		       #read -p "package name =$PARAM_PATH"
		       for ir in $PARAM_PATH
		       do
			 rpm_arr1[$ir_counter]=$ir
			 if [ -z "$rpm_name" ]
			 then
			     rpm_name=${rpm_arr1[0]}
			 fi
			 ir_counter=$(expr $ir_counter + 1)
		       done
		       ir_counter=$(expr $ir_counter - 1)
		       if [ "$i" = "$localnode" ]
		       then
			   actual=$(rpm -q "$rpm_name" --queryformat "%{name}|%{version}|%{release}|%{arch}\n")
			   rpm_q_rstatus=$?
		       else
#set -xv
			   IFS=$old_ifs
			   sshrpm="rpm -q $rpm_name --queryformat \"%{name}|%{version}|%{release}|%{arch}\n\""
                           #OLD_SSHELL=$SSHELL
                           #SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
			   rpm_actual=$($SSHELL $i $sshrpm)
			   rpm_q_rstatus=$?
			   actual=$(echo $rpm_actual|sed 's/ /|/g')
                           #SSHELL=$OLD_SSHELL 
			   #read -p "ssh $i $sshrpm and actual is $actual"
			   IFS=$'|'
#set +xv
		       fi
		       #read -p "RPM name is $rpm_name and actual found on system is $actual rpm_q_rstatus=$rpm_q_rstatus"
		       if [ $rpm_q_rstatus -ne 0 ]
		       then
			   rpm_status=3
			   #echo "rpm $PARAM_PATH is not installed on sysetm"
		       else
			   no_of_rpms=$(echo $actual|wc -l)
			   #read -p "before 2$actual"
			   if [ $no_of_rpms -gt 1 ]
			   then
			       actual1=$actual
			       actual=$(echo $actual|grep ${rpm_arr1[$ir_counter]}|sed 's/ /|/g')
			       if [ -z "$actual" ] 
			       then
				   actual=$(echo $actual1|grep -v "x86_64"|sed 's/ /|/g') 
				   #read -p " after 2 $actual"
			       fi
			   fi
			   ar_counter=0
			   how_many_name_a=0
			   how_many_no_a=0
			   element_count=0
			   no_of_loops=0 
			   for arpm in $actual
			   do
			     rpm_arr2[$ar_counter]=$arpm
			     if [ -z "$rpm_name" ]
			     then
				 rpm_name=${rpm_arr2[0]}
			     fi
			     ar_counter=$(expr $ar_counter + 1)
			   done
			   for array_item in ${rpm_arr1[*]}
			   do
			     if [ $element_count -eq 1 -o $element_count -eq 2 ] && [ -n "$array_item" ]
			     then
				 no_of_loops=$(expr $no_of_loops + 1)
			     fi
			     if [ $element_count -eq 3 ] && [ "${rpm_arr1[3]}" != "${rpm_arr2[3]}" ]
			     then
				case "${rpm_arr1[3]}" in
				i386)
				    if [[ "${rpm_arr2[3]}" = "i486" ||  "${rpm_arr2[3]}" = "i586" ||  "${rpm_arr2[3]}" = "i686" ||  "${rpm_arr2[3]}" = "i886" ]]
				    then
				       rpm_arch=1
				    fi
				;;
				i486)
				    if [ "${rpm_arr2[3]}" = "i386" ]
				    then
					rpm_arch=0
					elif [[ "${rpm_arr2[3]}" = "i586" ||  "${rpm_arr2[3]}" = "i686" ||  "${rpm_arr2[3]}" = "i886" ]]
					then
					    rpm_arch=1
					fi
				;;
				i586)
				    if [[ "${rpm_arr2[3]}" = "i386" || "${rpm_arr2[3]}" = "i486"  ]]
				    then
					rpm_arch=0
				    elif [[ "${rpm_arr2[3]}" = "i686" ||  "${rpm_arr2[3]}" = "i886" ]]
				    then
					rpm_arch=1
				    fi  
				;;
				i686)
				    if [[ "${rpm_arr2[3]}" = "i386" || "${rpm_arr2[3]}" = "i486" || "${rpm_arr2[3]}" = "i586"  ]]
				    then
					rpm_arch=0
					elif [  "${rpm_arr2[3]}" = "i886" ] 
					then
					    rpm_arch=1
					 fi
				;;
				i886)
				    if [[ "${rpm_arr2[3]}" = "i386" || "${rpm_arr2[3]}" = "i486" || "${rpm_arr2[3]}" = "i586"  || "${rpm_arr2[3]}" = "i686" ]]
				    then
					rpm_arch=0 
				    fi
				;; 
				*)
				  rpm_status=3
				;; 
				esac    
			    #read -p "${rpm_arr1[3]} and ${rpm_arr2[3]} $rpm_status $actual $PARAM_PATH"
			     fi
			# read -p "element is $array_item"
			     element_count=$(expr $element_count + 1)
			   done
			   element_count=0
		      #no_of_loops=$(expr $how_many_name_r + 2)
			   if [ -z "$rpm_status" ]
			   then
			       while [ "$how_many_name_r" -le "$no_of_loops" ]
			       do
			 #echo "to compare ${rpm_arr1[$how_many_name_r]} and ${rpm_arr2[$how_many_name_r]} and func_rpm_status =$func_rpm_status"
				 if [ "$func_rpm_status" -eq 0 ]
				 then
				     compare_rpmversion "${rpm_arr1[$how_many_name_r]}" "${rpm_arr2[$how_many_name_r]}"
				     rpm_status=$func_rpm_status
				 fi
				 how_many_name_r=$(expr $how_many_name_r + 1)
			       done
			   fi
		       fi
                       IFS=$old_ifs
		   fi 
		   echo "${ROW}_${PARAM_PATH}_rpm_status == $rpm_status">>$OSSPOOLFIL
		   echo "${ROW}_${PARAM_PATH}_rpm_arch == $rpm_arch">>$OSSPOOLFIL
		   ;;
	       SunOS)
		   PARAM_PATH=$(echo $PARAM_PATH|cut -d '|' -f1)
		   rpm_match=$(grep -c "$PARAM_PATH" $SOURCEFIL)
		   if [ $rpm_match -eq 1 ]
		   then
		      rpm_status=0
		   else
		      if [ $i = $localnode ]
		      then
			  rpm_match=$(pkginfo -q $PARAM_PATH;echo $?)
		      else
			  sshrpm="pkginfo -q $PARAM_PATH;echo \$?"
			  rpm_match=$($SSHELL $i $sshrpm)
    #                      read -p "rpm_match=$rpm_match and sshrpm=$sshrpm"
		      fi
		      actual=$PARAM_PATH
		      if [ $rpm_match -eq 0 ]
		      then
			  rpm_status=1
		      else
			  rpm_status=3
		      fi
		   fi
		   echo "${ROW}_${PARAM_PATH}_rpm_status == $rpm_status">>$OSSPOOLFIL
		   echo "${ROW}_${PARAM_PATH}_rpm_arch == $rpm_arch">>$OSSPOOLFIL
	       ;;
	       AIX)
		   rpm_match=$(grep -c $PARAM_PATH $SOURCEFIL)
		   unset rpm_arr1
		   unset rpm_arr2
		   unset rpm_name
		   unset rpm_status
		   func_rpm_status=0
		   ir_counter=0
		   how_many_name_r=1
		   how_many_no_r=0
		   if [ $rpm_match -eq 1 ]
		   then
		       rpm_status=0
		   else
                      if [ -n "$IFS" ]
                      then
                          old_ifs=$IFS
                      fi
                      IFS=$'|'
		      #read -p "package name =$PARAM_PATH"
		      for ir in $PARAM_PATH
		      do
			rpm_arr1[$ir_counter]=$ir
			if [ -z "$rpm_name" ]
			then
			    rpm_name=${rpm_arr1[0]}
			fi
			ir_counter=$(expr $ir_counter + 1)
		      done
		      ir_counter=$(expr $ir_counter - 1)
		      if [ "$i" = "$localnode" ]
		      then
			  actual=$(lslpp -lcq "$rpm_name" 2> /dev/null|head -1|awk 'BEGIN { FS = ":" };{print $2"|" $3}')
		      else
                          sshrpm="lslpp -lcq $rpm_name 2>/dev/null|head -1"  
                          OLD_SSHELL=$SSHELL
                          SSHELL="/usr/bin/ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no"
                          actual=$($SSHELL $i $sshrpm|sed 's/ /|/g')
                          actual=$(echo $actual|awk 'BEGIN { FS = ":" };{print $2"|" $3}')
                          SSHELL=$OLD_SSHELL
			  #actual=$($SSHELL $i lslpp -lcq "$rpm_name" 2>/dev/null|head -1|awk 'BEGIN { FS = ":" };{print $2"|" $3}')
		      fi
		      if [[ -z "$actual" || $actual = "|"  ]]
		      then
			 rpm_status=3
			  #echo "rpm $PARAM_PATH is not installed on sysetm"
		      else
			  #read -p "actual is $actual"
			  ar_counter=0
			  how_many_name_a=0
			  how_many_no_a=0
			  element_count=0
			  no_of_loops=0
			  for arpm in $actual
			  do
			     rpm_arr2[$ar_counter]=$arpm
			    if [ -z "$rpm_name" ]
			    then
				rpm_name=${rpm_arr2[0]}
			    fi
			    ar_counter=$(expr $ar_counter + 1)
			  done
			  if [ -z "$rpm_status" ]
			  then
			      #echo "to compare ${rpm_arr1[1]} and ${rpm_arr2[1]} and func_rpm_status =$func_rpm_status"
			      if [ "$func_rpm_status" -eq 0 ]
			      then
				  compare_rpmversion "${rpm_arr1[1]}" "${rpm_arr2[1]}"
				  rpm_status=$func_rpm_status
			      fi
			 fi
		      fi
		   fi
                   unset IFS
                   IFS=$' \t\n'  
		   echo "${ROW}_${PARAM_PATH}_rpm_status == $rpm_status">>$OSSPOOLFIL
		   echo "${ROW}_${PARAM_PATH}_rpm_arch == $rpm_arch">>$OSSPOOLFIL
	       ;;
	       esac #packages OS case ends here
	       #if [ $ISBRANCH -eq 0 ]; then echo "${CHECK_ID}|${rpm_status}@$actual" >>$OSACTUAL;fi
	     else # package offline else so above is for online and below is for offline 
	       if [ $op_mode -eq 0 ]
	       then
		   SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	       else
		   SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	       fi
	       #each node could potentially have a different listing of packages
	       #so use the node specific listing to check
	       #RPM STATUS
	       # 0=exact version is installed
	       # 1=higher version of same package is installed
	       # 2=package is installed but version is lower than recommended
	       # 3=package not instaleld
	       #sed 's/|/-/g'
	       SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
               if [ $OFFLINE -eq 0 ]
               then
	           SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i".out"
               else
	           SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out"
               fi
	       #write the code here to read back from os spool file
		#read -p "PARAM_PATH=$PARAM_PATH"
		call_get_log_result=1
		pkgtype=$(echo $PARAM_PATH|cut -d '|' -f2)
		pkgarch=$(echo $PARAM_PATH|cut -d '|' -f4)
		
		if [[ -z "$pkgtype" && "$pkgarch" != "ppc_64" ]]
		then 
		     
		     PARAM_PATH=$(echo $PARAM_PATH|cut -d '|' -f1)
		fi
		rpm_status=$(grep "${ROW}_${PARAM_PATH}_rpm_status" $OSSPOOLFIL|sed  -n 's/.*== //p')
		rpm_arch=$(grep "${ROW}_${PARAM_PATH}_rpm_arch" $OSSPOOLFIL|sed  -n 's/.*== //p')
		#read -p "RPM status $rpm_status and PARAM_PATH=$PARAM_PATH pkgarch=$pkgarch"
	     fi
         fi
         ;;
      esac # this end case is for SQL|SQL_PARAM|SQL_COLLECT|OS_PARAM|OS_PACKAGE|OS_PATCH
      case $COMTYPE in
      OS_PARAM)
        if [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
        then
            call_get_log_result=0
            echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL  
        elif  [[ $component_match_count  -lt 1 ]]
        then 
            echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL 
            call_get_log_result=0
        else
            call_get_log_result=1
	    case $FIELDPOS in
	      1) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
	       ;;
	      2) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
	       ;;
	      3) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
	       ;;
	      4) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
	       ;;
	      5) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
	       ;;
	      99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
	       ;;
	    esac
	    #if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
        fi
#commented below to execute sql out check
         ;;
    esac
       #-----------------DEBUGGING---------------
#       echo "----------------------------------------------"
#       echo "COMMAND = $COM"
#       echo "RESULT = $VAL"
       #--------------END DEBUGGING-------------
        #if [ -n "$LEVEL" ]
        #then
        #    get_log_result
	if [[ -n "$LEVEL" && -n $call_get_log_result && $call_get_log_result -eq 1 ]]; then  get_log_result; fi;
        #fi
     ;;
     OS_OUT_CHECK)
        if [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
        then
            echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL   
            call_get_log_result=0
        elif [[ $execute_once -eq 1 && $RAT_RUNMODE_INTERNAL = "slave" ]]
        then
            call_get_log_result=0    
            echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because execute_once is true">>$LOGFIL   
        elif [[ $execute_once -eq 1 && "$i" != "$localnode" ]]
        then
            call_get_log_result=0    
            echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because execute_once is true">>$LOGFIL   
        elif  [[ $component_match_count  -lt 1 ]]
        then
            echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
            call_get_log_result=0
        elif [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ $i != $localnode ]]
        then
            call_get_log_result=0
        else
            if [ $OFFLINE -eq 0 ]; then switch_name_file=${RTEMPDIR}/o_ibswitches.out;else switch_name_file=$OUTPUTDIR/o_ibswitches.out;fi
            #read -p "before switch os_out_check"
            if [ $op_mode -eq 0 ]
            then
	        audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
            else
	        audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
            fi
	    audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
            if [[ $NEEDS_RUNNING = "SPINE_SWITCH" || $NEEDS_RUNNING = "SWITCH" ]] && [[ -e $switch_name_file && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" &&  -n "$ibswitch_password_status" && $ibswitch_password_status -ne 3 ]]
            then
                #write_switchname_in_report=1
                if [ $write_switchname_in_report -eq 1 ]
                then
                    write_switchname_in_report=0
                    echo "============================================================="|tee -a $IBSREPFIL_PASS|tee -a $IBSREPFIL_FAIL|tee -a $IBREPFIL_PASS|tee -a $IBREPFIL_FAIL >/dev/null
                    echo "                    Infiniband switch checks                 "|tee -a $IBSREPFIL_PASS|tee -a $IBSREPFIL_FAIL|tee -a $IBREPFIL_PASS|tee -a $IBREPFIL_FAIL >/dev/null
                    echo "============================================================="|tee -a $IBSREPFIL_PASS|tee -a $IBSREPFIL_FAIL|tee -a $IBREPFIL_PASS|tee -a $IBREPFIL_FAIL >/dev/null
                fi
                ORIG_PMSG=$PMSG
                ORIG_FMSG=$FMSG
                mb_db_counter=0
                mb_db_counter_log=0
                for switchname in `cat $switch_name_file|cut -d. -f1`
                do
                    if [ -e $OUTPUTDIR/s_getnm2type_${switchname}.out ]
                    then 
                        switch_type=$(cat $OUTPUTDIR/s_getnm2type_${switchname}.out)
                        if [ "$switch_type" = "36P" ]; then switch_type_running=SPINE_SWITCH;else switch_type_running=SWITCH;fi
                    else
                        switch_type_running=SWITCH 
                    fi
                 #Added this branch to execute checks based on the switch type. check is not execute and not put in skipped if switch type does not match needs_running   
                    skip_this_target=0
                    set_skip_this_target $switchname
                    if [[ "$NEEDS_RUNNING" = "$switch_type_running" && $skip_this_target -eq "0" ]]
                    then  
			call_get_log_result=1
			COM=`echo "OS OUT CHECK $PARAM_PATH  $OP  $COMP"`
			if [ $op_mode -eq 0 ]
			then
			    SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
			else
			    SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
			fi
			if [ -e $OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname"_"report".out" ]
			then
			    SOURCEFIL_REPORT=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname"_"report".out"
			else
			    SOURCEFIL_REPORT=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname".out"
			fi
			if [ $OFFLINE -eq 0 ]
			then
			    if [ -e $OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname"_"report".out" ]
			    then
				SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"s_"$SOURCEFIL"_"$switchname"_"report".out"
			    else
				SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"s_"$SOURCEFIL"_"$switchname".out"
			    fi
			else
			    if [ -e $OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname"_"report".out" ]
			    then
				SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname"_"report".out"
			    else
				SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname".out"
			    fi
			fi
			SOURCEFIL=$OUTPUTDIR/"s_"$SOURCEFIL"_"$switchname".out"
			if [ $op_mode -eq 0 ]
			then
			    FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
			else
			    FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
			fi
			if [ -f $SOURCEFIL ]
			then
			    case $FIELDPOS in
			     1) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
			      ;;
			     2) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
			      ;;
			     3) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
			      ;;
			     4) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
			      ;;
			     5) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
			     ;;
			     99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
			     ;;
			    esac
			else
			    echo "skipping $audit_check_name (checkid:- $CHECK_ID) on $switchname because `basename $SOURCEFIL` not found" >>$SKIPFIL;
			    generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') on $switchname because `basename $SOURCEFIL` not found" 
			    #read -p "stop here to check skip file"
			fi
			PMSG=$(echo $ORIG_PMSG on infiniband switch ${switchname})
			FMSG=$(echo $ORIG_FMSG on infiniband switch ${switchname})
			#PMSG=$(echo "$PMSG for $switchname")
			#FMSG=$(echo "$FMSG for $switchname")
			#if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
			if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
			then
			    get_log_result "inloop" "switch"
			    mb_db_counter_log=$(expr $mb_db_counter_log + 1)
			fi
                    else
                      if [[ $skip_this_target -eq "1" ]] ; then
                        echo "skip_this_target=1 for $audit_check_name on $switchname so skipping">>$LOGFIL
                      else
                        echo "NEEDS_RUNNING($NEEDS_RUNNING) does not match to switch_type_running($switch_type_running) for $audit_check_name on $switchname so skipping">>$LOGFIL
                      fi
                    fi
                    mb_db_counter=$(expr $mb_db_counter + 1) # needed for opstat
                done
                mb_db_counter=0
            #read -p "after switch os_out_check"
            elif [[ $NEEDS_RUNNING = "STORAGE_CELL" && $i = $localnode && $RAT_RUNMODE_INTERNAL = "master" && -e $CELLIP &&  -n "$cell_password_status" && $cell_password_status -ne 3 && $current_exadata_version -lt $check_exadata_version  ]]
            then
                #write_cellname_in_report=1
                if [ $write_cellname_in_report -eq 1 ]
                then
                    write_cellname_in_report=0
                    echo "============================================================="|tee -a $CELLSREPFIL_PASS|tee -a $CELLSREPFIL_FAIL|tee -a $CELLREPFIL_PASS|tee -a $CELLREPFIL_FAIL >/dev/null
                    echo "                    Storage server checks                    "|tee -a $CELLSREPFIL_PASS|tee -a $CELLSREPFIL_FAIL|tee -a $CELLREPFIL_PASS|tee -a $CELLREPFIL_FAIL >/dev/null
                    echo "============================================================="|tee -a $CELLSREPFIL_PASS|tee -a $CELLSREPFIL_FAIL|tee -a $CELLREPFIL_PASS|tee -a $CELLREPFIL_FAIL >/dev/null
                fi
                #read -p "stop to see why its writing"
                #ORIG_PMSG=$PMSG
                #ORIG_FMSG=$FMSG
		call_get_log_result=0
                cell_count=0
                cell_count_cwc=0
                amb_temp_total=0 
                outcheck_cell_counter=0 
                amb_temp_cell_count=0
                unset a_cellname
	        unset a_cellCheckStatus
                for cellname in `cat $CELLIP|cut -d= -f2|sed 's/"//g'`
                do 
                    check_status=0
                    #if [ $OFFLINE -eq 0 ]
                    #then
                    #    cellname=$(cat /etc/hosts|grep "$cellname"|awk '{print $NF}'|cut -d'-' -f1)
                    #else
                        cellname=$(cat $CELLDIR/cells.out|grep "$cellname"|awk '{print $NF}')
                    #fi
                    mixed_hardware_execute_check=1
                    if [ $mixed_hardware -gt 1 ]
                    then
                        mixed_hardware_cell_type_v2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname}_report.out| grep -wci "SUN FIRE X4275")
                        mixed_hardware_cell_type_x2_2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname}_report.out| grep -wci "SUN FIRE X4[1-2]70 M2")
                        mixed_hardware_cell_type_x3_2=$(cat $CELLDIR/c_cbc_CellMakeModel_${cellname}_report.out| grep -wci "SUN FIRE X4[1-2]70 M3")

                        if [[ $mixed_hardware_cell_type_v2 -eq 1 && `echo $check_components|grep -icw EXADATA` -eq 0 ]]
                        then
                            mixed_hardware_execute_check=0
                        fi 
                        if [[ $mixed_hardware_cell_type_x2_2 -eq 1 && `echo $check_components|grep -icw X2-2` -eq 0 ]]
                        then
                            mixed_hardware_execute_check=0
                        fi 
                        if [[ $mixed_hardware_cell_type_x3_2 -eq 1 && `echo $check_components|grep -icw X3-2` -eq 0 ]]
                        then
                            mixed_hardware_execute_check=0
                        fi 
                        components=$old_components
                    fi 
                    if [ $mixed_hardware_execute_check -eq 1 ]
                    then 
			COM=`echo "OS OUT CHECK $PARAM_PATH  $OP  $COMP"`
			if [ $op_mode -eq 0 ]
			then
			    SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
			else
			    SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
			fi
			cell_outcheck_type=$(echo $SOURCEFIL|cut -d_ -f1)
			SOURCEFIL_REPORT_CELL=$CELLDIR/"c_"$SOURCEFIL"_"$cellname"_report.out"
			if [[ -n "$cell_outcheck_type" && $cell_outcheck_type = "cbc" ]]
			then 
			    SOURCEFIL_TRIM=$(echo $SOURCEFIL|sed 's/cbc_//g')
			elif [[ -n "$cell_outcheck_type" && $cell_outcheck_type = "cwc" ]]
			then
			   SOURCEFIL_TRIM=$(echo $SOURCEFIL|sed 's/cwc_//g')
			fi
			SOURCEFIL_REPORT=$OUTPUTDIR/"c_"$SOURCEFIL_TRIM"_report.out"
			if [ $OFFLINE -eq 0 ]
			then
			    SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"c_"$SOURCEFIL_TRIM"_report.out"
			else
			    SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"c_"$SOURCEFIL_TRIM"_report.out"
			fi
			SOURCEFIL=$CELLDIR/"c_"$SOURCEFIL"_"$cellname".out"
			if [[ -e $SOURCEFIL_REPORT_CELL && $OFFLINE -eq 0 && -n "$SOURCEFIL_TRIM" && $ISBRANCH -eq 0 ]]
			then
			   echo -e "TO REVIEW COLLECTED DATA FROM $(echo $cellname|tr "[a-z]" "[A-Z]") FOR $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >> $SOURCEFIL_REPORT
			   cat $SOURCEFIL_REPORT_CELL >>$SOURCEFIL_REPORT
			   rm -f $SOURCEFIL_REPORT_CELL >/dev/null 2>&1
			   echo -e "\n\n\n" >>$SOURCEFIL_REPORT
			fi
			if [ $op_mode -eq 0 ]
			then
			    FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
			else
			    FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
			fi
			if [[ -f $SOURCEFIL && 1 -eq 2 ]]
			then
			    case $FIELDPOS in
			     1) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
			      ;;
			     2) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
			      ;;
			     3) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
			      ;;
			     4) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
			      ;;
			     5) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
			     ;;
			     99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
			     ;;
			    esac
			fi
			if [ -e $SOURCEFIL ]
			then
			    VAL=$(cat $SOURCEFIL|head -1|awk '{print $1}')
			    call_get_log_result=1
			else
			    VAL=$VAL1
			    echo "skipping $audit_check_name (checkid:-$CHECK_ID) on $cellname because `basename $SOURCEFIL` not found" >>$SKIPFIL;
			    generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') on $cellname because `basename $SOURCEFIL` not found" 
			fi
			if [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cwc" ]]
			then
			    if [ $cell_count_cwc -eq 0 ]
			    then
			       VAL1=$VAL
			       CELL_VAL=1 
			    else
			       VAL2=$VAL
			       if [ $RAT_DEBUG -eq 1 ]
			       then
				   if [[ -n "$VAL1" && -n "$VAL2" ]] && [ "$VAL1" = "$VAL2" ]
				   then 
				       CELL_VAL=1
				   else
				       CELL_VAL=0
				      cell_count=$(expr $cell_count + 1 )
				   fi 
			       else
				   if [[ -n "$VAL1" && -n "$VAL2" ]] && [ "$VAL1" = "$VAL2" ]  2>>$ERRFIL
				   then 
				       CELL_VAL=1
				   else
				       CELL_VAL=0
				      cell_count=$(expr $cell_count + 1 )
				   fi
			       fi  
			    fi  
			elif [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cbc"  && "$CHECK_ID" != "A4C28178C200A9CBE040E50A1EC00952" ]]
			then
			    VAL1=$VAL 
			    if [ $RAT_DEBUG -eq 1 ]
			    then
			       if [ "$VAL1" "$OP" "$COMP" ]
			       then
				  CELL_VAL=1 
			       else
				  CELL_VAL=0 
				  cell_count=$(expr $cell_count + 1 ) 
			       fi
			    else
			       if [ "$VAL1" "$OP" "$COMP" ]  2>>$ERRFIL
			       then
				  CELL_VAL=1 
			       else
				  CELL_VAL=0 
				  cell_count=$(expr $cell_count + 1 ) 
			       fi
			    fi   
			elif [[ -e $SOURCEFIL && "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952" && `echo $cellname|egrep -ic '01$|02$|03$'` -gt 0 && $outcheck_cell_counter -lt 4 ]] 
			then
			    amb_temp_total=$(expr $amb_temp_total + $VAL )  
			    amb_temp_cell_count=$(expr $amb_temp_cell_count + 1 )
			fi    
			#if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
			if [ -e $SOURCEFIL ];then a_cellname[$cell_count_cwc]=$cellname;fi
			if [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cwc" ]]
			then
			    if [ $CELL_VAL -eq 1 ]; then a_cellCheckStatus[$cell_count_cwc]=PASS;else a_cellCheckStatus[$cell_count_cwc]=FAIL;fi
			elif [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cbc" ]]
			then
			    if [ $CELL_VAL -eq 1 ]; then a_cellCheckStatus[$cell_count_cwc]=PASS;else a_cellCheckStatus[$cell_count_cwc]=FAIL;fi
			fi
			if [ -e $SOURCEFIL ];then cell_count_cwc=$(expr $cell_count_cwc + 1);fi
			outcheck_cell_counter=$(expr $outcheck_cell_counter + 1)
		    #   read -p "stop here to check"
			else
			    echo "$audit_check_name did not execute on $cellname because $old_components does not match with $CELLDIR/c_cbc_CellMakeModel_${cellname}_report.out">>$LOGFIL
			fi
                done
                outcheck_cell_counter=0   
                #if [[ $SOURCEFIL && "$cell_outcheck_type" = "cwc" ]]
                if [[  "$cell_outcheck_type" = "cwc" ]]
                then
                    if [[ $cell_count -eq 0 && $CELL_VAL -eq 1 ]]; then VAL=$COMP;elif [[ $cell_count -gt 0 ]];then VAL="0123456789XYZ";fi
                #elif [[ -e $SOURCEFIL && "$cell_outcheck_type" = "cbc" ]]
                elif [[ "$cell_outcheck_type" = "cbc"  && "$CHECK_ID" != "A4C28178C200A9CBE040E50A1EC00952" ]]
                then
                    if [[ $cell_count -eq 0 && $CELL_VAL -eq 1 ]]; then VAL=$VAL1;elif [[ $cell_count -gt 0 ]];then VAL="0123456789XYZ";fi
                elif [ "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952"  ] 
                then
                      if [[ -n "$amb_temp_total"  && $amb_temp_total -gt 0 ]]
                      then
                          amb_temp_avg=$(echo "scale=0;$amb_temp_total / $amb_temp_cell_count"|bc)
                          echo "amb_temp_total=$amb_temp_total and amb_temp_avg=$amb_temp_avg amb_temp_cell_count = $amb_temp_cell_count">>$LOGFIL
                          if [[ $amb_temp_avg -lt 5 || $amb_temp_avg -gt 32 ]]; then VAL=1;else VAL=0;fi
                      else
                          echo "skipping $audit_check_name (checkid:-$CHECK_ID) because this cluster does not access the first three storage servers" >>$SKIPFIL
                          generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because this cluster does not access the first three storage servers" 
                          call_get_log_result=0
                      fi
                fi
                #if [ "$CHECK_ID" = "A4C28178C200A9CBE040E50A1EC00952" ]
                #then
                #read -p "stop here to check again"
                #fi
		#if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
		if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL"  ]]
		then
		    get_log_result
	        fi
                #read -p "after switch os_out_check"
            elif [[ -z "$NEEDS_RUNNING" || $NEEDS_RUNNING = "UNSPECIFIED" ]] && [ $rootYesNoint -ne 3 ] 
            then
		call_get_log_result=1
		COM=`echo "OS OUT CHECK $PARAM_PATH  $OP  $COMP"`
		if [ $op_mode -eq 0 ]
		then
		    SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		else
		    SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
		fi
                SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_report_"$i".out"
                if [ ! -e $SOURCEFIL_REPORT ]; then SOURCEFIL_REPORT=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i"_report.out";fi
                if [ $OFFLINE -eq 0 ]
                then
                    SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_report_"$i".out"
                    if [ ! -e $SOURCEFIL_REPORT_NEW ]; then SOURCEFIL_REPORT_NEW=$OUTPUTDIR_NEW/"o_"$SOURCEFIL"_"$i"_report.out";fi
                else
                    SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_report_"$i".out"
                    if [ ! -e $SOURCEFIL_REPORT_NEW ]; then SOURCEFIL_REPORT_NEW=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i"_report.out";fi
                fi
		SOURCEFIL=$OUTPUTDIR/"o_"$SOURCEFIL"_"$i".out" 
		if [ $op_mode -eq 0 ]
		then
		    FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		else
		    FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
		fi
		if [[ -f $SOURCEFIL && `ls -l $SOURCEFIL|awk '{print $5}'` -gt 1 ]]
		then
		    case $FIELDPOS in
		     1) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
		      ;;
		     2) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
		      ;;
		     3) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
		      ;;
		     4) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
		      ;;
		     5) VAL=`grep $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
		     ;;
		     99) VAL=`grep $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
		     ;;
		    esac
                else
                        #if [[ "$NEEDS_RUNNING" != "SWITCH" || "$NEEDS_RUNNING" != "STORAGE_CELL" ]]
                        #then
                            echo "skipping $audit_check_name(checkid:-$CHECK_ID) because `basename $SOURCEFIL` not found" >>$SKIPFIL
                            generate_exceptions_xml "skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because `basename $SOURCEFIL` not found"
                            call_get_log_result=0 
                       # fi
		fi
		#if [[ $ISBRANCH -eq 0  && $OFFLINE -eq 0 ]]; then echo "${CHECK_ID}|${VAL}" >>$OSACTUAL; fi
		if [[ -n $call_get_log_result && $call_get_log_result -eq 1 && -n "$LEVEL" && -f $SOURCEFIL ]]
		then
		    get_log_result
		fi
            fi
        fi
        #if [ $NEEDS_RUNNING = "STORAGE_CELL" ]; then read -p "stop";fi   
     ;;
     SQL_OUT_CHECK)
       if [[ -e $EXCLUDEFIL && `grep -ic $CHECK_ID $EXCLUDEFIL` -ge 1 ]]
       then
           call_get_log_result=0
           echo "Skipping $audit_check_name (CHECK ID $CHECK_ID) because its in exclude file $EXCLUDEFIL">>$LOGFIL
           generate_exceptions_xml "Skipping $(echo $audit_check_name|sed 's/\[DBMV2]//g') because its in exclude file $EXCLUDEFIL"
       elif  [[ $component_match_count  -lt 1 ]]
       then
           echo "Check component($check_components) and system component($components) dont match($component_match_count) for check_id =$CHECK_ID">>$LOGFIL
           call_get_log_result=0
       else
           mb_db_counter=0
           call_get_log_result=1
	   COM=`echo "SQL OUT CHECK $PARAM_PATH  $OP  $COMP"`
	   if [ $op_mode -eq 0 ]
	   then
	       SOURCEFIL=`grep _$ROW\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	   else
	       SOURCEFIL=`grep _$CHECK_ID\-SOURCE_FILE $REFFIL |awk {'print $2'}`
	   fi
	   #echo "PARAM_PATH=$PARAM_PATH and SOURCEFIL=$SOURCEFIL"
           ORIG_PMSG=$PMSG
           ORIG_FMSG=$FMSG
           for db_name_to_check in "${mb_db_names[@]}"
           do
             skip_this_version=0
             set_skip_this_version "-"
             if [$skip_this_version -eq 1 ]
             then
               mb_db_counter=$(expr $mb_db_counter + 1)
               echo "Skipping check($CHECK_ID) on version 8 db_version=$current_version versions_to_run=$versions_to_run" >> $LOGFIL
               continue
             fi
               DBACTUAL=$OUTPUTDIR/d_actual_${db_name_to_check}.out
               PMSG=$(echo $ORIG_PMSG for ${db_name_to_check})
               FMSG=$(echo $ORIG_FMSG for ${db_name_to_check})
	       if [ $SOURCEFIL = "check" ]
	       then
		    SOURCEFIL=$OUTPUTDIR/"d_check_${db_name_to_check}.out"
	       else
		   SOURCEFIL=$OUTPUTDIR/"d_"$SOURCEFIL"_"${db_name_to_check}".out"
	       fi 
	       if [ $op_mode -eq 0 ] 
	       then
		   FIELDPOS=`grep _$ROW\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
	       else
		   FIELDPOS=`grep _$CHECK_ID\-FIELD_POSITION $REFFIL |awk {'print $2'}`   
	       fi
	       #NEEDS_RUNNING="RDBMS"
	       if [ -n "$LEVEL" ] && [ ${stack_asm_up[$stack_counter]} -eq 1 -a ${stack_db_status[$mb_db_counter]} -ne 0 ]
	       then
		  case $FIELDPOS in
		     1) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $1'}`
		      ;;
		     2) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $2'}`
		      ;;
		     3) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $3'}`
		      ;;
		     4) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $4'}`
		      ;;
		     5) VAL=`grep -w $PARAM_PATH $SOURCEFIL |awk {'print $5'}`
		      ;;
		     99) VAL=`grep -w $PARAM_PATH $SOURCEFIL |sed s/$PARAM_PATH" = "//g |sed s/$PARAM_PATH" "//g|sed 's/ //g'`
		      ;;
		   esac
		   if [ $ISBRANCH -eq 0 ]
		   then
		       echo "$CHECK_ID|$VAL">>$DBACTUAL
		   fi
		   #read -p "New SOURCEFIL=$SOURCEFIL"
                  if [ $mb_db_counter -gt 0 ];then write_report_on_fail=0;fi
		  if [[ -n $call_get_log_result && $call_get_log_result -eq 1 ]]; then  get_log_result; fi;
	       fi
	       mb_db_counter=$(expr $mb_db_counter + 1)
           done
           mb_db_counter=0
           write_report_on_fail=1
       fi
     ;;
     *)
        if [ -n "$LEVEL" ]
        then
            echo "INVALID COMMAND TYPE - $COMTYPE"
        fi
     ;;
     esac # this end case is for rest of the commands which is not included in above all
     #echo "grep _$ROW\-$COMTYPE\_COMMAND $REFFIL"# |sed -n 's\/.*$COMTYPE_COMMAND \/\/p'"
     
#---------------DEBUGGING---------------------    

#     if [ -n "$LEVEL" ]
#     then
#       echo ""
#       echo "ROW = $ROW"
#       echo "TYPE = $COMTYPE"
#       echo "PARAM_PATH = $PARAM_PATH"
#       echo "OPERATOR = $OP"
#       echo "COMPARE_VALUE = $COMP"
#       echo "PASS_MSG = $PMSG"
#       echo "FAIL_MSG = $FMSG"
#       echo "IS_BRANCH = $ISBRANCH"
#       echo "LEVEL = $LEVEL"
#       echo "CURRENT LEVEL = $CUR_LEVEL"
#       echo "SF = $SF"
#       echo "CAT = $CAT"
#       echo "SUBCAT = $SUBCAT"
#       echo "----------------------------------------------"
#       echo ""
#     fi
#
#-------------END DEBUGGING--------------------

     # Incase of db related checks, check if run in a loop, the OPSTAT is from last entry in loop
     # To fix that m_opstat array is created
     passed_hosts=$(echo "${m_opstat[$CUR_LEVEL]}" | sed 's/,failedontarget//g' | sed 's/failedontarget//g')
     if [[ -n "$passed_hosts" && $ISBRANCH -eq "1" ]]
     then # Succeeded in atleast one loop
       OPSTAT=1
     fi

     #this code manages traversing down the command hierarchy

     if [[ -z "$COMTYPE"  &&  -z "$LEVEL"  &&  "$L2" -eq 0 ]]
     then
      #this means there were no more "root" commands
      #we've reached the end of the hierarchy
      ROW=
     else
	 if [[ $LEVEL -eq 1  &&  $ISBRANCH -eq 0 ]]
	 then
	   #this is a "root" command and no branching required
	   #we've landed on a "non-branching root" command, the simplest case
	   #increment the level one counter and re-initailze all the others
	   #sets us up to look for the NEXT root command, whether branching or not
	   CUR_LEVEL=1
	   L1=$(($L1+1))
	   L2=0;L3=0;L4=0;L5=0;L6=0;L7=0;L8=0;L9=0;L10=0
	 elif [ $ISBRANCH -eq 0 ]
	 then
	   #the level is implicitly > 1 so we're executing a step at some level
	   #we had to have gotten here as the result of a successful branch
	   #need to determine if there are aby other commands at this level
	   #we shoudl be on CUR_LEVEL.  CUR_LEVEL cannot be = 1
	   case $CUR_LEVEL in
	   2) L2=$(($L2+1)) ;;
	   3) L3=$(($L3+1)) ;;
	   4) L4=$(($L4+1)) ;;
	   5) L5=$(($L5+1)) ;;
	   6) L6=$(($L6+1)) ;;
	   7) L7=$(($L7+1)) ;;
	   8) L8=$(($L8+1)) ;;
	   9) L9=$(($L9+1)) ;;
	  10) L10=$(($L10+1)) ;;
	   *) echo "ONLY 10 LEVELS OF BRANCHING ARE SUPPORTED [1 - $LEVEL,$CUR_LEVEL]" ;;
	   esac
	#   echo "L2 = $L2,  ROW = $L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10,  CUR_LEVEL = $CUR_LEVEL"
	 elif [[ $ISBRANCH -eq 1  &&  $OPSTAT -eq 1 ]]
	 then
	   #we're executing a branch at some level, need to take into account the
	   #result , success or failure of the branch

	  #-----------------DEBUGGING--------------------
   #       echo "BRANCH SUCCESS - $ROW"
	  #----------------END DEBUGGING----------------
	  
	  #it the branch succeeds then we need to go a level deeper
	  # to look for steps and or other branches
	  #there should be steps if the data was entered correctly

	  case $LEVEL in
	  1) L2=$(($L2+1)) CUR_LEVEL=2 ;;
	  2) L3=$(($L3+1)) CUR_LEVEL=3 ;;
	  3) L4=$(($L4+1)) CUR_LEVEL=4 ;;
	  4) L5=$(($L5+1)) CUR_LEVEL=5 ;;
	  5) L6=$(($L6+1)) CUR_LEVEL=6 ;;
	  6) L7=$(($L7+1)) CUR_LEVEL=7 ;;
	  7) L8=$(($L8+1)) CUR_LEVEL=8 ;;
	  8) L9=$(($L9+1)) CUR_LEVEL=9 ;;
	  9) L10=$(($L10+1)) CUR_LEVEL=10 ;;
	  *) echo "ONLY 10 LEVELS OF BRANCHING ARE SUPPORTED [2 - $LEVEL,$CUR_LEVEL]" ;;
	  esac

	 elif [[ $ISBRANCH -eq 1  &&  $OPSTAT -eq 0 ]]
	 then

	   #this could be a branch at any level (1-10) that failed
	   #in that case we do not want to pursue any steps or branches
	   #in its hierarchy.  we need to go back up one level to see
	   #if there are any other steps or branches, except if the failing
	   #bracn was already at level 1
	   #when a branch fails we need to stay at the same level because
	   #there could be other branches or steps at the same level as the
	   #failed branch so we just need to increment the counter for the
	   #current level as with the ISBRANCH=0 case

	 #-----------------DEBUGGING--------------------
   #       echo "BRANCH FAILURE - $ROW"
	  #----------------END DEBUGGING----------------
     
	   case $CUR_LEVEL in
	   1) L1=$(($L1+1)) ;;
	   2) L2=$(($L2+1)) ;;
	   3) L3=$(($L3+1)) ;;
	   4) L4=$(($L4+1)) ;;
	   5) L5=$(($L5+1)) ;;
	   6) L6=$(($L6+1)) ;;
	   7) L7=$(($L7+1)) ;;
	   8) L8=$(($L8+1)) ;;
	   9) L9=$(($L9+1)) ;;
	  10) L10=$(($L10+1)) ;;
	   *) echo "ONLY 10 LEVELS OF BRANCHING ARE SUPPORTED [3 - $LEVEL,$CUR_LEVEL]" ;;
	   esac

	 fi
	 ROW=$L1.$L2.$L3.$L4.$L5.$L6.$L7.$L8.$L9.$L10
     fi
     #re-initialize LEVEL, the next row processed at top of loop should dictate
     #what level we are on byt parsing it from the data
     LEVEL=
   done
   #the above section is only going to be processed if $TYP = -a or -b
   ;;
 esac
 
fi # OFFLINE checking for OS commands ends here
  
  case $TYP in
  -a|-p|-f|-u)
       if [[ $SILENT -eq 0 &&  $upgrade_mode -ne 2 ]] 
       then
           #SCRIPTVER=`grep $DBVERSION $REFFIL |awk {'print $3'}`
           #PATCHVER=`grep $SCRIPTVER $REFFIL |awk {'print $3'}`
           #NON_PCW_NUM=`grep -c RP_COMPARE_VALUE $REFFIL1`
           #if [[ -n "$crsdb_mixed_version" && $crsdb_mixed_version -eq 1 ]]
           #then
           #    PCW_NUM=`grep -c PP_COMPARE_VALUE $REFFIL2`
           #    #read -p "it came here and found $PCW_NUM patchs from $REFFIL2"
           #else
                PCW_NUM=`grep -c PP_COMPARE_VALUE $REFFIL1`
           #fi
           if [[ $no_patches -eq 0 && $TYP != "-p" && -n "$db_machine_compute" && $db_machine_compute -eq 0 ]] 
           then
                  echo -e "\n\nBest Practice checking completed.Checking recommended patches on ${i}."
                   echo -e "---------------------------------------------------------------------------------\n\n"
           fi
       fi
       PATCHRESULT=$OUTPUTDIR/o_patch_result_${i}.out
       pp_crs_pcount=0
       pp_rdbms_pcount=0
       pp_asm_pcount=0
       rp_rdbms_pcount=0
       rp_asm_pcount=0
       unset rs_crs_applied
       unset rs_rdbms_applied
       unset rs_asm_applied
       if [[ -n "${asm_installed[$stack_counter]}" && ${asm_installed[$stack_counter]} -eq 0 ]]
       then
           unset ASM_HOME
       fi
	   ##================================================================================================
	   # CHANGED DONE BY GIRI TO QUERY OPATCH RATHER THAN COMPS.XML TO FIND OUT  ABOUT PATCH IF NUMBER OF NODES ARE LESS THAN 5
	   
	   #if [ `cat $HOSTLIST |wc -l` -lt 5  ]
	   if [[ `cat $HOSTLIST |wc -l` -lt 999 && $OFFLINE -eq 0 && $upgrade_mode -ne 2 ]] 
	   then
               echo -e "`date '+%a %b %d %H:%M:%S %Y'` - Recommended patches analysis on ${i}\n">>$RACCHECK_TIMING
               if [ $i = $localnode ]
               then 
                   if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "CRS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]]   
                   then
		       echo "Collecting patch inventory on  CRS HOME $CRS"|tee -a $LOGFIL
		       $CRS/OPatch/opatch lsinventory -oh $CRS > $OUTPUTDIR/o_crs_inventory_${i}.out 2>>$ERRFIL
		       crs_opatch_status=$(echo $?)
		       #if opatch fails then copy comps.xml as second source of patch info
		       if [ $crs_opatch_status  -ne 0 ]
		       then 
			    echo "Opatch failed with error code $crs_opatch_status on $i for $CRS.\n\n${program_name} will use $CRS/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
			   cat $CRS/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_crs_inventory_${i}.out
		       fi
		       if [ $crs_opatch_status  -eq 0 ]
		       then
			    cat $OUTPUTDIR/o_crs_inventory_${i}.out|grep Patch|awk '{print $2}'|sed 's/[a-zA-Z\.]//g'|sed '/^$/d'|sort>$OUTPUTDIR/o_crs_patchlist_${i}.out
		       fi
                   fi
                   if [ -n "$ASM_HOME" ] && [[ `echo $components|grep -cwi "NONE"` -ge 1 || `echo $components|grep -icw"ASM"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]]
	           then
                       echo "Collecting patch inventory on ASM HOME $ASM_HOME"|tee -a $LOGFIL
	               $ASM_HOME/OPatch/opatch lsinventory -oh $ASM_HOME > $OUTPUTDIR/o_asm_inventory_${i}.out 2>>$ERRFIL
                       asm_opatch_status=$(echo $?)
                       if [ $asm_opatch_status -ne 0 ]
                       then 
                        echo "Opatch failed with error code $asm_opatch_status on $i for $ASM_HOME.\n\n${program_name} will use $ASM_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
                           cat $ASM_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_asm_inventory_${i}.out
                       fi
                       if [ $asm_opatch_status -eq 0 ]
                       then
                           cat $OUTPUTDIR/o_asm_inventory_${i}.out|grep Patch|awk '{print $2}'|sed 's/[a-zA-Z\.]//g'|sed '/^$/d'|sort>$OUTPUTDIR/o_asm_patchlist_${i}.out
                       fi
	           fi
                   if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "RDBMS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 || `echo $components|grep -icw "SIDB"` -ge 1 ]] 
                   then
		       mb_db_counter=0
		       for mb_db_homes in ${mb_oracle_homes_distinct[@]}
		       do
			   mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
			   #read -p "mb_db_homes=$mb_db_homes"
			   if [ -d $mb_db_homes ] 
			   then
                               rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
                               if [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 && $rdbms_home_version -ne $targetversion ]]
                               then
                                   echo "Skipping $mb_db_homes because running in post upgrade and version is $rdbms_home_version">>$LOGFIL
                               else
				   echo "Collecting patch inventory on ORACLE_HOME $mb_db_homes "|tee -a $LOGFIL
				   export ORACLE_HOME=$mb_db_homes
				   $ORACLE_HOME/OPatch/opatch lsinventory -oh $ORACLE_HOME > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out 2>>$ERRFIL
				   rdbms_opatch_status=$(echo $?)
				   if [ $rdbms_opatch_status -ne 0 ]
				   then 
					echo  "Opatch failed with error code $rdbms_opatch_status on $i for $ORACLE_HOME.\n\n${program_name} will use $ORACLE_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
				       cat  $ORACLE_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out
				   fi
				   if [ $rdbms_opatch_status -eq 0 ]
				   then
				       cat $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|grep Patch|awk '{print $2}'|sed 's/[a-zA-Z\.]//g'|sed '/^$/d'|sort>$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${i}.out
				   fi
                               fi
			   fi
			   mb_db_counter=$(expr $mb_db_counter + 1)
		       done
		       mb_db_counter=0
                   fi
               else    
                   if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "CRS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1  ]]   
                   then
		       echo "Collecting patch inventory on  CRS HOME $CRS "|tee -a $LOGFIL
		       $SSHELL $i $CRS/OPatch/opatch lsinventory -oh $CRS > $OUTPUTDIR/o_crs_inventory_${i}.out 2>>$ERRFIL
		       crs_opatch_status=$(echo $?)
		       if [ $crs_opatch_status  -ne 0 ] 
		       then 
			    echo "Opatch failed with error code $crs_opatch_status on $i for $CRS.\n\n${program_name} will use $CRS/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">>$LOGFIL
			   $SSHELL $i  cat  $CRS/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_crs_inventory_${i}.out
		       fi
		       if [ $crs_opatch_status  -eq 0 ]
		       then
			   cat $OUTPUTDIR/o_crs_inventory_${i}.out|grep Patch|awk '{print $2}'|sed 's/[a-zA-Z\.]//g'|sed '/^$/d'|sort>$OUTPUTDIR/o_crs_patchlist_${i}.out
		       fi
                   fi
                   if [ -n "$ASM_HOME" ] && [[ `echo $components|grep -cwi "NONE"` -ge 1 || `echo $components|grep -icw"ASM"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]]
	           then
                       echo "Collecting patch inventory on ASM HOME $ASM_HOME "|tee -a $LOGFIL
	               $SSHELL $i $ASM_HOME/OPatch/opatch lsinventory -oh $ASM_HOME > $OUTPUTDIR/o_asm_inventory_${i}.out 2>>$ERRFIL
                       asm_opatch_status=$(echo $?)
                       if [ $asm_opatch_status -ne 0 ]
                       then
                        echo "Opatch failed with error code $asm_opatch_status on $i for $ASM_HOME.\n${program_name} will use $ASM_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
                           $SSHELL $i cat $ASM_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_asm_inventory_${i}.out
                       fi
                       if [ $asm_opatch_status -eq 0 ]
                       then
                           cat $OUTPUTDIR/o_asm_inventory_${i}.out|grep Patch|awk '{print $2}'|sed 's/[a-zA-Z\.]//g'|sed '/^$/d'|sort>$OUTPUTDIR/o_asm_patchlist_${i}.out
                       fi
	           fi
                   if [[ `echo $components|grep -iwc "NONE"` -ge 1 || `echo $components|grep -icw "RDBMS"` -ge 1 || `echo $components|grep -cwi "EXADATA"` -ge 1 || `echo $components|grep -icw "X2-2"` -ge 1 || `echo $components|grep -cwi "X2-8"` -ge 1 || `echo $components|grep -icw "ODA"` -ge 1 ]]
		   then
		       mb_db_counter=0
		       for mb_db_homes in ${mb_oracle_homes_distinct[@]}
		       do
			   mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
			   validate_remote_oracle_home=$($SSHELL $i ls -l $mb_db_homes >/dev/null 2>&1;echo $?)
			   if [[ -n "$validate_remote_oracle_home" && $validate_remote_oracle_home -eq 0 ]]
			   then
                               rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
                               if [[ -n "$upgrade_mode" && $upgrade_mode -eq 3 && $rdbms_home_version -ne $targetversion ]]
                               then
				   echo "Skipping $mb_db_homes because running in post upgrade and version is $rdbms_home_version">>$LOGFIL
				   else
				   echo "Collecting patch inventory on ORACLE_HOME $mb_db_homes "|tee -a $LOGFIL
				   export ORACLE_HOME=$mb_db_homes
				   $SSHELL $i $ORACLE_HOME/OPatch/opatch lsinventory -oh $ORACLE_HOME > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out 2>>$ERRFIL
				   rdbms_opatch_status=$(echo $?)
				   if [ $rdbms_opatch_status -ne 0 ]
				   then 
					echo  "Opatch failed with error code $rdbms_opatch_status on $i for $ORACLE_HOME.\n\n${program_name} will use $ORACLE_HOME/inventory/ContentsXML/comps.xml as alternate source for installed recommended patch analysis">> $LOGFIL
				       $SSHELL $i cat $ORACLE_HOME/inventory/ContentsXML/comps.xml > $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out
				   fi
				   if [ $rdbms_opatch_status -eq 0 ]
				   then
				       cat $OUTPUTDIR/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out|grep Patch|awk '{print $2}'|sed 's/[a-zA-Z\.]//g'|sed '/^$/d'|sort>$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${i}.out
				   fi
                               fi
			   fi
			   mb_db_counter=$(expr $mb_db_counter + 1)
		       done
		       mb_db_counter=0
                   fi
              fi
           else
               if [ $SILENT = 1 ]
               then
                  cp $CRS_INVENTORY $OUTPUTDIR/o_crs_comps_${i}.xml
                  cp $RDBMS_INVENTORY $OUTPUTDIR/o_rdbms_comps_${i}xml
                  if [[ -n $ASM  && $g112 -gt 0 ]]
                  then
                      cp $ASM_INVENTORY $OUTPUTDIR/o_asm_comps_${i}.xml
                  fi
               fi
           fi
           ##================================================================================================
           #To format headings for patches on screen,output file and logfile 
#IF RUNNING IN SILENT MODE, DONT CHECK PATCHES APPLIED OR NOT. JUST DUMP THE PATCH FILES ON OUTPUTDIR	
       #echo "DEBUG SILENT=$SILENT and RUNSWITCH=$RUNSWITCH"
        if [[ $SILENT -eq "0" && $RUNSWITCH != "-b"  &&  $no_patches -eq 0 && $db_machine_compute -eq 0 && $oda_machine -eq 0 ]]
        then  
            fmt_recomended="Patch#"
	    fmt_rdbms="RDBMS"
	    fmt_crs="CRS"
	    fmt_asm="ASM"
            fmt_rdbms_home="RDBMS_HOME"
	    fmt_patch_type_header="type"
	    fmt_dscrp="Patch-Description"
            fmt_patch_yes="yes"
	    fmt_patch_no="no"
            fmt_patch_type_merge="merge"
	    fmt_patch_type_oneoff="single"
	    fmt_hname=`echo $i`
            fmt_line_header="---------------------------------------------------------------------------------"
            fmt_ppheader_1="Total patches"
            fmt_ppheader_2="Applied on CRS"
            fmt_ppheader_3="Applied on RDBMS"
            fmt_ppheader_4="Applied on ASM"
            fmt_rpheader_1="Total patches"
            fmt_rpheader_2="Applied on RDBMS"
            fmt_rpheader_3="Applied on ASM"
            crs_patch_printed_html=0 # gadiga  track first time print to print heading
            if [[ $CREATE_HTML_REPORT -eq 1 && -e ${OUTPUTDIR}/o_crs_inventory_${i}.out ]]
            then
              print_crs_patch_detail_heading_html;
            fi
            set old_patch_type
            if [ -e ${OUTPUTDIR}/o_crs_inventory_${i}.out ]
            then
		echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
		echo "$PCW_NUM Recommended CRS patches for `echo ${stack_crs_version[$stack_counter]}|sed 's/\.//g'` from ${CRS} on $fmt_hname"|tee -a $LOGFIL|tee -a $PREPFIL
		echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
		echo $fmt_recomended $fmt_crs $fmt_asm $fmt_rdbms $fmt_rdbms_home  $fmt_dscrp|awk '{printf "%-9s%-5s%-7s%-6s%-40s%-45s\n",$1,$2,$3,$4,$5,$6}'|tee -a $LOGFIL|tee -a $PREPFIL
		echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
                if [[ $CREATE_HTML_REPORT -eq 1 && $PCW_NUM -eq "0" ]]
                then # For html report.. as we dont enter for loop, tell user that there are no patches
                  print_crs_patch_detail_html;
                fi
		for ((j=1;j<=$PCW_NUM;j+=1));
		do
		  SUBJ=`grep "_"$j"-PP_COMMAND" $REFFIL1 |sed  -n 's/.*-PP_COMMAND //p'` 
		  PATCH=`grep _$j-PP_COMPARE_VALUE $REFFIL1 |awk {'print $2'}`
		  PATCHTYPE=`grep _$j-PP_PARAM_PATH $REFFIL1 |awk {'print $2'}`
		  #==========================================================================================
		  check_patch "crs" "$PATCH"
		  ###=========================================================================================
		  if [ "$APPLIED" -gt "0" ]
		  then
		    fmt_crs_applied=$fmt_patch_yes
		    rs_crs_applied=1
		    pp_crs_pcount=$(($pp_crs_pcount+1))
		     #Added by kumar
		   if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
		   then
		       echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','crs','$CRS','${stack_crs_version[$stack_counter]}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1);">>$upload_raccheck_patch_result_fil
		   fi
		  else
		     fmt_crs_applied=$fmt_patch_no
		     rs_crs_applied=0
		     if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
		     then
			 echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','crs','$CRS','${stack_crs_version[$stack_counter]}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1);">>$upload_raccheck_patch_result_fil
		     fi
		  fi
		  mb_db_counter=0
		  #read -p "${mb_db_versions_all[$mb_db_counter]} and  ${stack_crs_version[$stack_counter]}"
		  for mb_db_homes in ${mb_oracle_homes_distinct[@]}
		  do
		      mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
		      if [ -f ${OUTPUTDIR}/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out ]
		      then
			  rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
			  #read -p "rdbms_home_version=$rdbms_home_version"
			  if [[ -n "${stack_crs_version[$stack_counter]}" && -n "$rdbms_home_version" && ${rdbms_home_version} -eq `echo ${stack_crs_version[$stack_counter]}|sed 's/\.//g'` ]]
			  then
			      mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
			      #==========================================================================================
			      check_patch "rdbms" "$PATCH"
			      #==========================================================================================
			      if [ "$APPLIED" -gt "0" ]
			      then
				 mb_fmt_rdbms_applied[$mb_db_counter]=$fmt_patch_yes
				 mb_rs_rdbms_applied[$mb_db_counter]=1
				 pp_rdbms_pcount=$(($pp_rdbms_pcount+1))
				 mb_pp_rdbms_pcount[$mb_db_counter]=$pp_rdbms_pcount
				 mb_crs_oh[$mb_db_counter]=$mb_db_homes
				 #Added by kumar
				 if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
				 then
				     echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','$ORACLE_HOME','${stack_dbinst_version[$stack_counter]}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1);">>$upload_raccheck_patch_result_fil
				 fi
			      else
				 mb_fmt_rdbms_applied[$mb_db_counter]=$fmt_patch_no
				 mb_rs_rdbms_applied[$mb_db_counter]=0
				 mb_crs_oh[$mb_db_counter]=$mb_db_homes
				 if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
				 then
				      echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','$ORACLE_HOME','${stack_dbinst_version[$stack_counter]}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1);">>$upload_raccheck_patch_result_fil
				 fi
			      fi
			  fi
		      fi
		      mb_db_counter=$(expr $mb_db_counter + 1)
		  done
		  rdbms_home_count_for_crs=$mb_db_counter
		  mb_db_counter=0
		  if [[ -n "$ASM_HOME" && -e ${OUTPUTDIR}/o_asm_inventory_${i}.out ]]
		  then
		       #==========================================================================================
		       check_patch "asm" "$PATCH"
		      ###=========================================================================================

		    if [ "$APPLIED" -gt "0" ]
		    then
		      fmt_asm_applied=$fmt_patch_yes
		      rs_asm_applied=1
		      pp_asm_pcount=$(($pp_asm_pcount+1))
		      #Added by kumar
		      if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
		      then
			  echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1);">>$upload_raccheck_patch_result_fil
		      fi
		    else
		       fmt_asm_applied=$fmt_patch_no
		       rs_asm_applied=0
		       if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
		       then
			   echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1);">>$upload_raccheck_patch_result_fil
		       fi
		    fi
		  fi
    #######################################################
		  if [ $PATCHTYPE = "Merge" ] 
		  then
		      fmt_patch_type=$fmt_patch_type_merge
		  else
		     fmt_patch_type=$fmt_patch_type_oneoff
		  fi
		#if [ $OFFLINE -eq 0 ] 
		#then
	       echo $PATCH |awk '{printf "%-9s",$1}'
	       if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
	       then
		fmt_subj=`echo $SUBJ |awk 'BEGIN { FS = "\n" };{print substr($1,0,39)}'`
		if [ $fmt_crs_applied = $fmt_patch_yes ]
		then
		    echo -e $GREEN$fmt_crs_applied$NORM|awk '{printf "%-5s",$2}'
		else
		    echo -e $RED $fmt_crs_applied $NORM|awk '{printf "%-5s",$2}'
		fi
		if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
		then
		    echo -e $GREEN $fmt_asm_applied $NORM|awk '{printf "%-6s",$2}'
		else
		    echo -e $RED $fmt_asm_applied $NORM|awk '{printf "%-6s",$2}'
		fi
		mb_db_counter=0
		for mb_db_homes in ${mb_oracle_homes_distinct[@]}
		do
		   if [ -n "${mb_fmt_rdbms_applied[$mb_db_counter]}" ]
		   then
		       fmt_rdbms_applied=${mb_fmt_rdbms_applied[$mb_db_counter]}
		       mb_crs_rdbms_home=${mb_crs_oh[$mb_db_counter]}
		       if [ $fmt_rdbms_applied = $fmt_patch_yes ]
		       then
			    echo -e $GREEN $fmt_rdbms_applied $NORM|awk '{printf "%-7s",$2}'
		       else
			    echo -e $RED $fmt_rdbms_applied $NORM|awk '{printf "%-7s",$2}'
		       fi
		       echo -e $mb_crs_rdbms_home|awk '{printf "%-19s",$1}'
		   fi
		    mb_db_counter=$(expr $mb_db_counter + 1)
		done  
		mb_db_counter=0
	       else
		fmt_subj=`echo $SUBJ |awk '{print substr($SUBJ,0,39)}'`
		if [ $fmt_crs_applied = $fmt_patch_yes ]
		then
		    echo -e $GREEN$fmt_crs_applied$NORM|awk '{printf "%-20s",$fmt_crs_applied}'
		else
		    echo -e $RED $fmt_crs_applied $NORM|awk '{printf "%-20s",$fmt_crs_applied}'
		fi
		if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
		then
		    echo -e $GREEN $fmt_asm_applied $NORM|awk '{printf "%-20s",$fmt_asm_applied}'
		else
		    echo -e $RED $fmt_asm_applied $NORM|awk '{printf "%-20s",$fmt_asm_applied}'
		fi
		mb_db_counter=0
    #            echo  "mb_fmt_rdbms_applied=${mb_fmt_rdbms_applied[@]} and mb_crs_oh=${mb_crs_oh[@]}"
		for mb_db_homes in ${mb_oracle_homes_distinct[@]}
		do
		   if [ -n "${mb_fmt_rdbms_applied[$mb_db_counter]}" ]
		   then
			#read -p "fmt_rdbms_applied=$fmt_rdbms_applied and fmt_patch_yes=$fmt_patch_yes array=${mb_fmt_rdbms_applied[$mb_db_counter]}"
			fmt_rdbms_applied=${mb_fmt_rdbms_applied[$mb_db_counter]}
			mb_crs_rdbms_home=${mb_crs_oh[$mb_db_counter]}
			if [ $fmt_rdbms_applied = $fmt_patch_yes ]
			then
			     echo -e $GREEN $fmt_rdbms_applied $NORM|awk '{printf "%-19s",$fmt_rdbms_applied}'
			else
			     echo -e $RED $fmt_rdbms_applied $NORM|awk '{printf "%-19s",$fmt_rdbms_applied}'
			fi
			echo -e $mb_crs_rdbms_home|awk '{printf "%-19s",$mb_crs_rdbms_home}'
    #                    echo -e "\n"|awk '{printf "%-40s",$1}'
		       # echo -e $mb_db_homes|awk '{printf "%-40s",$mb_db_homes}'
		    fi
		    mb_db_counter=$(expr $mb_db_counter + 1)
		done
		mb_db_counter=0
    #           read -p "stop"
	       fi #end if of uname -s AIX
		#echo $fmt_patch_type|awk '{printf "%-8s",$fmt_patch_type}'
		#echo $fmt_patch_type|awk '{printf "%-8s",$1}'
		echo $PATCH $fmt_crs_applied $fmt_asm_applied $fmt_rdbms_applied $fmt_patch_type |awk '{printf "%-9s%-5s%-7s%-6s%-8s",$1,$2,$3,$4,$5}'>>$PREPFIL
		echo $PATCH $fmt_crs_applied $fmt_asm_applied $fmt_rdbms_applied $fmt_patch_type |awk '{printf "%-9s%-5s%-7s%-6s%-8s",$1,$2,$3,$4,$5}'>>$LOGFIL
		#read -p "PATCHRESULT=$PATCHRESULT"
		echo $PATCH@$rs_crs_applied@$rs_rdbms_applied@$rs_asm_applied >>$PATCHRESULT
		#echo $fmt_subj |awk '{printf "%-45s\n",$fmt_subj}'|tee -a $LOGFIL | tee -a $REPFIL
                if [ $CREATE_HTML_REPORT -eq 1 ]
                then
                  print_crs_patch_detail_html;
                fi

		if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
		then
		    echo $fmt_subj |awk 'BEGIN { FS = "\n" };{printf "%-45s\n",$1}'|tee -a $LOGFIL | tee -a $PREPFIL
		else
		    echo $fmt_subj |awk '{printf "%-45s\n",$fmt_subj}'|tee -a $LOGFIL | tee -a $PREPFIL
		fi
		#else
		    #echo $PATCH $fmt_crs_applied $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type |awk '{printf "%-9s%-5s%-7s%-6s%-8s",$1,$2,$3,$4,$5}'|tee -a $FREPFIL
		    #echo $fmt_subj |awk '{printf "%-45s\n",$fmt_subj}'|tee -a $FREPFIL
	       #fi
    ###########################################################6
	    done
        fi
        mb_db_counter=0
        OLD_REFFIL1=$REFFIL1
        #echo "${mb_oracle_homes_distinct[@]} ${mb_oracle_versions_distinct[@]} all version=${mb_db_version_all[@]}"
       if [[ -n "$single_instance_run" && $single_instance_run -eq "1" ]] ; then patch_prefix="SP"; else patch_prefix="RP"; fi;

       for mb_db_homes in ${mb_oracle_homes_distinct[@]}
       do  
           mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
           rp_rdbms_pcount=0
           rp_asm_pcount=0 
           if [ -f ${OUTPUTDIR}/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out ]
           then           
	       if [ $crsdb_mixed_version -eq 1 ]
	       then
                   rdbms_home_version=$(grep "$mb_db_homes" $OUTPUTDIR/mb_db_homes_distinct.out|sort -u|cut -d'|' -f2)
		   if [ $OFFLINE -eq 0 ]
		   then 
		       REFFIL1=$INPUTDIR/rules_${rdbms_home_version}.dat
		       #REFFIL1=$INPUTDIR/rules_${mb_db_versions_all[$mb_db_counter]}.dat
		   else
		       REFFIL1=$DUMPDIR/rules_${rdbms_home_version}.dat
		   fi
	       fi
               #echo "mb_db_homes=$mb_db_homes $DUMPDIR/mb_db_homes_distinct.out crsdb_mixed_version=$crsdb_mixed_version" 
               NON_PCW_NUM=0  
	       if [ -r $REFFIL1 ]; then NON_PCW_NUM=$(grep -c ${patch_prefix}_COMPARE_VALUE $REFFIL1 2>$ERRFIL);fi
	       echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
	       echo "" |tee -a $LOGFIL |tee -a $PREPFIL
	       echo "" |tee -a $LOGFIL |tee -a $PREPFIL
	       echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
	       echo "$NON_PCW_NUM Recommended RDBMS patches for ${rdbms_home_version} from ${mb_oracle_homes_distinct[$mb_db_counter]} on $i"|tee -a $LOGFIL|tee -a $PREPFIL
	       echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
	       echo $fmt_recomended $fmt_rdbms $fmt_asm $fmt_patch_type_header $fmt_dscrp|awk '{printf "%-9s%-9s%-8s%-20s%-40s\n",$1,$2,$3,$4,$5}'|tee -a $LOGFIL|tee -a $PREPFIL
	       echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL
	       unset rs_crs_applied
	       unset rs_rdbms_applied
	       unset rs_asm_applied
	       napply_rdbms_cnt=0
	       napply_asm_cnt=0
	       napply_molecule=0
	       napply_molecule_cnt=1
	       unset rdbms_napply_missing_list
	       unset asm_napply_missing_list
               printed_rdbms_patch_html=0 # gadiga added to track first time
               if [[ $CREATE_HTML_REPORT -eq 1 && $NON_PCW_NUM -eq "0" ]]
               then
                 print_rdbms_patch_detailed_html
               fi
	       #read -p "File being used $REFFIL1"
	       #read -p "File being used is $REFIL1 mb_db_counter=$mb_db_counter"
	       for ((j=1;j<=${NON_PCW_NUM:-0};j+=1)); 
	       do
		     y=1
		     unset isnapply
		     SUBJ=`grep "_"$j"-${patch_prefix}_COMMAND" $REFFIL1 |sed  -n 's/.*-'${patch_prefix}'_COMMAND //p'`
		     PATCH=`grep _$j-${patch_prefix}_COMPARE_VALUE $REFFIL1 |awk {'print $2'}`
		     PATCHTYPE=`grep _$j-${patch_prefix}_PARAM_PATH $REFFIL1 |awk {'print $2'}`
		     #read -p "PATCHTYPE=$PATCHTYPE"
		     #PATCHTYPE=`grep _$j-RP_PARAM_PATH $REFFIL1 |sed  -n 's/.*-RP_PARAM_PATH //p'`
		     
		     if [ $PATCHTYPE = "Merge" ]
		     then
			 fmt_patch_type=$fmt_patch_type_merge
			 isnapply=0
		     elif [ `echo $PATCHTYPE|grep -c "N-APPLY("` -ge 1 ]
		     then
			 isnapply=1
			 SUBJ=`grep "_"$j"-${patch_prefix}_COMMAND_SUBJ" $REFFIL1 |sed  -n 's/.*-'${patch_prefix}'_COMMAND_SUBJ//p'`
			 napply_molecule=$(grep -c $PATCHTYPE $REFFIL1)
			 fmt_patch_type=$(echo $PATCHTYPE|cut -d'(' -f1)
		     else
			isnapply=0
			fmt_patch_type=$fmt_patch_type_oneoff
		     fi
		     #if [[ $old_patch_type = $PATCHTYPE && $isnapply -eq 1 ]] 
		     #then
		     #    fmt_patch_type="$napply_molecule "
		     #fi  
		     #old_patch_type=$PATCHTYPE
		     #==========================================================================================
		     check_patch "rdbms" "$PATCH"
		     ###=========================================================================================
		     if [ "$APPLIED" -gt "0" ]
		     then
			 fmt_rdbms_applied=$fmt_patch_yes
			 rs_rdbms_applied=1
			 rp_rdbms_pcount=$(($rp_rdbms_pcount+1))
			 if [ $isnapply -eq 1 ]
				then 
			     napply_rdbms_cnt=$(($napply_rdbms_cnt+1))
			     fmt_rdbms_applied_napply=$(echo ${napply_rdbms_cnt}/${napply_molecule})
			 fi
			 #Added by kumar
			 if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
			 then
			     echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','$ORACLE_HOME','${stack_dbinst_version[$stack_counter]}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1);">>$upload_raccheck_patch_result_fil
			 fi   
		     else
			 fmt_rdbms_applied=$fmt_patch_no
			 rs_rdbms_applied=0
			 #Added by kumar
			 if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
			 then   
			     echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','rdbms','$ORACLE_HOME','${stack_dbinst_version[$stack_counter]}','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1);">>$upload_raccheck_patch_result_fil
			 fi 
			 if [ $isnapply -eq 1 ]
			 then 
			     fmt_rdbms_applied_napply=$(echo ${napply_rdbms_cnt}/${napply_molecule})
			     if [ -z "$rdbms_napply_missing_list" ] 
			     then
				 rdbms_napply_missing_list=${PATCH}
			     else
				 rdbms_napply_missing_list=$(echo ${rdbms_napply_missing_list}","${PATCH})
			     fi
			 fi
			
		      fi
		      #echo "ASM_HOME=$ASM_HOME" 
		      if [[ -n "$ASM_HOME" && -e ${OUTPUTDIR}/o_asm_inventory_${i}.out ]]
		      then
			  #==========================================================================================
			  check_patch "asm" "$PATCH" 
			  ###=========================================================================================
			  if [ "$APPLIED" -gt "0" ]
			  then
			      fmt_asm_applied=$fmt_patch_yes
			      rp_asm_pcount=$(($rp_asm_pcount+1))
			      rs_asm_applied=1
			      if [ $isnapply -eq 1 ]
			      then 
				  napply_asm_cnt=$(($napply_asm_cnt+1))
				  fmt_asm_applied_napply=$(echo ${napply_asm_cnt}/${napply_molecule})
			      fi
			      #Added by kumar
			      if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
			      then   
				  echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',1,1);">>$upload_raccheck_patch_result_fil
			      fi
			  else
			      fmt_asm_applied=$fmt_patch_no
			      rs_asm_applied=0
			      #Added by kumar
			      if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
			      then
				  echo "insert into $RAT_PATCH_UPLOAD_TABLE(collection_date,hostname,oracle_home_type,oracle_home_path,oracle_home_version,patch_number,cluster_name,description,patch_type,applied,recommended)   values   (to_date('$collection_date','DD-MON-YYYY HH24:MI:SS'),'$i','asm','$ASM_HOME','version','$PATCH','$cluster_name','$SUBJ','$PATCHTYPE',0,1);">>$upload_raccheck_patch_result_fil
			      fi
			      if [ $isnapply -eq 1 ]
			      then 
				  #napply_asm_cnt=$(($napply_rdbms_cnt+1))
				  fmt_asm_applied_napply=$(echo ${napply_asm_cnt}/${napply_molecule})
				  if [ -z "$asm_napply_missing_list" ]
				  then
				      asm_napply_missing_list=${PATCH}
				  else
				      asm_napply_missing_list=$(echo ${asm_napply_missing_list}","${PATCH})
				  fi
			      fi
			  fi
		      fi
		      if [ $isnapply -eq 1 ]
		      then
			  PATCH=$(echo $PATCHTYPE|sed  -n 's/.*(//p'|sed 's/)//g')
		      fi
		      #read -p " $napply_molecule and  $napply_molecule_cnt $PATCH nappy=$isnapply rdbms_napply_missing_list=$rdbms_napply_missing_list" 
		      if  [[ $isnapply -eq 1 && $napply_molecule_cnt -lt $napply_molecule ]]
		      then
			  napply_molecule_cnt=$(($napply_molecule_cnt+1))
		      else
			  echo $PATCH |awk '{printf "%-9s",$1}'
			  #read -p "napply_rdbms_cnt=$napply_rdbms_cnt and napply_molecule_cnt=$napply_molecule_cnt"
			  if [ $isnapply -eq 1 ] && [[ $napply_rdbms_cnt -gt 0 && $napply_rdbms_cnt -lt $napply_molecule_cnt ]]
			  then
			      fmt_rdbms_applied=$fmt_patch_no
			      fmt_asm_applied=$fmt_patch_no
			      if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
			      then
				  fmt_subj=`echo $SUBJ |awk 'BEGIN { FS = "\n" };{print substr($1,0,40)}'`
				  if [ $fmt_rdbms_applied = $fmt_patch_yes ]
				  then
				      echo -e $GREEN $fmt_rdbms_applied_napply $NORM|awk '{printf "%-9s",$2}'
				  else
				      echo -e $RED $fmt_rdbms_applied_napply $NORM|awk '{printf "%-9s",$2}'  
				  fi
				  echo "Missing fixes from n-apply patch $PATCH from RDBMS HOME  are $rdbms_napply_missing_list" > $napply_missing_list
				  if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
				  then
				     echo -e $GREEN $fmt_asm_applied_napply $NORM|awk '{printf "%-8s",$2}'
				  else
				      echo -e $RED $fmt_asm_applied_napply $NORM|awk '{printf "%-8s",$2}'
				  fi
				  if [ -n "$ASM_HOME" ]
				  then
				      echo "Missing fixes from n-apply patch $PATCH from ASM HOME are $asm_napply_missing_list" >> $napply_missing_list
				  fi
			      else 
				  fmt_subj=`echo $SUBJ |awk '{print substr($SUBJ,0,40)}'`
				  if [ $fmt_rdbms_applied = $fmt_patch_yes ]
				  then
				      echo -e $GREEN $fmt_rdbms_applied_napply $NORM|awk '{printf "%-22s",$fmt_rdbms_applied}'
				  else
				      echo -e $RED $fmt_rdbms_applied_napply $NORM|awk '{printf "%-22s",$fmt_rdbms_applied}'  
				  fi 
				  echo "Missing fixes from n-apply patch $PATCH from RDBMS HOME  are $rdbms_napply_missing_list" >>  $napply_missing_list
				  if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
				  then
				      echo -e $GREEN $fmt_asm_applied_napply $NORM|awk '{printf "%-22s",$fmt_asm_applied}'
				  else
				      echo -e $RED $fmt_asm_applied_napply $NORM|awk '{printf "%-22s",$fmt_asm_applied}'
				  fi
				  if [ -n "$ASM_HOME" ]
				  then
				      echo "Missing fixes from n-apply  patch $PATCH from ASM HOME are $asm_napply_missing_list" >> $napply_missing_list
				  fi
			      fi
			      echo $fmt_patch_type|awk '{printf "%-20s",$1}'
			      echo $PATCH $fmt_rdbms_applied_napply $fmt_asm_applied_napply $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$LOGFIL
			      echo $PATCH $fmt_rdbms_applied_napply $fmt_asm_applied_napply $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$PREPFIL
                              if [ $CREATE_HTML_REPORT -eq 1 ]
                              then
                                print_rdbms_patch_detailed_html "$PATCH" "$fmt_rdbms_applied_napply" "$fmt_asm_applied_napply" "$fmt_patch_type"
                              fi
			  else
			      if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
			      then
				  fmt_subj=`echo $SUBJ |awk 'BEGIN { FS = "\n" };{print substr($1,0,40)}'`
				  if [ $fmt_rdbms_applied = $fmt_patch_yes ]
				  then
				      echo -e $GREEN $fmt_rdbms_applied $NORM|awk '{printf "%-9s",$2}'
				  else
				      echo -e $RED $fmt_rdbms_applied $NORM|awk '{printf "%-9s",$2}'  
				  fi 
				  if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
				  then
				     echo -e $GREEN $fmt_asm_applied $NORM|awk '{printf "%-8s",$2}'
				  else
				      echo -e $RED $fmt_asm_applied $NORM|awk '{printf "%-8s",$2}'
				  fi
			      else 
				  fmt_subj=`echo $SUBJ |awk '{print substr($SUBJ,0,40)}'`
				  if [ $fmt_rdbms_applied = $fmt_patch_yes ]
				  then
				      echo -e $GREEN $fmt_rdbms_applied $NORM|awk '{printf "%-22s",$fmt_rdbms_applied}'
				  else
				      echo -e $RED $fmt_rdbms_applied $NORM|awk '{printf "%-22s",$fmt_rdbms_applied}'  
				  fi 
				  if [[ $fmt_asm_applied = $fmt_patch_yes && -n $ASM_HOME ]]
				  then
				      echo -e $GREEN $fmt_asm_applied $NORM|awk '{printf "%-22s",$fmt_asm_applied}'
				  else
				      echo -e $RED $fmt_asm_applied $NORM|awk '{printf "%-22s",$fmt_asm_applied}'
				  fi
			      fi
			      echo $fmt_patch_type|awk '{printf "%-20s",$1}'
			      echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$LOGFIL
			      echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$PREPFIL
                              if [ $CREATE_HTML_REPORT -eq 1 ]
                              then
                                print_rdbms_patch_detailed_html "$PATCH" "$fmt_rdbms_applied" "$fmt_asm_applied" "$fmt_patch_type"
                              fi
			  fi
			  #echo $fmt_patch_type|awk '{printf "%-20s",$1}'
			  #echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$LOGFIL
			  #echo $PATCH $fmt_rdbms_applied $fmt_asm_applied $fmt_patch_type|awk '{printf "%-9s%-9s%-8s%-20s",$1,$2,$3,$4}'>>$REPFIL
			  if [[ `uname -s` = "AIX"  || `uname -s` = "HP-UX" ]]
			  then
			      echo $fmt_subj |awk 'BEGIN { FS = "\n" };{printf "%-40s\n",$1}'|tee -a $LOGFIL | tee -a $PREPFIL
			  else
			      echo $fmt_subj |awk '{printf "%-40s\n",$fmt_subj}'|tee -a $LOGFIL | tee -a $PREPFIL
			  fi
			  #echo "missing patch list $rdbms_napply_missing_list and $asm_napply_missing_list"
			  napply_molecule_cnt=1
			  napply_rdbms_cnt=0
			  napply_asm_cnt=0
			  unset rdbms_napply_missing_list
			  unset asm_napply_missing_list
			  
		      fi
			  # read -p "PATCHRESULT=$PATCHRESULT"
		      echo $PATCH@$rs_crs_applied@$rs_rdbms_applied@$rs_asm_applied>>$PATCHRESULT
	       done 
	       mb_non_pcw_num[$mb_db_counter]=$NON_PCW_NUM
	       mb_rp_rdbms_pcount[$mb_db_counter]=$rp_rdbms_pcount
	       mb_rp_asm_pcount[$mb_db_counter]=$rp_asm_pcount
	       echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
	       if [[ -f $napply_missing_list  ]]
	       then
		   echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
		   cat $napply_missing_list>>$PREPFIL
		   rm $napply_missing_list
	       fi
           fi
           mb_db_counter=$(expr $mb_db_counter + 1)
       done
       REFFIL1=$OLD_REFFIL1
       mb_db_counter=0
     
#   read -p "it should work till here"
# echo "OFFLINE=$OFFLINE TYP=$TYP RUNSWITCH=$RUNSWITCH single_instance_run=$single_instance_run"
       if [[ $OFFLINE -eq 0 && "$TYP" = "-a" || "$TYP" = "-p"  ]] || [[ $OFFLINE -eq 1 && "$RUNSWITCH" = "-a" || "$RUNSWITCH" = "-p" && $single_instance_run -eq 0 ]]
       then
         if [[ $single_instance_run -eq "0" ]] ; then
           echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo "              Clusterware patches summary report"|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
           then
              echo $fmt_ppheader_1|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL        
              echo $fmt_ppheader_2|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL        
              echo $fmt_ppheader_3|awk 'BEGIN { FS = "\n" } ;{printf "%-17s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL        
              echo $fmt_ppheader_4|awk 'BEGIN { FS = "\n" } ;{printf "%-15s\n",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL                       
           else
              echo $fmt_ppheader_1|awk '{printf "%-15s",$fmt_ppheader_1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              echo $fmt_ppheader_2|awk '{printf "%-15s",$fmt_ppheader_2}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              echo $fmt_ppheader_3|awk '{printf "%-17s",$fmt_ppheader_3}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
              echo $fmt_ppheader_4|awk '{printf "%-15s\n",$fmt_ppheader_4}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           fi
           echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL  
           echo $PCW_NUM $pp_crs_pcount $pp_rdbms_pcount $pp_asm_pcount |awk '{printf "%-15s%-15s%-17s%-15s\n",$1,$2,$3,$4}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           if [ $CREATE_HTML_REPORT -eq 1 ]
           then
             print_cluster_patch_summary_html;
           fi
         fi
           echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo "              RDBMS homes patches summary report"|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           if [[ `uname -s` = "AIX" || `uname -s` = "HP-UX" ]]
           then
               echo $fmt_rpheader_1|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
               echo $fmt_rpheader_2|awk 'BEGIN { FS = "\n" } ;{printf "%-17s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
               echo $fmt_rpheader_3|awk 'BEGIN { FS = "\n" } ;{printf "%-15s",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
               echo ORACLE_HOME    |awk 'BEGIN { FS = "\n" } ;{printf "%-20s\n",$1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           else
               echo $fmt_rpheader_1|awk '{printf "%-15s",$fmt_rpheader_1}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
               echo $fmt_rpheader_2|awk '{printf "%-17s",$fmt_rpheader_2}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
               echo $fmt_rpheader_3|awk '{printf "%-15s",$fmt_rpheader_3}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
               echo ORACLE_HOME|awk '{printf "%-15s\n",$fmt_rpheader_3}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           fi
           echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           mb_db_counter=0
           mb_db_counter_printed=0 # gadiga Required for html printing
           for mb_db_homes in ${mb_oracle_homes_distinct[@]}
           do 
              mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
              if [ -f ${OUTPUTDIR}/o_rdbms_inventory_${mb_db_homes_fil}_${i}.out ]
              then
                  echo ${mb_non_pcw_num[$mb_db_counter]} ${mb_rp_rdbms_pcount[$mb_db_counter]} ${mb_rp_asm_pcount[$mb_db_counter]} $mb_db_homes|awk '{printf " %-15s%-15s%-17s%-20s\n",$1,$2,$3,$4}'|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
                  if [ $CREATE_HTML_REPORT -eq 1 ]
                  then
                    print_rdbms_patch_summary_html 1;
                  fi
              else
                  if [ $CREATE_HTML_REPORT -eq 1 ]
                  then
                    print_rdbms_patch_summary_html 0;
                  fi
                
              fi
              mb_db_counter=$(expr $mb_db_counter + 1)
           done
           mb_db_counter=0
           mb_db_counter_printed=0
           echo $fmt_line_header|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
           echo ""|tee -a $LOGFIL|tee -a $PREPFIL|tee -a $PSREPFIL
      #else
         #echo $fmt_line_header|tee -a $FREPFIL
         #echo ""|tee -a $FREPFIL
         #echo ""|tee -a $FREPFIL
      fi
    fi # THIS IS THE END OF CHECKING THE SILENT MODE
          #the patch checks are only going to be process if $TYP = -a or -p
          ;;
 esac
#To delete temporary set ORACLE env file after doing all processing
#for rmFile in `cat $HOSTLIST`
#do
#  
#  if [ -f /tmp/root_"$rmFile".sh ]
#  then
#      rm /tmp/root_"$rmFile".sh
#  fi
#  ls -l /tmp/root_"$rmFile".sh
#   read -p " rm -f /tmp/root_"$rmFile".sh" 
#done
if [ $i = $localnode ]
then
    #rm $TRGTORCLENV 2>/dev/null
    rm ${RTEMPDIR}/o_*${i}.out 2>/dev/null
    #rm /tmp/raccheck_env.out 2>/dev/null
elif [ $OFFLINE -eq 0 ] 
then
    #$SSHELL $i "rm $TRGTORCLENV" 2>/dev/null
    $SSHELL $i "rm ${RTEMPDIR}/o_*${i}.out" 2>/dev/null
    #$SSHELL $i "rm /tmp/raccheck_env.out" 2>/dev/null
fi
rm /tmp/root_"$i".sh >/dev/null 2>&1

#loop to delete all os collect files created for os checks
for collect_file_name in "${collect_files[@]}"
do
  if [ -f $collect_file_name ]; then rm $collect_file_name; fi;
done
os_check_needs_collect_file=0 

#this counter is used to track which instance and crs is being worked upon.0 for 1st node and 1 for second node and so forth
stack_counter=`expr $stack_counter + 1`
echo
#echo "Finished run on node $i.. parallel=$RAT_COMPUTE_PARALLEL runmode=$RAT_RUNMODE_INTERNAL";
#-----------------------------------------------
#if [[ -n "$RAT_COMPUTE_PARALLEL" && $RAT_COMPUTE_PARALLEL -eq "1" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
#  wait_for_compute_completion
#echo "waited for completeion";
#fi
#OFFLINE=1
done # main loop for each host ends here

if [[ -n "$RAT_RUNMODE_INTERNAL" && $RAT_RUNMODE_INTERNAL = "slave" ]]
then
  diff $MASTERFIL.saved $MASTERFIL > $MASTERFIL.diff
  OFFLINE=1
  killtree $watchdog_pid 9 >/dev/null 2>&1
  exit;
fi

if [[ $OFFLINE -eq 0 && -n "$RAT_COMPUTE_RUNMODE" && $RAT_COMPUTE_RUNMODE = "parallel" && $RAT_RUNMODE_INTERNAL = "master" ]] ; then
  mv $HOSTLIST.org $HOSTLIST
  wait_for_compute_completion
  OFFLINE=0
fi


#following code is to check that same patches are installed on each node for every oracle home

#To delete 0 byte files 
find $OUTPUTDIR -size -1c  -exec rm -r {} \;
IFS=$'\n'



insertStatementsForInstalledPatches 'crs' $ORACLE_HOME ${stack_dbinst_version[$stack_counter]}
insertStatementsForInstalledPatches 'rdbms' $CRS ${stack_crs_version[$stack_counter]}
insertStatementsForInstalledPatches 'asm' $ASM_HOME 

#have to set IFS back to default to get patch loop working. otherwise it was treating both hostname as sinle line
if [ `cat $HOSTLIST|wc -l` -gt 1 ]
then
    patch_counter=0
    for h_patch in `cat $HOSTLIST`
    do
     if [ $patch_counter -eq 0 ]
     then
	 if [ -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out ]; then source_crs=$OUTPUTDIR/o_crs_patchlist_${h_patch}.out;fi;
     else
	 if [ -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out ]  
	 then
	    diff $source_crs $OUTPUTDIR/o_crs_patchlist_${h_patch}.out >/dev/null 2>&1
	    if [ $? -eq 0 ]; then crs_patch_diff=1;else crs_patch_diff=0;break;fi
	 fi
     fi
    patch_counter=$(expr $patch_counter + 1)
    done
    if [[ -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out && $crs_patch_diff -eq 1 ]] 
    then
	CRS_PATCH_MSG="${GREEN} PASS =>$NORM    CRS home has same number of patches installed across the cluster."
	crs_patch_check_status=1
    elif [  -f $OUTPUTDIR/o_crs_patchlist_${h_patch}.out ]
    then
	CRS_PATCH_MSG="${RED} FAIL =>$NORM    CRS home does not have same number of patches installed across the cluster."
	crs_patch_check_status=0
    fi

    mb_db_counter=0
    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
    do
      mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
      patch_counter=0
      for h_patch in `cat $HOSTLIST`
      do
	#read -p "file to read=$OUTPUTDIR/o_rdbms_patchlist_${h_patch}_${mb_db_homes_fil}.out hostname=$h_patch"
	if [ $patch_counter -eq 0 ]
	then
	    if [ -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out ]; then source_rdbms=$OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out;fi;
	else
	 #   read -p "$source_rdbms $OUTPUTDIR/o_rdbms_patchlist_${h_patch}.out"
	    if [ -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out ]  
	    then
    #	   read -p "$source_rdbms $OUTPUTDIR/o_rdbms_patchlist_${h_patch}_${mb_db_homes_fil}.out"
	       diff $source_rdbms $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out >/dev/null 2>&1
	       if [ $? -eq 0 ]; then mb_rdbms_patch_diff[$mb_db_counter]=1;else mb_rdbms_patch_diff[$mb_db_counter]=0;break;fi
	    fi
	fi
	#read -p "rdbms_patch_diff=${mb_rdbms_patch_diff[$mb_db_counter]} patch_counter=$patch_counter"
	patch_counter=$(expr $patch_counter + 1)
      done 
      mb_db_counter=$(expr $mb_db_counter + 1)
    done

    mb_db_counter=0
    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
    do
       mb_db_homes_fil=$(echo $mb_db_homes|sed 's/\///g')
       if [[ -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out && ${mb_rdbms_patch_diff[$mb_db_counter]} -eq 1 ]] 
       then
	   MB_RDBMS_PATCH_MSG[$mb_db_counter]="${GREEN} PASS =>$NORM    RDBMS home ${mb_db_homes} has same number of patches installed across the cluster."
	   mb_rdbms_patch_check_status[$mb_db_counter]=1
       elif [  -f $OUTPUTDIR/o_rdbms_patchlist_${mb_db_homes_fil}_${h_patch}.out ]
       then
	   MB_RDBMS_PATCH_MSG[$mb_db_counter]="${RED} FAIL =>$NORM    RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster."
	   mb_rdbms_patch_check_status[$mb_db_counter]=0
       fi
       mb_db_counter=$(expr $mb_db_counter + 1)
    done
    mb_db_counter=0

    patch_counter=0
    for h_patch in `cat $HOSTLIST`
    do
     if [ $patch_counter -eq 0 ]
     then
	 if [ -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out ]; then source_asm=$OUTPUTDIR/o_asm_patchlist_${h_patch}.out;fi;
     else
	 if [ -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out ]  
	 then
	    diff $source_asm $OUTPUTDIR/o_asm_patchlist_${h_patch}.out >/dev/null 2>&1
	    if [ $? -eq 0 ]; then asm_patch_diff=1;else asm_patch_diff=0;break;fi
	 fi
     fi
    patch_counter=$(expr $patch_counter + 1)
    done
    patch_counter=0
    if [[ -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out && $asm_patch_diff -eq 1 ]] 
    then
	ASM_PATCH_MSG="${GREEN} PASS =>$NORM    ASM home has same number of patches installed across the cluster."
	asm_patch_check_status=1
    elif [  -f $OUTPUTDIR/o_asm_patchlist_${h_patch}.out ]
    then
	ASM_PATCH_MSG="${RED} FAIL =>$NORM    ASM home does not have same number of patches installed across the cluster."
	asm_patch_check_status=0
    fi
fi
#following code is to check clustewide checks
#echo "stack_counter=$stack_counter clusterware_check_count=$clusterware_check_count clusterware_check_count_old=$clusterware_check_count_old"

#read -p "stack_counter=$stack_counter ${cls_check_host_list[*]} ${cls_check_host_list[0]} and ${cls_check_host_list[1]}"
#To set clusterware_check_count value from a compute node if last node was a control VM.
if [[ $clusterware_check_count -ne $clusterware_check_count_old && $clusterware_check_count_old -gt 0 ]]; then clusterware_check_count=$clusterware_check_count_old;fi
#read -p "clusterware_check_count=$clusterware_check_count clusterware_check_count_old=$clusterware_check_count_old"
if [[ $SILENT -eq 0 && $clusterware_check_count -ge 1 ]]
then
    echo -e "\n"|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
    echo $fmt_line_header|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
    echo "                      CLUSTERWIDE CHECKS"|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
    echo $fmt_line_header|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
fi
crs_stack_counter=$clusterware_check_count
C_ACTUAL=${OUTPUTDIR}/c_actual.out
crs_check_file_counter=0
COMTYPE="CLUSTERWIDE_CHECK"
if [ -f $C_ACTUAL ]; then rm $C_ACTUAL; fi;
#read -p "crs_stack_counter=$crs_stack_counter and array =${crs_check_id[*]} SILENT=$SILENT"

while [[ $crs_stack_counter -gt 0 && $SILENT -eq 0 ]]
do 
   CLUSTERCHECK_FIL=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}.out
   cls_no_of_nodes=$(cat ${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}.out|wc -l)
   #HOSTLIST=${OUTPUTDIR}/o_host_list.out
   #read -p " ls -l $CLUSTERCHECK_FIL"
   COMTYPE=$(grep "_"${crs_check_id[$crs_check_file_counter]}"-TYPE" $REFFIL |awk {'print $2'})
   crs_check_counter=0
   unset cls_check_val1
   unset cls_check_val2
   unset no_of_cells
   unset cell_stack_counter
  # following branch is to handle system wide check where we need to include storage server also to compare some value across nodes
   if [ "$COMTYPE" = "CLUSTERWIDE_CHECK" ]
   then
        crs_host_counter=$stack_counter
   else 
     if [[ -n "$skip_in_silent" && $skip_in_silent -eq "0" ]]
     then
        no_of_cells=$(cat $CELLIP|grep "cell="|grep -v ^#|wc -l|tr -d ' ')
        if [ -e $CELLDIR/cells.out ] ;then crs_host_counter=$(expr $stack_counter + $no_of_cells );else crs_host_counter=$stack_counter;fi
        cell_stack_counter=$stack_counter
        for cls_cell_host in $(if [ -e $CELLDIR/cells.out ] ;then cat $CELLDIR/cells.out|awk '{print $3}';fi) 
        do
           cls_check_host_list[$cell_stack_counter]=$cls_cell_host
           cell_stack_counter=$(expr $cell_stack_counter + 1 )
        done
     else # No cells in -s or -S
       no_of_cells=0
     fi
   fi
   SOURCEFIL_REPORT=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}_report.out
   if [ $OFFLINE -eq 0 ]
   then
       SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${crs_check_id[$crs_check_file_counter]}_report.out 
   else
       SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${crs_check_id[$crs_check_file_counter]}_report.out 
   fi
   while [ $crs_host_counter -gt 0 ] 
   do
     #read -p "hostname=${cls_check_host_list[$crs_check_counter]}"
     ROW=$(cat $CLUSTERCHECK_FIL|head -1|awk '{print $2}')
     #read -p "crs_check_counter=$crs_check_counter and crs_host_counter=$crs_host_counter"
     cls_host_exists=$(grep -ic "${cls_check_host_list[$crs_check_counter]}" $CLUSTERCHECK_FIL)
     if [[ -n "$cls_host_exists" && $cls_host_exists -ge 1 && -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]
     then
	 if [ -z "$cls_check_val1" ]
	 then
	     cls_check_val1=$(grep "${cls_check_host_list[$crs_check_counter]} $ROW" $CLUSTERCHECK_FIL|sed  -n 's/.*== //p')
	 else
	     cls_check_val2=$(grep "${cls_check_host_list[$crs_check_counter]} $ROW" $CLUSTERCHECK_FIL|sed  -n 's/.*== //p')
             # this is the fix to overcome the issue of having empty value for some nodes
             if [ -z "$cls_check_val2" ]; then cls_check_val2=$cls_check_val1;fi
	     if [ $RAT_DEBUG -eq 1 ]
	     then
		 if [[ -n "${cls_check_val1}" && -n "${cls_check_val2}" ]] && [ "${cls_check_val1}" = "${cls_check_val2}" ] 2>>$ERRFIL
		 then
		     CRS_VAL=1
		 else
		     CRS_VAL=0
		     break
		 fi 
	     else
		 if [[ -n "${cls_check_val1}" && -n "${cls_check_val2}" ]] && [ "${cls_check_val1}" = "${cls_check_val2}" ]
		 then
		     CRS_VAL=1
		 else
		     CRS_VAL=0
		     break
		 fi
	     fi
	     #read -p "${cls_check_host_list[$crs_check_counter]} $ROW"
	 fi
     fi
     crs_check_counter=$(expr $crs_check_counter + 1 )
     crs_host_counter=$(expr $crs_host_counter - 1 )
     #read -p "crs_check_counter=$crs_check_counter and crs_host_counter=$crs_host_counter $cls_host_exists for ${crs_check_id[$crs_check_file_counter]}"
   done
   #if [[ -f $C_ACTUAL && `cat $C_ACTUAL|wc -l` -ge 1 ]]
   #then
  # else
  #     echo "${crs_check_id[$crs_check_file_counter]}|$CRS_VAL" > $C_ACTUAL
  # fi
   if [ $op_mode -eq 0 ]
   then 
       PMSG=`grep "_"$ROW"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
       FMSG=`grep "_"$ROW"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
       SF=`grep "_"$ROW"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
       CAT=`grep "_"$ROW"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
       SUBCAT=`grep "_"$ROW"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
       ALVL=`grep _$ROW\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
       audit_check_name=`grep "_"$ROW"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
       NEEDS_RUNNING=`grep "_"$ROW"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'` 
       ISBRANCH=`grep _$ROW\-IS_BRANCH $REFFIL |awk {'print $2'} `
   else
       PMSG=`grep "_"${crs_check_id[$crs_check_file_counter]}"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
       FMSG=`grep "_"${crs_check_id[$crs_check_file_counter]}"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
       SF=`grep "_"${crs_check_id[$crs_check_file_counter]}"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
       check_components=`grep "_"${crs_check_id[$crs_check_file_counter]}"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
       CAT=`grep "_"${crs_check_id[$crs_check_file_counter]}"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
       SUBCAT=`grep "_"${crs_check_id[$crs_check_file_counter]}"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
       ALVL=`grep _${crs_check_id[$crs_check_file_counter]}\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
       audit_check_name=`grep "_"${crs_check_id[$crs_check_file_counter]}"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
       NEEDS_RUNNING=`grep "_"${crs_check_id[$crs_check_file_counter]}"-NEEDS_RUNNING" $REFFIL|sed  -n 's/.*NEEDS_RUNNING //p'`  
       ISBRANCH=`grep _"${crs_check_id[$crs_check_file_counter]}-IS_BRANCH" $REFFIL |awk {'print $2'}`
   fi
   ALVL_CHECK=$ALVL
   audit_check_name=`echo $audit_check_name | sed 's/^ *\(.*\) *$/\1/'`
   if [ "$COMTYPE" = "SYSTEMWIDE_CHECK" ]; then COMTYPE=CLUSTERWIDE_CHECK;fi
   if [[ -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]
   then
       if [[ $ALVL = "INFO" && $CRS_VAL -eq 1 ]]; then write_info_actual_files=0; else  write_info_actual_files=1;fi
       if [ $write_info_actual_files -eq 1 ]; then echo "${crs_check_id[$crs_check_file_counter]}|$CRS_VAL" >> $C_ACTUAL;fi 
   fi
   #following code is create report file if clusterwide check fails
   if [[ -n "$CRS_VAL" && $OFFLINE -eq 0 ]] 
     then
         while read cwc_line_report
         do 
            unset cwc_line_report_output
            cwc_line_report_output=$(echo $cwc_line_report|awk '{print $1}')
            cwc_line_report_output=$(echo $cwc_line_report_output = $(echo $cwc_line_report|sed  -n 's/.*== //p')) 
            echo $cwc_line_report_output>>$SOURCEFIL_REPORT
         done<$CLUSTERCHECK_FIL
   fi
   #read -p "audit_check_name=$audit_check_name"
   #add if condition for get_log_result to not to  execute if no of nodes are not greater than 1 in clusterwide check
   if [[ -n "$cls_no_of_nodes" && $cls_no_of_nodes -gt 1 ]]; then  get_log_result;fi 
   crs_stack_counter=`expr $crs_stack_counter - 1`
   crs_check_file_counter=`expr $crs_check_file_counter + 1`
done
crs_stack_counter=0
#reassiging i back to localnode to process cross node checks other wise it goes to remote node in copy_env_file function
i=$localnode

#Following code is to process CROSS_NODE_CHECKS
#counter has been increased after adding last item in arrary. -1 to bring it back to last item
cross_node_checkids_counter=$(expr $cross_node_checkids_counter - 1 )

while [[ $process_cross_node_checks -eq 1 && $cross_node_checkids_counter -ge 0 ]]
do
  COMTYPE=CLUSTERWIDE_CHECK 
  CHECK_ID=${cross_node_checkids[$cross_node_checkids_counter]}
  crs_check_id[$crs_check_file_counter]=$CHECK_ID 
  PARAM_PATH=`grep _$CHECK_ID\-PARAM_PATH $REFFIL |awk {'print $2'}`
  HOME_PATH=`grep _$CHECK_ID\-HOME_PATH $REFFIL |awk {'print $2'}`
  ISBRANCH=`grep _$CHECK_ID\-IS_BRANCH $REFFIL |awk {'print $2'} `
  PARAM=`grep "_"$CHECK_ID"-PARAM_PATH" $REFFIL |sed  -n 's/.*PARAM_PATH //p'`
  NEEDS_RUNNING=`grep "_"$CHECK_ID"-NEEDS_RUNNING" $REFFIL |sed  -n 's/.*NEEDS_RUNNING //p'| sed 's/^ *\(.*\) *$/\1/'`
  execute_once=`grep "_"$CHECK_ID"-EXECUTE_ONCE" $REFFIL |sed  -n 's/.*EXECUTE_ONCE //p'| sed 's/^ *\(.*\) *$/\1/'`
  check_exadata_version=$(grep "_"$CHECK_ID"-EXADATA_VERSION" $REFFIL |sed  -n 's/.*EXADATA_VERSION //p'| sed 's/^ *\(.*\) *$/\1/')
  check_database_role=$(grep "_"$CHECK_ID"-DATABASE_ROLE" $REFFIL |sed  -n 's/.*DATABASE_ROLE //p'| sed 's/^ *\(.*\) *$/\1/')
  check_database_type=$(grep "_"$CHECK_ID"-DATABASE_TYPE" $REFFIL |sed  -n 's/.*DATABASE_TYPE //p'| sed 's/^ *\(.*\) *$/\1/')
  check_database_mode=$(grep "_"$CHECK_ID"-DATABASE_MODE" $REFFIL |sed  -n 's/.*DATABASE_MODE //p'| sed 's/^ *\(.*\) *$/\1/')
  SF=`grep "_"$CHECK_ID"-SF" $REFFIL |sed  -n 's/.*-SF //p'`
  check_components=`grep "_"$CHECK_ID"-COMPONENTS" $REFFIL |sed  -n 's/.*COMPONENTS //p'| sed 's/^ *\(.*\) *$/\1/'`
  OP=`grep _$CHECK_ID\-OPERATOR $REFFIL |sed  -n 's/.*OPERATOR //p'`
  if [[ -z "$OP" && -e $REFFIL1 ]];then OP=`grep _$CHECK_ID\-OPERATOR $REFFIL1 |sed  -n 's/.*OPERATOR //p'`;fi
  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL |sed  -n 's/.*COMPARE_VALUE //p'`
  COM=`grep "_"$CHECK_ID"-CROSS_NODE_CHECK_COMMAND" $REFFIL |sed  -n 's/.*CROSS_NODE_CHECK_COMMAND //p'`
  COM_REPORT=`grep "_"$CHECK_ID"-CROSS_NODE_CHECK_COMMAND_REPORT" $REFFIL |sed  -n 's/.*CROSS_NODE_CHECK_COMMAND_REPORT //p'`
  audit_check_name=`grep "_"$CHECK_ID"-AUDIT_CHECK_NAME" $REFFIL |sed  -n 's/.*AUDIT_CHECK_NAME//p'`
  if [[ -z "$COMP" && -e $REFFIL1 ]];then  COMP=`grep "_"$CHECK_ID"-COMPARE_VALUE" $REFFIL1 |sed  -n 's/.*COMPARE_VALUE //p'`;fi
  if [ $SILENT -eq "0" ]
  then
      ALVL=`grep _$CHECK_ID\-ALERT_LEVEL $REFFIL1 |awk {'print $2'}`
      PMSG=`grep "_"$CHECK_ID"-PASS_MSG" $REFFIL1 |sed  -n 's/.*PASS_MSG //p'`
      FMSG=`grep "_"$CHECK_ID"-FAIL_MSG" $REFFIL1 |sed  -n 's/.*FAIL_MSG //p'`
      CAT=`grep "_"$CHECK_ID"-CAT" $REFFIL1 |sed  -n 's/.*-CAT //p'`
      SUBCAT=`grep "_"$CHECK_ID"-SUBCAT" $REFFIL1 |sed  -n 's/.*-SUBCAT //p'`
      ALVL_CHECK=$ALVL
  fi
  
  if [ $OFFLINE -eq 0 ]; then echo -e "start time - `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING;fi
  copy_env_files_to_tmp
  localcmd=/tmp/localcmd.sh
  echo "#!$bash_scr" >$localcmd
  echo "$bash_source" >>$localcmd
  echo ". $TRGTORCLENV">>$localcmd
  if [ -n "$COM_REPORT" ]
  then
      echo -e "TO REVIEW COLLECTED DATA FROM $(echo $i|tr "[a-z]" "[A-Z]") - $(echo $audit_check_name|tr "[a-z]" "[A-Z]") \n\n\n" >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
  fi
  chmod 755 $localcmd
  echo "$COM 2>>$ERRFIL">>$localcmd
  if [ -n "$COM_REPORT" ]; then echo "$COM_REPORT >>${OUTPUTDIR}/${CHECK_ID}_${i}_report.out 2>>$ERRFIL">>$localcmd;fi
  FILVAL=`$localcmd 2>>$ERRFIL`
  if [ -e $localcmd ]; then rm $localcmd; fi; 
  #echo "" >>$OSSPOOLFIL
  #printf "%s %s %s %s %s\n" " $PARAM_PATH $CHECK_ID $COM == $FILVAL" >>$OSSPOOLFIL
  #VAL=`grep "$PARAM_PATH $ROW " $OSSPOOLFIL|sed  -n 's/.*== //p'`
  VAL=$FILVAL
  if [ -n "$COM_REPORT" ]
  then
       SOURCEFIL_REPORT=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
       if [ $OFFLINE -eq 0 ]
       then
	   SOURCEFIL_REPORT_NEW=${OUTPUTDIR_NEW}/${CHECK_ID}_${i}_report.out
       else
	   SOURCEFIL_REPORT_NEW=${OUTPUTDIR}/${CHECK_ID}_${i}_report.out
       fi
  fi  
  cross_node_get_log_result_call=1
  get_log_result
  if [ $OFFLINE -eq 0 ]; then echo -e "end time -  `date '+%a %b %d %H:%M:%S %Y'` - $audit_check_name on ${i}\n">>$CHECKS_TIMING;fi
  cross_node_checkids_counter=$(expr $cross_node_checkids_counter - 1 )
  crs_check_file_counter=$(expr $crs_check_file_counter + 1) 
done
crs_check_file_counter=0
#read -p "stop after corss node processing"
###CROSS_NODE_CHECK processing ends here

if [ $SILENT -eq 0 ]
then
    if [[ -n "$CRS_PATCH_MSG" && -n "$crs_patch_check_status" ]] && [[ "$TYP" != "-p" ]] && [[ $print_pass_on_screen -eq 1 || $crs_patch_check_status -eq 0 ]]; then echo -e "$CRS_PATCH_MSG";fi; 
    mb_db_counter=0
    for mb_db_homes in ${mb_oracle_homes_distinct[@]}
    do 
       if [[ -n "${MB_RDBMS_PATCH_MSG[$mb_db_counter]}" && -n "${mb_rdbms_patch_check_status[$mb_db_counter]}" ]] && [[ "$TYP" != "-p" ]] && [[ $print_pass_on_screen -eq 1 || ${mb_rdbms_patch_check_status[$mb_db_counter]} -eq 0 ]]; then echo -e "${MB_RDBMS_PATCH_MSG[$mb_db_counter]}";fi;
       mb_db_counter=$(expr $mb_db_counter + 1)
    done
    mb_db_counter=0
    if [[ -n "$ASM_PATCH_MSG" && -n "$asm_patch_check_status" ]] && [[ "$TYP" != "-p" ]] && [[ $print_pass_on_screen -eq 1 || $asm_patch_check_status -eq 0 ]]; then echo -e "$ASM_PATCH_MSG";fi; 
 
    if [ -n "$crs_patch_check_status" ] && [[ "$TYP" != "-p" ]]
    then
       if [ $crs_patch_check_status -eq 1 ]
       then
           echo "Check:- PASS => CRS home has same number of patches installed across the cluster">>$CWCREPFIL_PASS   
           echo "Check:- PASS => CRS home has same number of patches installed across the cluster">>$SCWCREPFIL_PASS
           echo "Check:- PASS => CRS home has same number of patches installed across the cluster">>$MISCCWCHECK
           if [[ $CREATE_HTML_REPORT -eq 1 ]]
           then # gadiga - for html reporting
             write_cwc_status_html "PASS" "CRS home has same number of patches installed across the cluster";
           fi
       else 
           echo "Check:- FAIL => CRS home does not have same number of patches installed across the cluster">>$CWCREPFIL_FAIL
           echo "Check:- FAIL => CRS home does not  have same number of patches installed across the cluster">>$SCWCREPFIL_FAIL
           echo "Check:- FAIL => CRS home does not have same number of patches installed across the cluster">>$MISCCWCHECK
           if [[ $CREATE_HTML_REPORT -eq 1 ]]
           then # gadiga - for html reporting
             write_cwc_status_html "FAIL" "CRS home does not have same number of patches installed across the cluster"
           fi
       fi
    fi
    if [[ "$TYP" != "-p" ]]
    then
	mb_db_counter=0
	for mb_db_homes in ${mb_oracle_homes_distinct[@]}
	do
	   if [ -n "${mb_rdbms_patch_check_status[$mb_db_counter]}" ]
	   then
	       if [ ${mb_rdbms_patch_check_status[$mb_db_counter]} -eq 1 ]
	       then
		   echo "Check:- PASS => RDBMS home ${mb_db_homes} has same number of patches installed across the cluster">>$CWCREPFIL_PASS
		   echo "Check:- PASS => RDBMS home ${mb_db_homes} has same number of patches installed across the cluster">>$SCWCREPFIL_PASS
		   echo "Check:- PASS => RDBMS home ${mb_db_homes} has same number of patches installed across the cluster">>$MISCCWCHECK
                   if [[ $CREATE_HTML_REPORT -eq 1 ]]
                   then # gadiga - for html reporting
                     write_cwc_status_html "PASS" "RDBMS home ${mb_db_homes} has same number of patches installed across the cluster"
                   fi
	       else
		   echo "Check:- FAIL => RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster">>$CWCREPFIL_FAIL 
		   echo "Check:- FAIL => RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster">>$SCWCREPFIL_FAIL 
		   echo "Check:- FAIL => RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster">>$MISCCWCHECK 
                   if [[ $CREATE_HTML_REPORT -eq 1 ]]
                   then # gadiga - for html reporting
                     write_cwc_status_html "FAIL" "RDBMS home ${mb_db_homes} does not have same number of patches installed across the cluster"
                   fi
	       fi
	   fi
	  mb_db_counter=$(expr $mb_db_counter + 1)
	done
	mb_db_counter=0
    fi
    if [ -n "$asm_patch_check_status" ] && [[ "$TYP" != "-p" ]]
    then
        if [ $asm_patch_check_status -eq 1 ]
        then
            echo "Check:- PASS => ASM home has same number of patches installed across the cluster">>$CWCREPFIL_PASS
            echo "Check:- PASS => ASM home has same number of patches installed across the cluster">>$SCWCREPFIL_PASS
            echo "Check:- PASS => ASM home has same number of patches installed across the cluster">>$MISCCWCHECK
            if [[ $CREATE_HTML_REPORT -eq 1 ]]
            then # gadiga - for html reporting
              write_cwc_status_html "PASS" "ASM home has same number of patches installed across the cluster"
            fi
        else 
            echo "Check:- FAIL => ASM home does not have same number of patches installed across the cluster">>$CWCREPFIL_FAIL
            echo "Check:- FAIL => ASM home does not have same number of patches installed across the cluster">>$SCWCREPFIL_FAIL
            echo "Check:- FAIL => ASM home does not have same number of patches installed across the cluster">>$MISCCWCHECK
            if [[ $CREATE_HTML_REPORT -eq 1 ]]
            then # gadiga - for html reporting
              write_cwc_status_html "FAIL" "ASM home does not have same number of patches installed across the cluster"
            fi
        fi
    fi
    #MISCCWCHECK=$OUTPUTDIR/o_misc_clusterwide_checks.out
    if [ -z "$platform" ]; then platform=$(uname -s);fi;
    CWSQLPARAM=$OUTPUTDIR/${program_name}_cw_sqlparam.out
    CWOSPARAM=$OUTPUTDIR/${program_name}_cw_osparam.out
    CWOSPKG=$OUTPUTDIR/${program_name}_cw_ospkg.out
    CWOSPATCH=$OUTPUTDIR/${program_name}_cw_ospatch.out
    echo $fmt_line_header|tee -a $LOGFIL|tee -a $CWCREPFIL_PASS|tee -a $SCWCREPFIL_PASS|tee -a $CWCREPFIL_FAIL| tee -a $SCWCREPFIL_FAIL
fi
####
if [ -z $ent_naming ]; then ent_naming=$localnode; else ent_naming=$DB; fi;
#----------------------------------------------------------------------
#Added by kumar
if [[ $OFFLINE -eq 0 && $SILENT -eq 0 ]]
then
 upload_outfil=$OUTPUTDIR/upload_${program_name}_result.lst
 upload_patch_outfil=$OUTPUTDIR/upload_${program_name}_patch_result.lst
 if [ "$TYP" != "-p" ]
 then   
    insert_data_into_table "$RAT_UPLOAD_TABLE" "$upload_raccheck_result_fil" "$upload_outfil"
    if [ $data_upload_status -eq 2 ] 
    then
       echo -e $RED"${program_name} was not able to make successfull connection to database to upload result.\nPlease run ${OUTPUTDIR_NEW}/upload_${program_name}_result.sql script manually to upload result to database\n$NORM"|tee -a $LOGFIL    
    elif [ $data_upload_status -eq 3 ]
    then
       echo -e $RED"$upload_error insert statement have failed from ${OUTPUTDIR_NEW}/upload_${program_name}_result.sql. please see the $OUTPUTDIR_NEW/upload_${program_name}_result.lst and fix those errors manually\n$NORM"|tee -a $LOGFIL
    fi 
 fi
 if [[ -n "$data_upload_status" && $data_upload_status -ne 2 ]]
 then
    if [[ "$TYP" = "-a" || "$TYP" = "-s" || "$TYP" = "-S" || "$TYP" = "-p" || "$TYP" = "-u" ]]
    then  
       insert_data_into_table "$RAT_PATCH_UPLOAD_TABLE" "$upload_raccheck_patch_result_fil" "$upload_patch_outfil"
       if [ $data_upload_status -eq 2 ] 
       then         
          echo -e $RED"${program_name} was not able to make successfull connection to database to upload result.\nPlease run ${OUTPUTDIR_NEW}/upload_${program_name}_patch_result.sql script manually to upload result to database\n$NORM"|tee -a $LOGFIL    
       elif [ $data_upload_status -eq 3 ]
       then
          echo -e $RED"$upload_error insert statement have failed from ${OUTPUTDIR_NEW}/upload_${program_name}_patch_result.sql. please see the $OUTPUTDIR_NEW/upload_${program_name}_patch_result.lst and fix those errors manually\n$NORM"|tee -a $LOGFIL
       fi 
    fi
 fi
 echo -e ${GREEN}"${upload_pass_msg} $upload_pass_msg2"${NORM}
fi
#----------------------------------------------------------------------

#
##to delete ssh configuration
if [[ $OFFLINE -eq 0 && 1 -eq 2 ]]
then 
   arr=`expr $arr - 1`
   while [[ -n $arr && $arr -ge 0 ]]
   do
     if [ $i = $localnode ]
     then
         rm -rf ~/.ssh 2>/dev/null
     else
         ssh ${hnameArr[$arr]} rm -rf ~/.ssh 
     fi
   arr=`expr $arr - 1`
   done
fi

for i in `cat $HOSTLIST`
do
  if [ $i = $localnode ]
  then
    rm $TRGTORCLENV 2>/dev/null
    rm /tmp/raccheck_env.out 2>/dev/null
  elif [ $OFFLINE -eq 0 ]
  then
    $SSHELL $i "rm $TRGTORCLENV" 2>/dev/null
    $SSHELL $i "rm /tmp/raccheck_env.out" 2>/dev/null
  fi
done

#To copy EXCLUDEFIL to OUTPUTDIR
if [ -e $EXCLUDEFIL ]; then cp $EXCLUDEFIL $OUTPUTDIR;fi;
if [ -e $WRKDIR/cgrep ]; then rm $WRKDIR/cgrep >/dev/null 2>&1;fi;
if [[ $OFFLINE -eq 0 && -n "$OUTPUTDIR_NEW" ]]
then
    mv $OUTPUTDIR $OUTPUTDIR_NEW 2>>$ERRFIL
    OUTPUTDIR=$OUTPUTDIR_NEW
    ERRFIL=$OUTPUTDIR/${program_name}_error.log
    LOGFIL=$OUTPUTDIR/${program_name}.log
    SKIPFIL=$OUTPUTDIR/${program_name}_skipped_checks.log
    REPFIL=$OUTPUTDIR/${program_name}.rep
    XMLREPFIL=$OUTPUTDIR/${program_name}_results.xml
    XMLSKIPFIL=$OUTPUTDIR/${program_name}_exceptions.xml
    SREPFIL=$OUTPUTDIR/${program_name}_summary.rep
    REPFIL_PASS=$OUTPUTDIR/${program_name}_pass.rep
    REPFIL_FAIL=$OUTPUTDIR/${program_name}_fail.rep
    SREPFIL_PASS=$OUTPUTDIR/${program_name}_summary_pass.rep
    SREPFIL_FAIL=$OUTPUTDIR/${program_name}_summary_fail.rep
    PREPFIL=$OUTPUTDIR/${program_name}_patches.rep
    PSREPFIL=$OUTPUTDIR/${program_name}_patches_summary.rep
    CWCREPFIL=$OUTPUTDIR/${program_name}_cwc.rep
    SCWCREPFIL=$OUTPUTDIR/${program_name}_cwc_summary.rep
    CWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_pass.rep
    SCWCREPFIL_PASS=$OUTPUTDIR/${program_name}_cwc_summary_pass.rep
    CWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_fail.rep
    SCWCREPFIL_FAIL=$OUTPUTDIR/${program_name}_cwc_summary_fail.rep
    CELLSREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_summary_pass.rep
    CELLSREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells_summary_fail.rep
    CELLREPFIL_PASS=$OUTPUTDIR/${program_name}_cells_pass.rep
    CELLREPFIL_FAIL=$OUTPUTDIR/${program_name}_cells__fail.rep
    IBSREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_summary_pass.rep
    IBSREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib_summary_fail.rep
    IBREPFIL_PASS=$OUTPUTDIR/${program_name}_ib_pass.rep
    IBREPFIL_FAIL=$OUTPUTDIR/${program_name}_ib__fail.rep
    COLLECT_TIMING=$OUTPUTDIR/${program_name}_collection_timings.out
    CHECKS_TIMING=$OUTPUTDIR/${program_name}_checks_timings.out
    RACCHECK_TIMING=$OUTPUTDIR/${program_name}_timings.out
    HOSTLIST=$OUTPUTDIR/o_host_list.out
    MISCCWCHECK=$OUTPUTDIR/clusterwide_patch_compare.out 
    MASTERFIL=$OUTPUTDIR/raccheck_env.out
    CELLDIR="$OUTPUTDIR/.CELLDIR"
fi
if [ $SILENT -ne 1 ]
then
    if [[ -e $SKIPFIL && `cat $SKIPFIL|wc -l` -gt 4 ]]
    then
         
        echo -e "$fmt_line_header\n">>$SREPFIL
        echo -e "Some checks were skipped. Please review $SKIPFIL for more detail\n">>$SREPFIL
        echo -e "$fmt_line_header\n\n">>$SREPFIL
        echo -e "$fmt_line_header\n">>$REPFIL
        echo -e "Some checks were skipped. Please review $SKIPFIL for more detail\n">>$REPFIL
        echo -e "$fmt_line_header\n\n">>$REPFIL
    fi 
    if [ -f $SCWCREPFIL_FAIL  ]
    then 
        if [ `cat $SCWCREPFIL_FAIL|wc -l` -gt 6 ]; then cat $SCWCREPFIL_FAIL >>$SREPFIL; fi;
    fi
    if [ -f $SREPFIL_FAIL ]
    then
         if [ `cat $SREPFIL_FAIL|wc -l` -gt 6 ]; then  cat $SREPFIL_FAIL >>$SREPFIL; fi;
    fi
    if [ -f $CELLSREPFIL_FAIL ]; then  cat $CELLSREPFIL_FAIL >>$SREPFIL;fi   
    if [ -f $IBSREPFIL_FAIL ]; then  cat $IBSREPFIL_FAIL >>$SREPFIL;fi   
    if [ -f $SCWCREPFIL_PASS ] 
    then 
        if [ `cat $SCWCREPFIL_PASS|wc -l` -gt 6 ]; then cat $SCWCREPFIL_PASS >>$SREPFIL ;fi;
    fi
    if [ -f $SREPFIL_PASS ] 
    then 
        if [ `cat $SREPFIL_PASS|wc -l` -gt 6 ]; then cat $SREPFIL_PASS >>$SREPFIL ;fi;
    fi
    if [ -f $CELLSREPFIL_PASS ]; then  cat $CELLSREPFIL_PASS >>$SREPFIL;fi   
    if [ -f $IBSREPFIL_PASS ]; then  cat $IBSREPFIL_PASS >>$SREPFIL;fi   
    if [ -f $PSREPFIL ];     then cat $PSREPFIL >>$SREPFIL;fi;
    if [ -f $CWCREPFIL_FAIL ]
    then 
        if [ `cat $CWCREPFIL_FAIL|wc -l` -gt 6 ]; then cat $CWCREPFIL_FAIL>>$REPFIL; fi;
    fi
    if [ -f $REPFIL_FAIL ] 
    then 
        if [ `cat $REPFIL_FAIL|wc -l` -gt 6 ]; then cat $REPFIL_FAIL >>$REPFIL; fi;
    fi
    if [ -f $CELLREPFIL_FAIL ]; then  cat $CELLREPFIL_FAIL >>$REPFIL;fi   
    if [ -f $IBREPFIL_FAIL ]; then  cat $IBREPFIL_FAIL >>$REPFIL;fi   
    if [ -f $CWCREPFIL_PASS ]
    then 
        if [ `cat $CWCREPFIL_PASS|wc -l` -gt 6 ]; then cat $CWCREPFIL_PASS >>$REPFIL; fi;
    fi
    if [ -f $REPFIL_PASS ]
    then
        if [ `cat $REPFIL_PASS|wc -l` -gt 6 ]; then cat $REPFIL_PASS >>$REPFIL; fi;
    fi
    if [ -f $CELLREPFIL_PASS ]; then  cat $CELLREPFIL_PASS >>$REPFIL;fi   
    if [ -f $IBREPFIL_PASS ]; then  cat $IBREPFIL_PASS >>$REPFIL;fi   
    if [ -f $PREPFIL ];     then cat $PREPFIL >>$REPFIL;fi;
    echo "Detailed report is $REPFIL">>$SREPFIL
    if [ $OFFLINE -eq 0 ]
    then
        echo "Log file is at $LOGFIL">>$REPFIL
    fi
    #SREPFIL=$OUTPUTDIR/raccheck_summary.rep 
    #REPFIL=$OUTPUTDIR/raccheck.rep 
    #echo  "Summary report  - $SREPFIL"
    #echo  "Detailed report  - $REPFIL"
fi

#call function to generate exadata version report
if [[ $OFFLINE -eq 0 &&  -n "$db_machine_compute" && $db_machine_compute -eq 1 ]] || [[ -n "$is_exalytics_machine" && $is_exalytics_machine -eq 1 ]] || [[ -n "$is_exalogic_machine" && $is_exalogic_machine -eq 1 ]]
then
    generate_exadata_report
fi


# gadiga
# Create rachcehck.html file
if [[ $CREATE_HTML_REPORT -eq 1 ]]
then
  create_raccheck_html
fi

########
if [ $SILENT -eq "1" ]
then
    if [ -f $REPFIL ]; then rm $REPFIL;fi;
    if [ -f $SREPFIL ]; then rm $SREPFIL; fi;
    if [ -f $SCWCREPFIL_FAIL  ]; then rm $SCWCREPFIL_FAIL; fi;
    if [ -f $SREPFIL_FAIL ]; then rm $SREPFIL_FAIL; fi;
    if [ -f $SCWCREPFIL_PASS ]; then rm $SCWCREPFIL_PASS; fi;
    if [ -f $SREPFIL_PASS ]; then rm $SREPFIL_PASS; fi;
    if [ -f $CWCREPFIL_FAIL ]; then rm $CWCREPFIL_FAIL; fi;
    if [ -f $REPFIL_FAIL ]; then rm $REPFIL_FAIL; fi;
    if [ -f $CWCREPFIL_PASS ]; then rm $CWCREPFIL_PASS; fi;
    if [ -f $REPFIL_PASS ]; then rm $REPFIL_PASS; fi;
    if [ -f $CELLSREPFIL_PASS ]; then rm $CELLSREPFIL_PASS;fi
    if [ -f $CELLSREPFIL_FAIL ]; then rm $CELLSREPFIL_FAIL;fi
    if [ -f $CELLREPFIL_PASS ]; then rm $CELLREPFIL_PASS;fi
    if [ -f $CELLREPFIL_FAIL ]; then rm $CELLREPFIL_FAIL;fi
    if [ -f $IBSREPFIL_PASS ]; then rm $IBSREPFIL_PASS;fi
    if [ -f $IBSREPFIL_FAIL ]; then rm $IBSREPFIL_FAIL;fi
    if [ -f $IBREPFIL_PASS ]; then rm $IBREPFIL_PASS;fi
    if [ -f $IBREPFIL_FAIL ]; then rm $IBREPFIL_FAIL;fi

else
     #To delete ^M from report file
    if [ $OFFLINE -eq 0 ]
    then
       sed  's///g' $REPFIL >$INPUTDIR/${program_name}.rep 
       cp $INPUTDIR/${program_name}.rep $REPFIL
       rm $INPUTDIR/${program_name}.rep
       #echo  "Summary report  - $SREPFIL"
       #echo  "Detailed report (txt) - $REPFIL"
       if [ -e "${HTML_REPFILE}" ]
       then 
         echo "Detailed report (html) - ${HTML_REPFILE}"
       fi 
       #if [ -e $OUTPUTDIR/${program_name}_versions.html ]; then echo  "Exadata version report  - $OUTPUTDIR/${program_name}_versions.html";fi  
    else
       sed  's///g' $REPFIL >/tmp/${program_name}.rep 
       cp /tmp/${program_name}.rep $REPFIL
       rm /tmp/${program_name}.rep
       if [ -e $DUMPDIR/collections.dat  ]; then rm $DUMPDIR/collections.dat; fi;
       if [ -e $DUMPDIR/collections_new.dat  ]; then rm $DUMPDIR/collections_new.dat; fi;
       if [ -e $DUMPDIR/rules.dat  ]; then rm $DUMPDIR/rules.dat; fi;
       if [ -e $DUMPDIR/rules_new.dat  ]; then rm $DUMPDIR/rules_new.dat; fi;
       #echo  "Summary report  - $DUMPDIR/${program_name}_summary.rep"
       #echo  "Detailed report (txt) - $DUMPDIR/${program_name}.rep"
       if [ -e "${HTML_REPFILE}" ]
       then 
         echo "Detailed report (html) - ${HTML_REPFILE}"
       fi 
       #if [ -e $DUMPDIR/${program_name}_versions.html ]; then echo  "Exadata version report  - $DUMPDIR/${program_name}_versions.html";fi  
    fi
    if [ -e $OUTPUTDIR/${program_name}.html ]
    then
      echo "Note: Use links (text mode browser) or your favorite browser to view the html report."
    fi

fi
#to change the name of raccheck_env.out to check_env.out
if [ $OFFLINE -eq 0 ]; then mv $MASTERFIL $OUTPUTDIR/check_env.out;elif [ $OFFLINE -eq 1 ]; then mv $DUMPDIR/raccheck_env.out $DUMPDIR/check_env.out;fi
if [ -e ${RTEMPDIR}/o_ibswitches.out ]; then cp ${RTEMPDIR}/o_ibswitches.out $OUTPUTDIR >/dev/null 2>&1; fi;

#This is where em plugin xml ends
 echo "</${xml_prefix1}Results>" >> $XMLREPFIL
 echo "</${xml_prefix2}Exclusions>" >> $XMLSKIPFIL
#

#call function to write xml file to remote nodes for CC12
if [[ $OFFLINE -eq 0 ]] && [[ -n "$db_machine_compute" && $db_machine_compute -eq 1 || $is_exalogic_machine -eq 1 ]]; then copy_em_xml_files_to_remote_nodes ;fi
#read -p "stop here for copy_em_xml_files_to_remote_nodes"

perl_exe=$(which perl)
if [ -n "$perl_exe" ] ; then
  # Create ${program_name}_browse_<FDS>.html
  $perl_exe $SCRIPTPATH/.cgrep/raw_data_browser.pl $OUTPUTDIR  >/dev/null 2>>$ERRFIL
fi
#Moved this finished before reorg
if [ $OFFLINE -eq 0 ]
then
    echo -e "`date '+%a %b %d %H:%M:%S %Y'` - ${program_name} execution finished\n">>$RACCHECK_TIMING
    echo $fmt_timing_lines >>$RACCHECK_TIMING
fi

reorg_output_dir

#To delete dat files in offline from output directory
if [[ $OFFLINE -eq 1 && `find $OUTPUTDIR -name '*.dat' -type f|wc -l` -gt 0 ]];then rm -f $OUTPUTDIR/*.dat >/dev/null 2>&1;fi

if [ $OFFLINE -eq 0 ]
then
    cd $OUTPUTDIR
    #read -p "OUTPUTDIR=$OUTPUTDIR"
    cd ..
    which zip >/dev/null 2>&1
    if [ `echo $?` -eq 0 ]
    then
        #zip -q "$UPLOADFIL".zip raccheck_$FDS/* 2>>$ERRFIL
        OUTPUTDIR_ZIP=$(basename $OUTPUTDIR)
        CELLDIR_ZIP=$(basename $CELLDIR)
        zip -qr "$UPLOADFIL".zip $OUTPUTDIR_ZIP/* $OUTPUTDIR_ZIP/$CELLDIR_ZIP/* 2>>$ERRFIL
        echo ""
        echo ""
        echo "UPLOAD(if required) - "$UPLOADFIL".zip"
    else
        OUTPUTDIR_ZIP=$(basename $OUTPUTDIR)
        tar -cf "$UPLOADFIL".tar.gz $OUTPUTDIR_ZIP/* 2>>$ERRFIL
        #if [ -f $"$UPLOADFIL".tar.gz ]; then rm "$UPLOADFIL".tar.gz >/dev/null;gzip -q "$UPLOADFIL".tar >/dev/null 2&>1; fi;
        echo ""
        echo ""
        echo "UPLOAD(if required) - "$UPLOADFIL".tar.gz"
    fi
else
    cd $OUTPUTDIR
    cd ..
    rm ${program_name}_${outfilefds1}_collect_${outfilefds2}_${outfilefds3}.zip 2>>$ERRFIL
    rm ${program_name}_${outfilefds1}_collect_${outfilefds3}_${outfilefds3}.tar.gz 2>>$ERRFIL
    which zip >/dev/null 2>&1
    if [ `echo $?` -eq 0 ]
    then
        CELLDIR_ZIP=$(basename $CELLDIR)
        zip -qr "$UPLOADFIL".zip ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/* ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/$CELLDIR_ZIP/* 2>>$ERRFIL
        echo ""
        echo ""
        echo "UPLOAD(if required) - "$UPLOADFIL".zip"
    else
        #read -p "UPLOADFIL=$UPLOADFIL ${outfilefds1} ${outfilefds2} ${outfilefds3}"
        tar -cf "$UPLOADFIL".tar.gz ${program_name}_${outfilefds1}_${outfilefds2}_${outfilefds3}/* 2>>$ERRFIL
        #if [ -f $"$UPLOADFIL".tar.gz ]; then rm "$UPLOADFIL".tar.gz >/dev/null 2&>1; gzip -q "$UPLOADFIL".tar >/dev/null 2&>1;fi;
        echo ""
        echo ""
        echo "UPLOAD(if required) - "$UPLOADFIL".tar.gz"
    fi     
fi
echo -e "\n"
echo -e "\n"
