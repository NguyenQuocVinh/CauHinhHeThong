script
printf("==========START_OF_AUDIT_CHECK_chkBackend.aksh==========\n");
//
// Name: chkBackend.aksh
// Author: Jim Stewart
//
// Usage: ssh user@appliance < chkBackend.aksh
//
// Purpose: Detect issues in the backend
//

	// To Enable Debug set to 1 to disable set 0
	var DEBUG = 0;

// Lots of Global Variables

	//Appliance Vars
	var hostname;
	var applianceVersion;
	var applianceVersionShort;

	//Shelf SIM Vars
	var simfwcompare = "NONE";

	//Data Disk Vars
	var diskfwcompare = "NONE";

	//Log Device Vars
	var logs; //List of Logs in a shelf
	var logfw,loglabel,logpaths;

	var founderrors = "false"; // This flag is set true if any error is found
	var auditcheck = 0;
	var report = 1;
//----------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
	try {
		prop = get(getProperty);
	} catch(err) {
		prop = 'ERROR';
	}
	return prop;
}

// ---------------------------------------------------------
// Get Hostname
function getHostname() {
	run('cd /');
	run('maintenance hardware select chassis-000'); 
	hostname=safeGet('name'); 
	run('cd /');
}

// ---------------------------------------------------------
// Get Appliance Version
function getApplianceVersion() {
	run('cd /');
	run('configuration version');
	applianceVersionShort = safeGet('version').split(',')[0].replace(/\./g,"");
	applianceVersion = safeGet('version');
	run('cd /');
}

// ----------------------------------------------------------------------------
// checkSIM() - Check the properties of a SIM
function checkSIM() {
	// Check to see if the sim is present
	if ( safeGet('present') ) {
		// Check to see if the sim is faulted
		simlabel = safeGet('label');
		if (safeGet('faulted')) {
			if ( report == 1) {
				printf("ERROR: %12s SHELF: %s SIM: %s REPORTS FAULTED\n",hostname,shelfserial,simlabel);
			}
			founderrors = 'true';
		} else {
			simfw = safeGet('revision');
	    	if ( simfwcompare == 'NONE' ) {
            	if ( simfw != 'ERROR') {
	            	simfwcompare = simfw;
            	} else {
               		founderrors='TRUE';
            	}
         	}
			if ( simfw != simfwcompare && simfwcompare != 'NONE' ) {
				if ( simfw == 'ERROR' ) {
					if ( report == 1) {
               			printf("ERROR: %12s SHELF: %s SIM: %s UNKNOWN STATE\n",hostname,shelfserial,simlabel);
					}
               		founderrors='TRUE';
            	} else {
					if ( report == 1) {
				   		printf("ERROR: %12s SHELF: %s SIM: %s FIRMWARE: %4s FIRMWARE MISMATCH: %4s on another SIM \n",hostname,shelfserial,simlabel,simfw,simfwcompare);
					}
               		founderrors='TRUE';
				}
			}
			if ( safeGet('part') == 'ERROR' ) {
				if ( report == 1) {
					printf("ERROR: %12s SHELF: %s SIM: %s UNKNOWN PART\n",hostname,shelfserial,simlabel);
				}
    	        founderrors='TRUE';
			}
		}
	} else {
		if ( report == 1) {
			printf("ERROR: %12s SHELF: %s SIM: %s NOT PRESENT\n",hostname,shelfserial,simlabel);
		}
		founderrors = 'true';
	}
}

// ---------------------------------------------------------
// checkStorageChassis() - Check things particular to a storage chassis
function checkStorageChassis(myChassis) {

	// Variables

   // Get back to a know starting state
   run('cd /');
   // Select the chassis
   run('maintenance hardware select ' + myChassis);

	shelfserial = safeGet('serial');

	// Get Slot0 Info
	run('select slot select slot-000');
	checkSIM();
	run('cd ../..');
	// Get Slot1 Info
	run('select slot select slot-001');
	checkSIM();

   // Get back to a know starting state
   run('cd /');

	return 0;
}

function checkSystemChassis(systemchassis) {
}

// ---------------------------------------------------------
// Check Data Disks
// 
// Precondition: State must have disk to be checked selected
//
function checkDataDisk(myChassis,myDisk) {

	diskfw = safeGet('revision'); 
	disklabel = safeGet('label');
	diskpaths = safeGet('pathcount');

	if ( diskpaths != 2 ) {
		founderrors='true';
		if ( report == 1) {
			printf("ERROR: %12s SHELF: %s DISK: %6s PATH ERROR ONLY FOUND %s PATHS\n",hostname,shelfserial,disklabel,diskpaths);
		}
	}
	if ( DEBUG ) { printf("DEBUG %s SHELF: %s DISK: %6s FW: %5s PATHS: %5s\n",hostname,shelfserial,disklabel,diskfw,diskpaths); }
	if ( diskfwcompare != 'NONE' ) {
		if ( diskfw != diskfwcompare ) {
			founderrors='true';
			if ( report == 1 ) {
				printf("ERROR: %12s SHELF: %s DISK: %6s DISK FIRMWARE MISMATCH ERROR DETECTED\n",hostname,shelfserial,disklabel);
			}
		}
	}

}

// --------------------------------------------------------
// Check Log Device
function checkLogDisk(myChassis,myDisk) {

	logfw = safeGet('revision');
	logpaths = safeGet('pathcount');
	loglabel = safeGet('label'); 

	if ( DEBUG ) { printf("DEBUG %s SHELF: %s LOG: %7s FW: %5s PATHS: %5s\n",hostname,shelfserial,loglabel,logfw,logpaths); }
	if ( logpaths != 2 ) {
		founderrors='true';
		if ( report == 1) {
			printf("ERROR: %12s SHELF: %s LOG: %7s PATH ERROR ONLY FOUND %s PATHS\n",hostname,shelfserial,loglabel,logpaths);
		}
	}

// We are seeing some systems get provisioned with newer firmware than we expect
// We need to detect the exact firmware version vs the appliance software and 
// then do a greater than or equal check

	// This minimum is valid for all GIT appliances
	if ( logfw < 9001 ) {
		if ( report == 1) {
			printf("ERROR: %12s SHELF: %s LOG: %7s FIRMWARE: %4s FIRMWARE BELOW MINIMUM RELEASE\n",hostname,shelfserial,loglabel,logfw);
		}
		founderrors='true';
	}
	if ( logfw < 9002 && applianceVersionShort >= 2010081720 ) {
		if ( report == 1) {
			printf("ERROR: %12s SHELF: %s LOG: %7s FIRMWARE: %4s FIRMWARE BELOW MINIMUM FOR AK VERSION\n",hostname,shelfserial,loglabel,logfw);
		}
		founderrors='true';
	}
}

// ---------------------------------------------------------
// checkChassis() - The Chassis
function checkChassis(myChassis) {

	var myDisk; // The current disk being checked
	var disks; // List of Disks
	var diskfw,disklabel,diskpaths; // Disk Attributes
	var chassistype; // The type of chassis we are looking at
	
	// Get back to a know starting state
	run('cd /');
	// Select the chassis
	run('maintenance hardware select ' + myChassis);

	if ( safeGet('faulted') == 'true' ) {
		if ( report == 1) {
			printf("ERROR: %12%s SHELF %s REPORTS FAULTED\n",hostname,shelfserial);
		}
		founderrors = 'true';
		return;
	}

	// get chassis type
	chassistype = safeGet('type');

	// Run Chassis Type Specific Checks
	if ( chassistype == "storage") {
		 checkStorageChassis(myChassis);
	} else {
		if ( safeGet('type') == "system" ) {
			checkSystemChassis(myChassis);
			return;
		}
	}
	// Get back to a know starting state
	run('cd /');
	// Select the chassis
	run('maintenance hardware select ' + myChassis);

	run('select disk');
	disks = list();
	for ( x = 0; x < disks.length; x++) {
		myDisk = disks[x];
		run('select ' + myDisk);
		if ( safeGet('present') ) {
			if ( safeGet('faulted') ) {
				disktype = 'faulted';
			} else {
				disktype = safeGet('type');
			}
		} else {
			disktype = 'missing';
		}
		if ( disktype == "faulted" ) {
			founderrors = 'true';
			if ( report == 1) {
				printf("ERROR: %12s SHELF: %s DISK: %6s FAULTED\n",hostname,shelfserial,myDisk);
			}
		}
		if ( disktype == "missing" ) {
			founderrors = 'true';
			if ( report == 1) {
				printf("ERROR: %12s SHELF: %s DISK: %6s REPORTED AS MISSING - SHOULD IT BE?\n",hostname,shelfserial,myDisk);
			}
		}
		if ( disktype == "data" ) {
			checkDataDisk(myChassis,myDisk);
		}
		if ( disktype == "log" ) {
			checkLogDisk(myChassis,myDisk);
		}
		if ( disktype == "ERROR" ) {
			founderrors='true';
			if ( report == 1) {
				//printf("DEBUG: %s SHELF: %s DISK: %s FAULTED: %s\n",hostname,shelfserial,myDisk,diskfaulted); 
				printf("ERROR: %s SHELF: %s DISK: %s\n",hostname,shelfserial,myDisk); 
			}
		}
		run('cd ..');
	}
}


// ---------------------------------------------------------
// Run the actual Check
function runCheck() {
	run('maintenance hardware');
	chassis = list();
	for (i = 0; i < chassis.length; i++) {
		checkChassis(chassis[i]);
       }
} // END Function runCheck

// ---------------------------------------------------------
// MAIN STARTS HERE

getHostname();

getApplianceVersion();

//printf("Version: %s\n",applianceVersionShort);

// Figure out if this script supports this version
runCheck();

if ( auditcheck == 1 ){
	if ( founderrors == 'false' ) { 
		printf("backend_check_status = 0\n"); 
	}
	else {
		printf("backend_check_status = 1\n");
	}
}
// Report Command
if ( report == 1 ) {
	if ( founderrors == 'false' ) { 
		printf("OK: %s Backend Check Completed: No Errors Found\n",hostname); 
	}
}
printf("==========END_OF_AUDIT_CHECK_chkBackend.aksh==========\n");
printf("==========START_OF_REPORT_chkBackend.aksh==========\n");
//
// Name: chkBackend.aksh
// Author: Jim Stewart
//
// Usage: ssh user@appliance < chkBackend.aksh
//
// Purpose: Detect issues in the backend
//

	// To Enable Debug set to 1 to disable set 0
	var DEBUG = 0;

// Lots of Global Variables

	//Appliance Vars
	var hostname;
	var applianceVersion;
	var applianceVersionShort;

	//Shelf SIM Vars
	var simfwcompare = "NONE";

	//Data Disk Vars
	var diskfwcompare = "NONE";

	//Log Device Vars
	var logs; //List of Logs in a shelf
	var logfw,loglabel,logpaths;

	var founderrors = "false"; // This flag is set true if any error is found
	var auditcheck = 0;
	var report = 1;
//----------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
	try {
		prop = get(getProperty);
	} catch(err) {
		prop = 'ERROR';
	}
	return prop;
}

// ---------------------------------------------------------
// Get Hostname
function getHostname() {
	run('cd /');
	run('maintenance hardware select chassis-000'); 
	hostname=safeGet('name'); 
	run('cd /');
}

// ---------------------------------------------------------
// Get Appliance Version
function getApplianceVersion() {
	run('cd /');
	run('configuration version');
	applianceVersionShort = safeGet('version').split(',')[0].replace(/\./g,"");
	applianceVersion = safeGet('version');
	run('cd /');
}

// ----------------------------------------------------------------------------
// checkSIM() - Check the properties of a SIM
function checkSIM() {
	// Check to see if the sim is present
	if ( safeGet('present') ) {
		// Check to see if the sim is faulted
		simlabel = safeGet('label');
		if (safeGet('faulted')) {
			if ( report == 1) {
				printf("ERROR: %12s SHELF: %s SIM: %s REPORTS FAULTED\n",hostname,shelfserial,simlabel);
			}
			founderrors = 'true';
		} else {
			simfw = safeGet('revision');
	    	if ( simfwcompare == 'NONE' ) {
            	if ( simfw != 'ERROR') {
	            	simfwcompare = simfw;
            	} else {
               		founderrors='TRUE';
            	}
         	}
			if ( simfw != simfwcompare && simfwcompare != 'NONE' ) {
				if ( simfw == 'ERROR' ) {
					if ( report == 1) {
               			printf("ERROR: %12s SHELF: %s SIM: %s UNKNOWN STATE\n",hostname,shelfserial,simlabel);
					}
               		founderrors='TRUE';
            	} else {
					if ( report == 1) {
				   		printf("ERROR: %12s SHELF: %s SIM: %s FIRMWARE: %4s FIRMWARE MISMATCH: %4s on another SIM \n",hostname,shelfserial,simlabel,simfw,simfwcompare);
					}
               		founderrors='TRUE';
				}
			}
			if ( safeGet('part') == 'ERROR' ) {
				if ( report == 1) {
					printf("ERROR: %12s SHELF: %s SIM: %s UNKNOWN PART\n",hostname,shelfserial,simlabel);
				}
    	        founderrors='TRUE';
			}
		}
	} else {
		if ( report == 1) {
			printf("ERROR: %12s SHELF: %s SIM: %s NOT PRESENT\n",hostname,shelfserial,simlabel);
		}
		founderrors = 'true';
	}
}

// ---------------------------------------------------------
// checkStorageChassis() - Check things particular to a storage chassis
function checkStorageChassis(myChassis) {

	// Variables

   // Get back to a know starting state
   run('cd /');
   // Select the chassis
   run('maintenance hardware select ' + myChassis);

	shelfserial = safeGet('serial');

	// Get Slot0 Info
	run('select slot select slot-000');
	checkSIM();
	run('cd ../..');
	// Get Slot1 Info
	run('select slot select slot-001');
	checkSIM();

   // Get back to a know starting state
   run('cd /');

	return 0;
}

function checkSystemChassis(systemchassis) {
}

// ---------------------------------------------------------
// Check Data Disks
// 
// Precondition: State must have disk to be checked selected
//
function checkDataDisk(myChassis,myDisk) {

	diskfw = safeGet('revision'); 
	disklabel = safeGet('label');
	diskpaths = safeGet('pathcount');

	if ( diskpaths != 2 ) {
		founderrors='true';
		if ( report == 1) {
			printf("ERROR: %12s SHELF: %s DISK: %6s PATH ERROR ONLY FOUND %s PATHS\n",hostname,shelfserial,disklabel,diskpaths);
		}
	}
	if ( DEBUG ) { printf("DEBUG %s SHELF: %s DISK: %6s FW: %5s PATHS: %5s\n",hostname,shelfserial,disklabel,diskfw,diskpaths); }
	if ( diskfwcompare != 'NONE' ) {
		if ( diskfw != diskfwcompare ) {
			founderrors='true';
			if ( report == 1 ) {
				printf("ERROR: %12s SHELF: %s DISK: %6s DISK FIRMWARE MISMATCH ERROR DETECTED\n",hostname,shelfserial,disklabel);
			}
		}
	}

}

// --------------------------------------------------------
// Check Log Device
function checkLogDisk(myChassis,myDisk) {

	logfw = safeGet('revision');
	logpaths = safeGet('pathcount');
	loglabel = safeGet('label'); 

	if ( DEBUG ) { printf("DEBUG %s SHELF: %s LOG: %7s FW: %5s PATHS: %5s\n",hostname,shelfserial,loglabel,logfw,logpaths); }
	if ( logpaths != 2 ) {
		founderrors='true';
		if ( report == 1) {
			printf("ERROR: %12s SHELF: %s LOG: %7s PATH ERROR ONLY FOUND %s PATHS\n",hostname,shelfserial,loglabel,logpaths);
		}
	}

// We are seeing some systems get provisioned with newer firmware than we expect
// We need to detect the exact firmware version vs the appliance software and 
// then do a greater than or equal check

	// This minimum is valid for all GIT appliances
	if ( logfw < 9001 ) {
		if ( report == 1) {
			printf("ERROR: %12s SHELF: %s LOG: %7s FIRMWARE: %4s FIRMWARE BELOW MINIMUM RELEASE\n",hostname,shelfserial,loglabel,logfw);
		}
		founderrors='true';
	}
	if ( logfw < 9002 && applianceVersionShort >= 2010081720 ) {
		if ( report == 1) {
			printf("ERROR: %12s SHELF: %s LOG: %7s FIRMWARE: %4s FIRMWARE BELOW MINIMUM FOR AK VERSION\n",hostname,shelfserial,loglabel,logfw);
		}
		founderrors='true';
	}
}

// ---------------------------------------------------------
// checkChassis() - The Chassis
function checkChassis(myChassis) {

	var myDisk; // The current disk being checked
	var disks; // List of Disks
	var diskfw,disklabel,diskpaths; // Disk Attributes
	var chassistype; // The type of chassis we are looking at
	
	// Get back to a know starting state
	run('cd /');
	// Select the chassis
	run('maintenance hardware select ' + myChassis);

	if ( safeGet('faulted') == 'true' ) {
		if ( report == 1) {
			printf("ERROR: %12%s SHELF %s REPORTS FAULTED\n",hostname,shelfserial);
		}
		founderrors = 'true';
		return;
	}

	// get chassis type
	chassistype = safeGet('type');

	// Run Chassis Type Specific Checks
	if ( chassistype == "storage") {
		 checkStorageChassis(myChassis);
	} else {
		if ( safeGet('type') == "system" ) {
			checkSystemChassis(myChassis);
			return;
		}
	}
	// Get back to a know starting state
	run('cd /');
	// Select the chassis
	run('maintenance hardware select ' + myChassis);

	run('select disk');
	disks = list();
	for ( x = 0; x < disks.length; x++) {
		myDisk = disks[x];
		run('select ' + myDisk);
		if ( safeGet('present') ) {
			if ( safeGet('faulted') ) {
				disktype = 'faulted';
			} else {
				disktype = safeGet('type');
			}
		} else {
			disktype = 'missing';
		}
		if ( disktype == "faulted" ) {
			founderrors = 'true';
			if ( report == 1) {
				printf("ERROR: %12s SHELF: %s DISK: %6s FAULTED\n",hostname,shelfserial,myDisk);
			}
		}
		if ( disktype == "missing" ) {
			founderrors = 'true';
			if ( report == 1) {
				printf("ERROR: %12s SHELF: %s DISK: %6s REPORTED AS MISSING - SHOULD IT BE?\n",hostname,shelfserial,myDisk);
			}
		}
		if ( disktype == "data" ) {
			checkDataDisk(myChassis,myDisk);
		}
		if ( disktype == "log" ) {
			checkLogDisk(myChassis,myDisk);
		}
		if ( disktype == "ERROR" ) {
			founderrors='true';
			if ( report == 1) {
				//printf("DEBUG: %s SHELF: %s DISK: %s FAULTED: %s\n",hostname,shelfserial,myDisk,diskfaulted); 
				printf("ERROR: %s SHELF: %s DISK: %s\n",hostname,shelfserial,myDisk); 
			}
		}
		run('cd ..');
	}
}


// ---------------------------------------------------------
// Run the actual Check
function runCheck() {
	run('maintenance hardware');
	chassis = list();
	for (i = 0; i < chassis.length; i++) {
		checkChassis(chassis[i]);
       }
} // END Function runCheck

// ---------------------------------------------------------
// MAIN STARTS HERE

getHostname();

getApplianceVersion();

//printf("Version: %s\n",applianceVersionShort);

// Figure out if this script supports this version
runCheck();

if ( auditcheck == 1 ){
	if ( founderrors == 'false' ) { 
		printf("backend_check_status = 0\n"); 
	}
	else {
		printf("backend_check_status = 1\n");
	}
}
// Report Command
if ( report == 1 ) {
	if ( founderrors == 'false' ) { 
		printf("OK: %s Backend Check Completed: No Errors Found\n",hostname); 
	}
}
printf("==========END_OF_REPORT_chkBackend.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkBlockSize.aksh==========\n");
//
//
// This script will check the block size on zfs to be at least 128k
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'false'; // Track error findings
	var auditcheck = 1;
	var report = 0;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the block size
try { 
	var projects, p, shares, s, myRecordsize;

	run('cd /');
	run('shares');
	projects = list();
	if ( report == 1 ){
		printf("List of projects and its shares with its block size\n");
		printf("---------------------------------------------------\n\n");
	}
	for (p = 0; p < projects.length; p++) {
        run('select ' + projects[p]);
        myRecordsize = get('recordsize');
        if ( report ==1 ){
			print(projects[p] + ": " + myRecordsize + " Bytes\n");
		}
        shares = list();

        for (s = 0; s < shares.length; s++) {
                run('select ' + shares[s]);
                myRecordsize = get('recordsize');
				if ( report == 1 ){ 
                	print("\t" + shares[s] + ": " + myRecordsize + " Bytes\n");
				}
				if ( myRecordsize < 131072 ) {
					founderrors = 'true';
				}
                run('cd ..');
        }
        run('cd ..');
	}
	run('cd /');
} catch(err) { 
}

if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("block_size_check_status = 0\n");
    }
    else {
        printf("block_size_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s Block Size Check Completed: Block size on all ZFS shares are at least 128 KB\n",hostname);
    }
    else {
	    printf("WARNING: %s Block Size Check Completed: Block size on one or more ZFS shares are not at least 128 KB\n",hostname);
    }

}

//END

printf("==========END_OF_AUDIT_CHECK_chkBlockSize.aksh==========\n");
printf("==========START_OF_REPORT_chkBlockSize.aksh==========\n");
//
//
// This script will check the block size on zfs to be at least 128k
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'false'; // Track error findings
	var auditcheck = 0;
	var report = 1;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the block size
try { 
	var projects, p, shares, s, myRecordsize;

	run('cd /');
	run('shares');
	projects = list();
	if ( report == 1 ){
		printf("List of projects and its shares with its block size\n");
		printf("---------------------------------------------------\n\n");
	}
	for (p = 0; p < projects.length; p++) {
        run('select ' + projects[p]);
        myRecordsize = get('recordsize');
        if ( report ==1 ){
			print(projects[p] + ": " + myRecordsize + " Bytes\n");
		}
        shares = list();

        for (s = 0; s < shares.length; s++) {
                run('select ' + shares[s]);
                myRecordsize = get('recordsize');
				if ( report == 1 ){ 
                	print("\t" + shares[s] + ": " + myRecordsize + " Bytes\n");
				}
				if ( myRecordsize < 131072 ) {
					founderrors = 'true';
				}
                run('cd ..');
        }
        run('cd ..');
	}
	run('cd /');
} catch(err) { 
}

if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("block_size_check_status = 0\n");
    }
    else {
        printf("block_size_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s Block Size Check Completed: Block size on all ZFS shares are at least 128 KB\n",hostname);
    }
    else {
	    printf("WARNING: %s Block Size Check Completed: Block size on one or more ZFS shares are not at least 128 KB\n",hostname);
    }

}

//END

printf("==========END_OF_REPORT_chkBlockSize.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkCluster.aksh==========\n");
//
// Name: chkCluster.aksh
// Author: Jim Stewart
//
// Usage: ssh user@appliance < chkCluster.aksh
//
// Purpose: Check for cluster problems
//          
// ----------------------------------------------------------------------------

	// To Enable Debug set to 1 to disable set 0
	var DEBUG = 0;

	//Appliance Vars
	var hostname;

	var founderrors = "false"; // This flag is set true if any error is found
	var auditcheck = 1;
	var report = 0;

//-----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
	try {
		prop = get(getProperty);
	} catch(err) {
		prop = 'ERROR';
	}
	return prop;
}

//-----------------------------------------------------------------------------
// Get Hostname
function getHostname() {
	run('cd /');
	run('maintenance hardware select chassis-000'); 
	hostname=safeGet('name'); 
	run('cd /');
}

//-----------------------------------------------------------------------------
// CHECK CLUSTER LINKS
function clusterLinks() {
	i=0;
	while ( i < 3 ) {
		clusterlink=cluster.listDevices().devs[0].links[i].state;
		clusterlinkname=cluster.listDevices().devs[0].links[i].name;
		if ( clusterlink != "AKCIOS_ACTIVE" ) {
			if ( report == 1) {
				printf("ERROR: %s CLUSTER LINK: %s NOT ACTIVE\n",hostname,clusterlinkname);
			}
			founderrors='true';
		}
		if ( DEBUG ) {printf("DEBUG: %s CLUSTER LINK: %s STATE: %s\n", hostname,clusterlinkname,clusterlink); }
		i++;
	}
}

//-----------------------------------------------------------------------------
function clusterState() {
	run('cd /');
	run('configuration cluster');
	mystate=safeGet('state');
	peerstate=safeGet('peer_state');
	if ( mystate != 'AKCS_CLUSTERED' ) {
		if ( mystate == 'AKCS_OWNER' ) {
			if ( report == 1) {
				//printf("INFO: %s CLUSTER: FAILOVER - THIS NODE OWNS ALL CLUSTER RESOURCES\n",hostname);
			}
			//founderrors='true';
		}
		if ( mystate == 'AKCS_STRIPPED' ) {
			if ( peerstate == 'AKCS_OWNER' ) {
				if ( report == 1) {
					//printf("INFO: %s CLUSTER: FAILOVER - THIS NODE IS STRIPPED\n",hostname);
				}
			} else {
				if ( report == 1) {
            		printf("ERROR: %s CLUSTER: FAILOVER - NO ONE OWNS THE RESOURCES!\n",hostname);
         			founderrors='true';
				}
         }
		}
	} else {
		if ( DEBUG ) {printf("DEBUG: %s CLUSTER: OK\n",hostname); }
	}
}


//-----------------------------------------------------------------------------
// MAIN STARTS HERE

getHostname();
clusterLinks();
clusterState();

if ( auditcheck == 1 ) {
	if ( founderrors == 'false' ) { 
    	printf("cluster_check_status = 0\n"); 
	}
	else {
    	printf("cluster_check_status = 1\n");
	}
}
// Report Command

if ( report == 1 ) {
	if ( founderrors == 'false' ) { 
    	printf("OK: %s Cluster Check Completed: No Errors Found\n",hostname); 
	}
}
printf("==========END_OF_AUDIT_CHECK_chkCluster.aksh==========\n");
printf("==========START_OF_REPORT_chkCluster.aksh==========\n");
//
// Name: chkCluster.aksh
// Author: Jim Stewart
//
// Usage: ssh user@appliance < chkCluster.aksh
//
// Purpose: Check for cluster problems
//          
// ----------------------------------------------------------------------------

	// To Enable Debug set to 1 to disable set 0
	var DEBUG = 0;

	//Appliance Vars
	var hostname;

	var founderrors = "false"; // This flag is set true if any error is found
	var auditcheck = 0;
	var report = 1;

//-----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
	try {
		prop = get(getProperty);
	} catch(err) {
		prop = 'ERROR';
	}
	return prop;
}

//-----------------------------------------------------------------------------
// Get Hostname
function getHostname() {
	run('cd /');
	run('maintenance hardware select chassis-000'); 
	hostname=safeGet('name'); 
	run('cd /');
}

//-----------------------------------------------------------------------------
// CHECK CLUSTER LINKS
function clusterLinks() {
	i=0;
	while ( i < 3 ) {
		clusterlink=cluster.listDevices().devs[0].links[i].state;
		clusterlinkname=cluster.listDevices().devs[0].links[i].name;
		if ( clusterlink != "AKCIOS_ACTIVE" ) {
			if ( report == 1) {
				printf("ERROR: %s CLUSTER LINK: %s NOT ACTIVE\n",hostname,clusterlinkname);
			}
			founderrors='true';
		}
		if ( DEBUG ) {printf("DEBUG: %s CLUSTER LINK: %s STATE: %s\n", hostname,clusterlinkname,clusterlink); }
		i++;
	}
}

//-----------------------------------------------------------------------------
function clusterState() {
	run('cd /');
	run('configuration cluster');
	mystate=safeGet('state');
	peerstate=safeGet('peer_state');
	if ( mystate != 'AKCS_CLUSTERED' ) {
		if ( mystate == 'AKCS_OWNER' ) {
			if ( report == 1) {
				//printf("INFO: %s CLUSTER: FAILOVER - THIS NODE OWNS ALL CLUSTER RESOURCES\n",hostname);
			}
			//founderrors='true';
		}
		if ( mystate == 'AKCS_STRIPPED' ) {
			if ( peerstate == 'AKCS_OWNER' ) {
				if ( report == 1) {
					//printf("INFO: %s CLUSTER: FAILOVER - THIS NODE IS STRIPPED\n",hostname);
				}
			} else {
				if ( report == 1) {
            		printf("ERROR: %s CLUSTER: FAILOVER - NO ONE OWNS THE RESOURCES!\n",hostname);
         			founderrors='true';
				}
         }
		}
	} else {
		if ( DEBUG ) {printf("DEBUG: %s CLUSTER: OK\n",hostname); }
	}
}


//-----------------------------------------------------------------------------
// MAIN STARTS HERE

getHostname();
clusterLinks();
clusterState();

if ( auditcheck == 1 ) {
	if ( founderrors == 'false' ) { 
    	printf("cluster_check_status = 0\n"); 
	}
	else {
    	printf("cluster_check_status = 1\n");
	}
}
// Report Command

if ( report == 1 ) {
	if ( founderrors == 'false' ) { 
    	printf("OK: %s Cluster Check Completed: No Errors Found\n",hostname); 
	}
}
printf("==========END_OF_REPORT_chkCluster.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkDatasets.aksh==========\n");
//
// Name: chkDatasets.aksh
// Author: Jim Stewart
//
// Usage: ssh user@appliance < chkDatasets.aksh
//
// Purpose: Check for large datasets which can impact AKD performance
//          
// ----------------------------------------------------------------------------

	// To Enable Debug set to 1 to disable set 0
	var DEBUG = 0;

	//Appliance Vars
	var hostname;

	var founderrors = "false"; // This flag is set true if any error is found
	// To enable detailed report, set to 1. To disable set to 0
	var report = 0;
	// To enable audit check output(whether it passes or fails), set to 1. To disable set to 0 
	var auditcheck = 1;
//-----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
	try {
		prop = get(getProperty);
	} catch(err) {
		prop = 'ERROR';
	}
	return prop;
}

//-----------------------------------------------------------------------------
// Get Hostname
function getHostname() {
	run('cd /');
	run('maintenance hardware select chassis-000'); 
	hostname=safeGet('name'); 
	run('cd /');
}

//-----------------------------------------------------------------------------
// MAIN STARTS HERE

getHostname();

run('analytics datasets');
datasetlist=list();
x = 0;
loopmax = datasetlist.length;
while ( x < loopmax ) {
	mydataset = datasetlist[x];
	run('select ' + mydataset);
	datasetsize = safeGet('size');
	datasetname = safeGet('name');
	datasetincore = safeGet('incore');
	run('cd ..');
	
	if ( datasetsize > 2147483648) {
		datasetsize = datasetsize / 1073741824;
		if ( report == 1) { printf("WARN: %s DATASET: %s SIZE: %.2fGB SIZE EXCEEDS RECOMMENDED VALUE\n",hostname,datasetname,datasetsize); }
		founderrors = 'true';
// THIS CODEBLOCK WHEN UNCOMMENTED WILL REMOVE LARGE IO.OPS DATASETS, THE USER AUTO CANNOT DO THIS
//		if ( datasetname.match('io.ops*') ) {
//			printf("NUKING DATASET: %s\n",datasetname);
//			run('confirm destroy ' + mydataset);
//			// When you remove a dataset the numbers get reset so you will need to recheck the current dataset number
//			x = x - 1;
//			loopmax = loopmax - 1;
//		}
	}
	if ( DEBUG ) { printf("DEBUG: %s DATASET: %s SIZE: %s\n",hostname,datasetname,datasetsize); }
	x = x + 1 ;

}		

// Audit Check
if ( auditcheck == 1 ) {
	if ( founderrors == 'false' ) { 
    	printf("dataset_check_status = 0\n"); 
	}
	else {
    	printf("dataset_check_status = 1\n");
	}
}
// Report Command
if ( report == 1 ) {
	if ( founderrors == 'false' ) { 
		printf("OK: %s Dataset Size Check Completed: No Errors Found\n",hostname); 
	}
}
//END
printf("==========END_OF_AUDIT_CHECK_chkDatasets.aksh==========\n");
printf("==========START_OF_REPORT_chkDatasets.aksh==========\n");
//
// Name: chkDatasets.aksh
// Author: Jim Stewart
//
// Usage: ssh user@appliance < chkDatasets.aksh
//
// Purpose: Check for large datasets which can impact AKD performance
//          
// ----------------------------------------------------------------------------

	// To Enable Debug set to 1 to disable set 0
	var DEBUG = 0;

	//Appliance Vars
	var hostname;

	var founderrors = "false"; // This flag is set true if any error is found
	// To enable detailed report, set to 1. To disable set to 0
	var report = 1;
	// To enable audit check output(whether it passes or fails), set to 1. To disable set to 0 
	var auditcheck = 0;
//-----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
	try {
		prop = get(getProperty);
	} catch(err) {
		prop = 'ERROR';
	}
	return prop;
}

//-----------------------------------------------------------------------------
// Get Hostname
function getHostname() {
	run('cd /');
	run('maintenance hardware select chassis-000'); 
	hostname=safeGet('name'); 
	run('cd /');
}

//-----------------------------------------------------------------------------
// MAIN STARTS HERE

getHostname();

run('analytics datasets');
datasetlist=list();
x = 0;
loopmax = datasetlist.length;
while ( x < loopmax ) {
	mydataset = datasetlist[x];
	run('select ' + mydataset);
	datasetsize = safeGet('size');
	datasetname = safeGet('name');
	datasetincore = safeGet('incore');
	run('cd ..');
	
	if ( datasetsize > 2147483648) {
		datasetsize = datasetsize / 1073741824;
		if ( report == 1) { printf("WARN: %s DATASET: %s SIZE: %.2fGB SIZE EXCEEDS RECOMMENDED VALUE\n",hostname,datasetname,datasetsize); }
		founderrors = 'true';
// THIS CODEBLOCK WHEN UNCOMMENTED WILL REMOVE LARGE IO.OPS DATASETS, THE USER AUTO CANNOT DO THIS
//		if ( datasetname.match('io.ops*') ) {
//			printf("NUKING DATASET: %s\n",datasetname);
//			run('confirm destroy ' + mydataset);
//			// When you remove a dataset the numbers get reset so you will need to recheck the current dataset number
//			x = x - 1;
//			loopmax = loopmax - 1;
//		}
	}
	if ( DEBUG ) { printf("DEBUG: %s DATASET: %s SIZE: %s\n",hostname,datasetname,datasetsize); }
	x = x + 1 ;

}		

// Audit Check
if ( auditcheck == 1 ) {
	if ( founderrors == 'false' ) { 
    	printf("dataset_check_status = 0\n"); 
	}
	else {
    	printf("dataset_check_status = 1\n");
	}
}
// Report Command
if ( report == 1 ) {
	if ( founderrors == 'false' ) { 
		printf("OK: %s Dataset Size Check Completed: No Errors Found\n",hostname); 
	}
}
//END
printf("==========END_OF_REPORT_chkDatasets.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkIPMPFailback.aksh==========\n");
//
//
// This script will check if the IPMP failback setting is configured properly 
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'true'; // Track error findings
	var auditcheck = 1;
	var report = 0;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the interval
try { 
	run('configuration services ipmp');
	interval=get('interval');
    failback=get('failback'); 
	run('cd /');
} catch(err) { 
	interval="UNKNOWN";
    failback="UNKNOWN";
}

if ( interval == 5000 && failback == '') {
	founderrors='false';
}
if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("ipmp_failback_check_status = 0\n");
    }
    else {
        printf("ipmp_failback_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s IPMP Failback Check Completed: IPMP Failback setting is configured properly\n",hostname);
    }
    else {
	    printf("WARNING: %s IPMP Failback Check Completed: IPMP Failback Setting is not configured properly\n",hostname);
    }

}

//END

printf("==========END_OF_AUDIT_CHECK_chkIPMPFailback.aksh==========\n");
printf("==========START_OF_REPORT_chkIPMPFailback.aksh==========\n");
//
//
// This script will check if the IPMP failback setting is configured properly 
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'true'; // Track error findings
	var auditcheck = 0;
	var report = 1;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the interval
try { 
	run('configuration services ipmp');
	interval=get('interval');
    failback=get('failback'); 
	run('cd /');
} catch(err) { 
	interval="UNKNOWN";
    failback="UNKNOWN";
}

if ( interval == 5000 && failback == '') {
	founderrors='false';
}
if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("ipmp_failback_check_status = 0\n");
    }
    else {
        printf("ipmp_failback_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s IPMP Failback Check Completed: IPMP Failback setting is configured properly\n",hostname);
    }
    else {
	    printf("WARNING: %s IPMP Failback Check Completed: IPMP Failback Setting is not configured properly\n",hostname);
    }

}

//END

printf("==========END_OF_REPORT_chkIPMPFailback.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkIPMPStandby.aksh==========\n");
//
//
// This script will check if the IPMP standby setting is configured properly 
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'false'; // Track error findings
	var auditcheck = 1;
	var report = 0;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
function getValidLinks(){
	try {
		run('configuration net interfaces');
		var allLinks= list()
		for (var i = 0; i < allLinks.length; i++) {
                if (allLinks[i].indexOf("ipmp") != -1) {
					run('select ' + allLinks[i]);
					if ( get('state') == 'up' && get('links')[0].indexOf("ibp") != -1 ) {
						standbys=get('standbys');
    					if (standbys == "" || (get('links')[0] != standbys && get('links')[1] != standbys)){
							founderrors='true';
						} 
					}
                	run('cd ..');
				}
        }
	} catch (err) {
		founderrors='true';
	}
}
// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

getValidLinks()
if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("ipmp_standby_check_status = 0\n");
    }
    else {
        printf("ipmp_standby_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s IPMP Standby Check Completed: IPMP Standby setting is configured properly\n",hostname);
    }
    else {
	    printf("WARNING: %s IPMP Standby Check Completed: IPMP Standby Setting is not configured properly\n",hostname);
    }

}

//END

printf("==========END_OF_AUDIT_CHECK_chkIPMPStandby.aksh==========\n");
printf("==========START_OF_REPORT_chkIPMPStandby.aksh==========\n");
//
//
// This script will check if the IPMP standby setting is configured properly 
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'false'; // Track error findings
	var auditcheck = 0;
	var report = 1;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
function getValidLinks(){
	try {
		run('configuration net interfaces');
		var allLinks= list()
		for (var i = 0; i < allLinks.length; i++) {
                if (allLinks[i].indexOf("ipmp") != -1) {
					run('select ' + allLinks[i]);
					if ( get('state') == 'up' && get('links')[0].indexOf("ibp") != -1 ) {
						standbys=get('standbys');
    					if (standbys == "" || (get('links')[0] != standbys && get('links')[1] != standbys)){
							founderrors='true';
						} 
					}
                	run('cd ..');
				}
        }
	} catch (err) {
		founderrors='true';
	}
}
// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

getValidLinks()
if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("ipmp_standby_check_status = 0\n");
    }
    else {
        printf("ipmp_standby_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s IPMP Standby Check Completed: IPMP Standby setting is configured properly\n",hostname);
    }
    else {
	    printf("WARNING: %s IPMP Standby Check Completed: IPMP Standby Setting is not configured properly\n",hostname);
    }

}

//END

printf("==========END_OF_REPORT_chkIPMPStandby.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkL2ARCHeader.aksh==========\n");
//
// Name: chkL2ArcHeader.aksh
// Author: Andrego Halim
//
// Purpose: Monitor L2Arc Header size on ZFS not to exceed 3GB


	// Appliance Vars
	var hostname;
	var auditcheck = 1;
	var report = 0;
	var founderrors = "false";
//----------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
    try {
        prop = get(getProperty);
    } catch(err) {
        prop = 'ERROR';
    }
    return prop;
}

// ---------------------------------------------------------
// Get Hostname
function getHostname() {
    run('cd /'); 
    run('maintenance hardware select chassis-000');
    hostname=safeGet('name'); 
    run('cd /');
}

function getAllDatasets() {
	run('cd /');
	run('analytics datasets');
    var alldatasets = list();
	run('cd /');

	if ( alldatasets.length == 0 ) {
		founderrors="true"
		if ( report == 1) {
			printf("INFO: No datasets exist in this storage node.\n");
		}
	} 
	else {
        for (var i = 0; i < alldatasets.length; i++) {
			run('analytics datasets select ' + alldatasets[i]);
			var dataset_name= get ('name');
			if ( dataset_name == "arc.size[component]" ) {
				result=run('read 2');
				l2arc_header_size=run('confirm shell echo \"' + result + '\" | grep L2ARC | head -n 1').replace(/^\s\s*/, '').split(" ")[0];
				if (report == 1){
					printf("Statistics from " + alldatasets[i] + "\n");
					printf(result);
				}
				if ( l2arc_header_size > 3072 ) {
					founderrors="true"
					printf("WARNING: %s L2ARC Header Size Check Completed: L2ARC Header Size is currently %s MB, which exceeds the recommended limit of 3072 MB (3GB)\n",hostname,l2arc_header_size);
				}
				break;
			}
			run('cd /');
    	}
	}
}

getHostname();
getAllDatasets();
if ( auditcheck == 1 ){
    if ( founderrors == 'false' ) {
        printf("l2arc_header_check_status = 0\n");
    }
    else {
        printf("l2arc_header_check_status = 1\n");
    }
}
if ( report == 1 ){
	if ( founderrors == 'false' ) {
		printf("OK: %s L2ARC Header Size Check Completed: L2ARC Header size doesn't exceed 3072 MB (3GB).\n", hostname);
	}
}
printf("==========END_OF_AUDIT_CHECK_chkL2ARCHeader.aksh==========\n");
printf("==========START_OF_REPORT_chkL2ARCHeader.aksh==========\n");
//
// Name: chkL2ArcHeader.aksh
// Author: Andrego Halim
//
// Purpose: Monitor L2Arc Header size on ZFS not to exceed 3GB


	// Appliance Vars
	var hostname;
	var auditcheck = 0;
	var report = 1;
	var founderrors = "false";
//----------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
    try {
        prop = get(getProperty);
    } catch(err) {
        prop = 'ERROR';
    }
    return prop;
}

// ---------------------------------------------------------
// Get Hostname
function getHostname() {
    run('cd /'); 
    run('maintenance hardware select chassis-000');
    hostname=safeGet('name'); 
    run('cd /');
}

function getAllDatasets() {
	run('cd /');
	run('analytics datasets');
    var alldatasets = list();
	run('cd /');

	if ( alldatasets.length == 0 ) {
		founderrors="true"
		if ( report == 1) {
			printf("INFO: No datasets exist in this storage node.\n");
		}
	} 
	else {
        for (var i = 0; i < alldatasets.length; i++) {
			run('analytics datasets select ' + alldatasets[i]);
			var dataset_name= get ('name');
			if ( dataset_name == "arc.size[component]" ) {
				result=run('read 2');
				l2arc_header_size=run('confirm shell echo \"' + result + '\" | grep L2ARC | head -n 1').replace(/^\s\s*/, '').split(" ")[0];
				if (report == 1){
					printf("Statistics from " + alldatasets[i] + "\n");
					printf(result);
				}
				if ( l2arc_header_size > 3072 ) {
					founderrors="true"
					printf("WARNING: %s L2ARC Header Size Check Completed: L2ARC Header Size is currently %s MB, which exceeds the recommended limit of 3072 MB (3GB)\n",hostname,l2arc_header_size);
				}
				break;
			}
			run('cd /');
    	}
	}
}

getHostname();
getAllDatasets();
if ( auditcheck == 1 ){
    if ( founderrors == 'false' ) {
        printf("l2arc_header_check_status = 0\n");
    }
    else {
        printf("l2arc_header_check_status = 1\n");
    }
}
if ( report == 1 ){
	if ( founderrors == 'false' ) {
		printf("OK: %s L2ARC Header Size Check Completed: L2ARC Header size doesn't exceed 3072 MB (3GB).\n", hostname);
	}
}
printf("==========END_OF_REPORT_chkL2ARCHeader.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkLock.aksh==========\n");
//
//
// This script will check if the lockd server has reached its limit 
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'true'; // Track error findings
	var auditcheck = 1;
	var report = 0;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Confirm the lock from sharectl
try { 
	lockd=run('confirm shell sharectl get nfs | grep lockd_servers | cut -d "=" -f2');
	if ( lockd == "512\n" ) {
		founderrors = "false";
	}
} catch(err) { 
	// do nothing
}


// Confirm the lock from sus4540-010#
try { 
	lockd=run('confirm shell sus4540-010# svcprop nlockmgr | grep lockd_servers | grep 512'); 
	if ( lockd != "" ) {
		founderrors = "false";
	}
} catch(err) { 
	// do nothing
}

// Confirm the lock from nlockmgr.xml file
try { 
	lockd=run('confirm shell grep lockd_servers /lib/svc/manifest/network/nfs/nlockmgr.xml | grep 512'); 
	if ( lockd != "" ) {
		founderrors = "false";
	}
} catch(err) { 
	// do nothing
}

if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("lock_check_status = 0\n");
    }
    else {
        printf("lock_check_status = 1\n");
    }
}
// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s Lock Check Completed: Lock Daemon Configuration is configured correctly.\n",hostname);
    }
    else {
	    printf("WARNING: %s Lock Check Completed: Lock Daemon Configuration is not configured correctly.\n",hostname);
    }

}

//END
printf("==========END_OF_AUDIT_CHECK_chkLock.aksh==========\n");
printf("==========START_OF_REPORT_chkLock.aksh==========\n");
//
//
// This script will check if the lockd server has reached its limit 
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'true'; // Track error findings
	var auditcheck = 0;
	var report = 1;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Confirm the lock from sharectl
try { 
	lockd=run('confirm shell sharectl get nfs | grep lockd_servers | cut -d "=" -f2');
	if ( lockd == "512\n" ) {
		founderrors = "false";
	}
} catch(err) { 
	// do nothing
}


// Confirm the lock from sus4540-010#
try { 
	lockd=run('confirm shell sus4540-010# svcprop nlockmgr | grep lockd_servers | grep 512'); 
	if ( lockd != "" ) {
		founderrors = "false";
	}
} catch(err) { 
	// do nothing
}

// Confirm the lock from nlockmgr.xml file
try { 
	lockd=run('confirm shell grep lockd_servers /lib/svc/manifest/network/nfs/nlockmgr.xml | grep 512'); 
	if ( lockd != "" ) {
		founderrors = "false";
	}
} catch(err) { 
	// do nothing
}

if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("lock_check_status = 0\n");
    }
    else {
        printf("lock_check_status = 1\n");
    }
}
// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s Lock Check Completed: Lock Daemon Configuration is configured correctly.\n",hostname);
    }
    else {
	    printf("WARNING: %s Lock Check Completed: Lock Daemon Configuration is not configured correctly.\n",hostname);
    }

}

//END
printf("==========END_OF_REPORT_chkLock.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkMaintenance.aksh==========\n");
//
//
// This script will check if ZFS has any outstanding active problems
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'false'; // Track error findings
	var auditcheck = 1;
	var report = 0;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the interval
try { 
	run('maintenance problems');
	var allproblems = list();
    if ( allproblems.length > 0 ) {
		founderrors='true';
        if ( report == 1) {
			problem=run('show');
			printf("%s\n",problem);
        }
    }
	run('cd /');
} catch(err) { 
}

if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("maintenance_check_status = 0\n");
    }
    else {
        printf("maintenance_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s ZFS Maintenance Check Completed: ZFS has no outstanding active problems\n",hostname);
    }
    else {
	    printf("WARNING: %s ZFS Maintenance Check Completed: ZFS has one or more outstanding active problems\n",hostname);
    }

}

//END

printf("==========END_OF_AUDIT_CHECK_chkMaintenance.aksh==========\n");
printf("==========START_OF_REPORT_chkMaintenance.aksh==========\n");
//
//
// This script will check if ZFS has any outstanding active problems
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'false'; // Track error findings
	var auditcheck = 0;
	var report = 1;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the interval
try { 
	run('maintenance problems');
	var allproblems = list();
    if ( allproblems.length > 0 ) {
		founderrors='true';
        if ( report == 1) {
			problem=run('show');
			printf("%s\n",problem);
        }
    }
	run('cd /');
} catch(err) { 
}

if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("maintenance_check_status = 0\n");
    }
    else {
        printf("maintenance_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s ZFS Maintenance Check Completed: ZFS has no outstanding active problems\n",hostname);
    }
    else {
	    printf("WARNING: %s ZFS Maintenance Check Completed: ZFS has one or more outstanding active problems\n",hostname);
    }

}

//END

printf("==========END_OF_REPORT_chkMaintenance.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkNFSDelegation.aksh==========\n");
//
//
// This script will check if the NFSv4 Delegation is properly disabled to avoid hanging problems within ZFS storage
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'true'; // Track error findings
	var auditcheck = 1;
	var report = 0;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the delegation setting
try { 
	run('configuration services nfs');
	enable_delegation=get('enable_delegation');
	run('cd /');
} catch(err) { 
	enable_delegation="UNKNOWN";
}

if ( enable_delegation == '') {
	founderrors='false';
}
if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("nfs_delegation_check_status = 0\n");
    }
    else {
        printf("nfs_delegation_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s NFS Delegation Check Completed: NFSv4 Delegation setting is disabled\n",hostname);
    }
    else {
	    printf("WARNING: %s NFS Delegation Check Completed: NFSv4 Delegation Setting is enabled\n",hostname);
    }

}

//END

printf("==========END_OF_AUDIT_CHECK_chkNFSDelegation.aksh==========\n");
printf("==========START_OF_REPORT_chkNFSDelegation.aksh==========\n");
//
//
// This script will check if the NFSv4 Delegation is properly disabled to avoid hanging problems within ZFS storage
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'true'; // Track error findings
	var auditcheck = 0;
	var report = 1;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the delegation setting
try { 
	run('configuration services nfs');
	enable_delegation=get('enable_delegation');
	run('cd /');
} catch(err) { 
	enable_delegation="UNKNOWN";
}

if ( enable_delegation == '') {
	founderrors='false';
}
if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("nfs_delegation_check_status = 0\n");
    }
    else {
        printf("nfs_delegation_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s NFS Delegation Check Completed: NFSv4 Delegation setting is disabled\n",hostname);
    }
    else {
	    printf("WARNING: %s NFS Delegation Check Completed: NFSv4 Delegation Setting is enabled\n",hostname);
    }

}

//END

printf("==========END_OF_REPORT_chkNFSDelegation.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkNTP_DataCollection.aksh==========\n");
//
//
// This script will be used for data collection on NTP Check 
//

// ----------------------------------------------------------------------------
// VARS

	var auditcheck = 1;
	var report = 0;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}
// ---------------------------------------------------------
// Get Hostname
function getHostname() {
    run('cd /');
    run('maintenance hardware select chassis-000');
    hostname=safeGet('name');
    run('cd /');
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");
getHostname();

// -------------------
// Go get the servers
run('configuration services ntp');
try { 
	servers=get('servers'); 
	run('cd ..');
} catch(err) { 
	servers = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Report Command

if ( report == 1 ) {
	printf("NTP Servers for Storage in %s:%s\n",hostname,servers);
}

//END

printf("==========END_OF_AUDIT_CHECK_chkNTP_DataCollection.aksh==========\n");
printf("==========START_OF_REPORT_chkNTP_DataCollection.aksh==========\n");
//
//
// This script will be used for data collection on NTP Check 
//

// ----------------------------------------------------------------------------
// VARS

	var auditcheck = 0;
	var report = 1;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}
// ---------------------------------------------------------
// Get Hostname
function getHostname() {
    run('cd /');
    run('maintenance hardware select chassis-000');
    hostname=safeGet('name');
    run('cd /');
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");
getHostname();

// -------------------
// Go get the servers
run('configuration services ntp');
try { 
	servers=get('servers'); 
	run('cd ..');
} catch(err) { 
	servers = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Report Command

if ( report == 1 ) {
	printf("NTP Servers for Storage in %s:%s\n",hostname,servers);
}

//END

printf("==========END_OF_REPORT_chkNTP_DataCollection.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkShadows.aksh==========\n");
//
//
// This script will iterate through the shares and find those shares which are
// being shadow migrated. It will throw an error if a shadow has not moved any
// data or if the shadow migration is showing errors.
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'false'; // Track error findings
	var auditcheck = 1;
	var report = 0;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get a listing of projects so we can iterate through them
run('shares');
projects = list();

for (i = 0; i < projects.length; i++) 
{
   // Get a listing of shares so we can iterate through them
   run('select ' + projects[i]);
   shares = list();

   for (j = 0; j < shares.length; j++) 
	{
      run('select ' + shares[j]);
      share = projects[i] + '/' + shares[j];
      shadow = safeGet('shadow');
		if ( shadow != "none" )
		{
			run('shadow');
			shadowerrors=safeGet('errors');
			shadowtransferred=safeGet('transferred');
			// If there are errors or we are not moving data print an error msg
			if ( shadowerrors > 0 || shadowtransferred < 1 )
			{
				if ( report == 1) {
					printf('ERROR: %s SHARE: %s SHADOWSOURCE: %s ERRORS: %s TRANSFERRED: %s\n',hostname, share, shadow, shadowerrors, shadowtransferred);
				}
				founderrors = 'true' ;
			}
			else
			{
				// This line can be uncommented to list all active shadow migrations
				//	printf('INFO: %s SHARE: %s SHADOWSOURCE: %s\n',hostname, share, shadow);
			}
			run('cd ..');
		}
      run('cd ..');
   }
   run('cd ..');
}
if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("shadow_check_status = 0\n");
    }
    else {
        printf("shadow_check_status = 1\n");
    }
}
// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s Shadow Check Completed: No Errors Found\n",hostname);
    }
}

//END
printf("==========END_OF_AUDIT_CHECK_chkShadows.aksh==========\n");
printf("==========START_OF_REPORT_chkShadows.aksh==========\n");
//
//
// This script will iterate through the shares and find those shares which are
// being shadow migrated. It will throw an error if a shadow has not moved any
// data or if the shadow migration is showing errors.
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'false'; // Track error findings
	var auditcheck = 0;
	var report = 1;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get a listing of projects so we can iterate through them
run('shares');
projects = list();

for (i = 0; i < projects.length; i++) 
{
   // Get a listing of shares so we can iterate through them
   run('select ' + projects[i]);
   shares = list();

   for (j = 0; j < shares.length; j++) 
	{
      run('select ' + shares[j]);
      share = projects[i] + '/' + shares[j];
      shadow = safeGet('shadow');
		if ( shadow != "none" )
		{
			run('shadow');
			shadowerrors=safeGet('errors');
			shadowtransferred=safeGet('transferred');
			// If there are errors or we are not moving data print an error msg
			if ( shadowerrors > 0 || shadowtransferred < 1 )
			{
				if ( report == 1) {
					printf('ERROR: %s SHARE: %s SHADOWSOURCE: %s ERRORS: %s TRANSFERRED: %s\n',hostname, share, shadow, shadowerrors, shadowtransferred);
				}
				founderrors = 'true' ;
			}
			else
			{
				// This line can be uncommented to list all active shadow migrations
				//	printf('INFO: %s SHARE: %s SHADOWSOURCE: %s\n',hostname, share, shadow);
			}
			run('cd ..');
		}
      run('cd ..');
   }
   run('cd ..');
}
if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("shadow_check_status = 0\n");
    }
    else {
        printf("shadow_check_status = 1\n");
    }
}
// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s Shadow Check Completed: No Errors Found\n",hostname);
    }
}

//END
printf("==========END_OF_REPORT_chkShadows.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkSnapshotVisibility.aksh==========\n");
//
//
// This script will check if the ZFS Snapshot is properly hidden to avoid Exacheck using old vm.cfg file
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'true'; // Track error findings
	var auditcheck = 1;
	var report = 0;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the snapshot visibility property
try { 
	run('shares select ExalogicControl');
	snapdir=get('snapdir');
	run('cd /');
} catch(err) { 
	snapdir = "UNKNOWN";
}

if (snapdir == 'hidden' || snapdir == 'UNKNOWN') {
	founderrors = 'false';
}

if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("snapshot_visibility_check_status = 0\n");
    }
    else {
        printf("snapshot_visibility_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
		if ( snapdir == 'UNKNOWN' ) {
			printf("INFO: %s Snapshot Visibility Check Completed: No ExalogicControl share was found.\n",hostname);
		}
        else {
			printf("OK: %s Snapshot Visibility Check Completed: ZFS Snapshot is hidden.\n",hostname);
		}
    }
    else {
	  	printf("WARNING: %s Snapshot Visibility Check Completed: ZFS Snapshot is not hidden.\n",hostname);
    }
}

//END
printf("==========END_OF_AUDIT_CHECK_chkSnapshotVisibility.aksh==========\n");
printf("==========START_OF_REPORT_chkSnapshotVisibility.aksh==========\n");
//
//
// This script will check if the ZFS Snapshot is properly hidden to avoid Exacheck using old vm.cfg file
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'true'; // Track error findings
	var auditcheck = 0;
	var report = 1;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the snapshot visibility property
try { 
	run('shares select ExalogicControl');
	snapdir=get('snapdir');
	run('cd /');
} catch(err) { 
	snapdir = "UNKNOWN";
}

if (snapdir == 'hidden' || snapdir == 'UNKNOWN') {
	founderrors = 'false';
}

if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("snapshot_visibility_check_status = 0\n");
    }
    else {
        printf("snapshot_visibility_check_status = 1\n");
    }
}

// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
		if ( snapdir == 'UNKNOWN' ) {
			printf("INFO: %s Snapshot Visibility Check Completed: No ExalogicControl share was found.\n",hostname);
		}
        else {
			printf("OK: %s Snapshot Visibility Check Completed: ZFS Snapshot is hidden.\n",hostname);
		}
    }
    else {
	  	printf("WARNING: %s Snapshot Visibility Check Completed: ZFS Snapshot is not hidden.\n",hostname);
    }
}

//END
printf("==========END_OF_REPORT_chkSnapshotVisibility.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkSpace.aksh==========\n");
//
// Name: chkSpace.aksh
// Author: Paul Johnson
//
// Usage: ssh user@appliance < chkSpace.aksh
//
// Purpose: Check space utilization based on
//	    pool / project / share size


	// Appliance Vars
	var hostname;
	var auditcheck = 1;
	var report = 0;
	var founderrors = "false";
//----------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
    try {
        prop = get(getProperty);
    } catch(err) {
        prop = 'ERROR';
    }
    return prop;
}

// ---------------------------------------------------------
// Get Hostname
function getHostname() {
    run('cd /'); 
    run('maintenance hardware select chassis-000');
    hostname=safeGet('name'); 
    run('cd /');
}


function getSpaceByPool(poolname) {
	if ( report == 1 ) {
		printf("Poolname: %12s\n",poolname);
	}
	run('cd /');
	run('status storage select ' + poolname);

	var poolused = get('used');
	var poolavail = get('avail');
	var poolpercentused = Math.round((poolused/(poolused+poolavail))*100);
	if ( report == 1 ) {

		printf("   Used:\t%s\n",poolused);
		printf("   Avail:\t%s\n",poolavail);
		printf("   Used %%:\t%s %%\n\n",poolpercentused);
	}
	if ( poolpercentused > 80 ) {
		founderrors="true";
		
		if ( report == 1 ) {
			printf("Warning: The pool exceeded 80% of pool capacity. Intensive workload will degrade significantly. To avoid possible performance issues, please expand the pool capacity.\n");
		}
	} 
}

function getSpaceAllPools() {
	run('cd /');
	run('status storage');
    var allpools = list();
	if ( allpools.length == 0 ) {
		if ( report == 1) {
			printf("INFO: No pool exists in this storage node. Please check the other node to examine space utilization.\n");
		}
	} 
	else {
		if ( report == 1 ){
			printf("-----------------------------\n");
			printf("Space Utilization by Pool\n");
			printf("-----------------------------\n");
		}
        for (var i = 0; i < allpools.length; i++) {
			getSpaceByPool(allpools[i]);
    	}
	}
}

function getSpaceByProject(projectname) {
	printf("Project: %12s\n",projectname);
	run('cd /');
	run('shares select ' + projectname);

	var projectquota = get('quota');
	var projectreserv = get('reservation');
	var projectused = get('space_total');
	var projectavail = get('space_available');
	var projectpercentused = Math.round((projectused/(projectused+projectavail))*100);

	printf("   Used: \t%s\n",projectused);
	printf("   Avail:\t%s\n",projectavail);
	printf("   Used %%\t%s %%\n\n",projectpercentused);
}

function getSpaceByShare(projectname,sharename) {
	printf("Share: %12s\n",sharename);
	run('cd /');
	run('shares select ' + projectname + ' select ' + sharename);

	var sharequota = get('quota');
	var sharereserv = get('reservation');
	var shareused = get('space_total');
	var shareavail = get('space_available');
	var sharepercentused = Math.round((shareused/(shareused+shareavail))*100);

        printf("   Used: \t%s\n",shareused);
        printf("   Avail:\t%s\n",shareavail);
        printf("   Used %%\t%s %%\n\n",sharepercentused);
}

function getSpaceAllProjects() {
	run('cd /');
	run('shares');
        var allprojects = list();
        for (var i = 0; i < allprojects.length; i++) {
		getSpaceByProject(allprojects[i]);
        }
}

function getSpaceAllSharesByProject(projectname) {
	run('cd /');
	run('shares select ' + projectname);
	var allshares = list();

	for (var i = 0; i < allshares.length; i++) {
		getSpaceByShare(projectname,allshares[i]);
	}

}
getHostname();
getSpaceAllPools();
if ( auditcheck == 1 ){
    if ( founderrors == 'false' ) {
        printf("space_check_status = 0\n");
    }
    else {
        printf("space_check_status = 1\n");
    }
}
if ( report == 1 ){
	if ( founderrors == 'false' ) {
		printf("OK: %s Space Check Completed: No Errors Found.\n", hostname);
	}
}
printf("==========END_OF_AUDIT_CHECK_chkSpace.aksh==========\n");
printf("==========START_OF_REPORT_chkSpace.aksh==========\n");
//
// Name: chkSpace.aksh
// Author: Paul Johnson
//
// Usage: ssh user@appliance < chkSpace.aksh
//
// Purpose: Check space utilization based on
//	    pool / project / share size


	// Appliance Vars
	var hostname;
	var auditcheck = 0;
	var report = 1;
	var founderrors = "false";
//----------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
    try {
        prop = get(getProperty);
    } catch(err) {
        prop = 'ERROR';
    }
    return prop;
}

// ---------------------------------------------------------
// Get Hostname
function getHostname() {
    run('cd /'); 
    run('maintenance hardware select chassis-000');
    hostname=safeGet('name'); 
    run('cd /');
}


function getSpaceByPool(poolname) {
	if ( report == 1 ) {
		printf("Poolname: %12s\n",poolname);
	}
	run('cd /');
	run('status storage select ' + poolname);

	var poolused = get('used');
	var poolavail = get('avail');
	var poolpercentused = Math.round((poolused/(poolused+poolavail))*100);
	if ( report == 1 ) {

		printf("   Used:\t%s\n",poolused);
		printf("   Avail:\t%s\n",poolavail);
		printf("   Used %%:\t%s %%\n\n",poolpercentused);
	}
	if ( poolpercentused > 80 ) {
		founderrors="true";
		
		if ( report == 1 ) {
			printf("Warning: The pool exceeded 80% of pool capacity. Intensive workload will degrade significantly. To avoid possible performance issues, please expand the pool capacity.\n");
		}
	} 
}

function getSpaceAllPools() {
	run('cd /');
	run('status storage');
    var allpools = list();
	if ( allpools.length == 0 ) {
		if ( report == 1) {
			printf("INFO: No pool exists in this storage node. Please check the other node to examine space utilization.\n");
		}
	} 
	else {
		if ( report == 1 ){
			printf("-----------------------------\n");
			printf("Space Utilization by Pool\n");
			printf("-----------------------------\n");
		}
        for (var i = 0; i < allpools.length; i++) {
			getSpaceByPool(allpools[i]);
    	}
	}
}

function getSpaceByProject(projectname) {
	printf("Project: %12s\n",projectname);
	run('cd /');
	run('shares select ' + projectname);

	var projectquota = get('quota');
	var projectreserv = get('reservation');
	var projectused = get('space_total');
	var projectavail = get('space_available');
	var projectpercentused = Math.round((projectused/(projectused+projectavail))*100);

	printf("   Used: \t%s\n",projectused);
	printf("   Avail:\t%s\n",projectavail);
	printf("   Used %%\t%s %%\n\n",projectpercentused);
}

function getSpaceByShare(projectname,sharename) {
	printf("Share: %12s\n",sharename);
	run('cd /');
	run('shares select ' + projectname + ' select ' + sharename);

	var sharequota = get('quota');
	var sharereserv = get('reservation');
	var shareused = get('space_total');
	var shareavail = get('space_available');
	var sharepercentused = Math.round((shareused/(shareused+shareavail))*100);

        printf("   Used: \t%s\n",shareused);
        printf("   Avail:\t%s\n",shareavail);
        printf("   Used %%\t%s %%\n\n",sharepercentused);
}

function getSpaceAllProjects() {
	run('cd /');
	run('shares');
        var allprojects = list();
        for (var i = 0; i < allprojects.length; i++) {
		getSpaceByProject(allprojects[i]);
        }
}

function getSpaceAllSharesByProject(projectname) {
	run('cd /');
	run('shares select ' + projectname);
	var allshares = list();

	for (var i = 0; i < allshares.length; i++) {
		getSpaceByShare(projectname,allshares[i]);
	}

}
getHostname();
getSpaceAllPools();
if ( auditcheck == 1 ){
    if ( founderrors == 'false' ) {
        printf("space_check_status = 0\n");
    }
    else {
        printf("space_check_status = 1\n");
    }
}
if ( report == 1 ){
	if ( founderrors == 'false' ) {
		printf("OK: %s Space Check Completed: No Errors Found.\n", hostname);
	}
}
printf("==========END_OF_REPORT_chkSpace.aksh==========\n");
printf("==========START_OF_AUDIT_CHECK_chkVersion.aksh==========\n");
//
//
// This script will check if the firmware version is supported 
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'true'; // Track error findings
	var auditcheck = 1;
	var report = 0;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the firmware version
try { 
	run('configuration version'); 
	version=get('version'); 
	run('cd ..');
} catch(err) { 
	version = "UNKNOWN";
}

var supported_version = new Array("2010.08.17.1.1,1-1.16","2010.08.17.3.0,1-1.25", "2011.04.24.1.0,1-1.8", "2011.04.24.4.0,1-1.21", "2011.04.24.4.1,1-1.26");
for (var i = 0; i < supported_version.length; i++) {
	if ( supported_version[i] == version ) {
		founderrors = 'false';
		break;
	}
}
if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("version_check_status = 0\n");
    }
    else {
        printf("version_check_status = 1\n");
    }
}
// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s Version Check Completed: Current firmware version %s is supported\n",hostname,version);
    }
    else {
	    printf("WARNING: %s Version Check Completed: Current firmware version %s is not supported\n",hostname,version);
    }

}

//END
printf("==========END_OF_AUDIT_CHECK_chkVersion.aksh==========\n");
printf("==========START_OF_REPORT_chkVersion.aksh==========\n");
//
//
// This script will check if the firmware version is supported 
//

// ----------------------------------------------------------------------------
// VARS

	var founderrors = 'true'; // Track error findings
	var auditcheck = 0;
	var report = 1;

// ----------------------------------------------------------------------------
// safeGet() Gets properties and captures errors
function safeGet(getProperty) {
        try {
                prop = get(getProperty);
        } catch(err) {
                prop = 'none';
        }
        return prop;
}

// ----------------------------------------------------------------------------
// MAIN STARTS HERE	

// Get to a known context
run("cd /");

// -------------------
// Go get the hostname
run('maintenance hardware');
try { 
	run('select chassis-000'); 
	hostname=get('name'); 
	run('cd ..');
} catch(err) { 
	hostname = "UNKNOWN";
}

// Get to a known context
run("cd /");

// Get the firmware version
try { 
	run('configuration version'); 
	version=get('version'); 
	run('cd ..');
} catch(err) { 
	version = "UNKNOWN";
}

var supported_version = new Array("2010.08.17.1.1,1-1.16","2010.08.17.3.0,1-1.25", "2011.04.24.1.0,1-1.8", "2011.04.24.4.0,1-1.21", "2011.04.24.4.1,1-1.26");
for (var i = 0; i < supported_version.length; i++) {
	if ( supported_version[i] == version ) {
		founderrors = 'false';
		break;
	}
}
if ( auditcheck == 1 ) {
    if ( founderrors == 'false' ) {
        printf("version_check_status = 0\n");
    }
    else {
        printf("version_check_status = 1\n");
    }
}
// Report Command

if ( report == 1 ) {
    if ( founderrors == 'false' ) {
        printf("OK: %s Version Check Completed: Current firmware version %s is supported\n",hostname,version);
    }
    else {
	    printf("WARNING: %s Version Check Completed: Current firmware version %s is not supported\n",hostname,version);
    }

}

//END
printf("==========END_OF_REPORT_chkVersion.aksh==========\n");
.
